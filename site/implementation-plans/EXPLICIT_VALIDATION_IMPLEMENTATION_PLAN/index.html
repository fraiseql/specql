<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
      <link rel="shortcut icon" href="../../img/favicon.ico" />
    <title>Implementation Plan: Explicit Validation &amp; Recalculation Pattern - SpecQL Documentation</title>
    <link rel="stylesheet" href="../../css/theme.css" />
    <link rel="stylesheet" href="../../css/theme_extra.css" />
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github.min.css" />
    
      <script>
        // Current page data
        var mkdocs_page_name = "Implementation Plan: Explicit Validation \u0026amp; Recalculation Pattern";
        var mkdocs_page_input_path = "implementation-plans/EXPLICIT_VALIDATION_IMPLEMENTATION_PLAN.md";
        var mkdocs_page_url = null;
      </script>
    
    <!--[if lt IE 9]>
      <script src="../../js/html5shiv.min.js"></script>
    <![endif]-->
      <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
      <script>hljs.highlightAll();</script> 
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
          <a href="../.." class="icon icon-home"> SpecQL Documentation
        </a><div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../../search.html" method="get">
      <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../..">Home</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="" href="../../getting-started/">Getting Started</a>
                </li>
              </ul>
              <p class="caption"><span class="caption-text">Guides</span></p>
              <ul>
                  <li class="toctree-l1"><a class="" href="../../guides/mutation-patterns/">Mutation Patterns</a>
                  </li>
                  <li class="toctree-l1"><a class="" href="../../guides/test-generation/">Test Generation</a>
                  </li>
                  <li class="toctree-l1"><a class="" href="../../guides/cli/">CLI</a>
                  </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="" href="../../reference/">Reference</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="" href="../../examples/">Examples</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="" href="../../tutorials/">Tutorials</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="" href="../../best-practices/">Best Practices</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="" href="../../troubleshooting/">Troubleshooting</a>
                </li>
              </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">
      <nav class="wy-nav-top" role="navigation" aria-label="Mobile navigation menu">
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../..">SpecQL Documentation</a>
        
      </nav>
      <div class="wy-nav-content">
        <div class="rst-content"><div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../.." class="icon icon-home" aria-label="Docs"></a></li>
      <li class="breadcrumb-item active">Implementation Plan: Explicit Validation &amp; Recalculation Pattern</li>
    <li class="wy-breadcrumbs-aside">
    </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
            <div class="section" itemprop="articleBody">
              
                <h1 id="implementation-plan-explicit-validation-recalculation-pattern">Implementation Plan: Explicit Validation &amp; Recalculation Pattern</h1>
<p><strong>Status</strong>: üéØ Detailed Phased Plan
<strong>Timeline</strong>: 7 days (Team B Week 2 - Days 7-13)
<strong>Dependencies</strong>: Phases 1-6 of Team B completed
<strong>Related Docs</strong>:
- <code>EXPLICIT_VALIDATION_PATTERN.md</code>
- <code>EXPLICIT_PATH_RECALCULATION.md</code>
- <code>TEAM_B_DATABASE_DECISIONS_PLAN.md</code></p>
<hr />
<h2 id="overview">üìã Overview</h2>
<p>This plan refactors <strong>Phase 7</strong> of Team B from trigger-based to explicit validation, and adds explicit identifier recalculation to complete the pattern.</p>
<h3 id="what-were-replacing">What We're Replacing</h3>
<p><strong>OLD (Trigger-Based)</strong>:
- ‚ùå <code>prevent_cycle</code> trigger (hidden validation)
- ‚ùå <code>check_sequence_limit</code> trigger (hidden validation)
- ‚ùå <code>check_depth_limit</code> trigger (hidden validation)
- ‚ùå Auto-calculated identifiers (no explicit recalculation)</p>
<p><strong>NEW (Explicit Pattern)</strong>:
- ‚úÖ <code>validate_hierarchy_change()</code> - Called explicitly
- ‚úÖ <code>validate_identifier_sequence()</code> - Called explicitly
- ‚úÖ <code>recalculate_identifier()</code> - Called explicitly (like <code>recalculate_tree_path()</code>)
- ‚úÖ All validations and recalculations visible in mutation code</p>
<hr />
<h2 id="success-criteria">üéØ Success Criteria</h2>
<ul>
<li>[ ] Zero triggers for business logic validation</li>
<li>[ ] All validations called explicitly from mutations</li>
<li>[ ] Identifier recalculation works like path recalculation</li>
<li>[ ] Validation functions return structured errors (not exceptions)</li>
<li>[ ] Team C templates auto-generate explicit calls</li>
<li>[ ] 90%+ test coverage on all validation logic</li>
<li>[ ] Performance equivalent or better than triggers</li>
<li>[ ] Clear migration path from trigger-based code</li>
</ul>
<hr />
<h2 id="phased-implementation">üìÖ Phased Implementation</h2>
<h3 id="phase-1-core-types-validation-functions-days-7-8"><strong>Phase 1: Core Types &amp; Validation Functions</strong> (Days 7-8)</h3>
<p><strong>Objective</strong>: Create foundation types and validation functions</p>
<p><strong>TDD Cycle 1.1: Validation Error Type</strong></p>
<h4 id="red-write-failing-test">üî¥ RED: Write Failing Test</h4>
<p><strong>File</strong>: <code>tests/unit/schema/test_validation_types.py</code> (NEW)</p>
<pre><code class="language-python">&quot;&quot;&quot;Test validation error types.&quot;&quot;&quot;

import pytest
from tests.utils.db_test import execute_sql, execute_query


class TestValidationErrorType:
    &quot;&quot;&quot;Test core.hierarchy_validation_error composite type.&quot;&quot;&quot;

    def test_create_validation_error(self, db):
        &quot;&quot;&quot;Should create validation error with all fields.&quot;&quot;&quot;
        result = execute_query(db, &quot;&quot;&quot;
            SELECT ROW(
                'circular_reference',
                'Circular reference detected',
                'Choose a different parent',
                '{&quot;node_pk&quot;: 5, &quot;parent_pk&quot;: 10}'::jsonb
            )::core.hierarchy_validation_error AS error;
        &quot;&quot;&quot;)

        assert result['error']['error_code'] == 'circular_reference'
        assert result['error']['error_message'] == 'Circular reference detected'
        assert result['error']['hint'] == 'Choose a different parent'
        assert result['error']['detail']['node_pk'] == 5

    def test_null_validation_error_means_valid(self, db):
        &quot;&quot;&quot;NULL error should indicate validation passed.&quot;&quot;&quot;
        result = execute_query(db, &quot;&quot;&quot;
            SELECT NULL::core.hierarchy_validation_error AS error;
        &quot;&quot;&quot;)

        assert result['error'] is None
</code></pre>
<p><strong>Expected</strong>: ‚ùå FAIL - Type does not exist</p>
<h4 id="green-minimal-implementation">üü¢ GREEN: Minimal Implementation</h4>
<p><strong>File</strong>: <code>templates/sql/000_types.sql.jinja2</code> (UPDATE)</p>
<p>Add to existing file:</p>
<pre><code class="language-sql">-- Validation error type for explicit validation functions
CREATE TYPE core.hierarchy_validation_error AS (
    error_code TEXT,
    error_message TEXT,
    hint TEXT,
    detail JSONB
);

COMMENT ON TYPE core.hierarchy_validation_error IS
'Return type for validation functions. NULL indicates validation passed.

Fields:
- error_code: Machine-readable error code (e.g., ''circular_reference'')
- error_message: Human-readable error message
- hint: Suggestion for fixing the error
- detail: Additional context as JSONB

Used by:
- core.validate_hierarchy_change()
- core.validate_identifier_sequence()

Example usage:
  v_error := core.validate_hierarchy_change(...);
  IF v_error IS NOT NULL THEN
    -- Handle error
    RETURN error_response(v_error);
  END IF;';
</code></pre>
<p><strong>Expected</strong>: ‚úÖ PASS</p>
<h4 id="refactor-add-type-helper-function">üîß REFACTOR: Add Type Helper Function</h4>
<pre><code class="language-sql">-- Helper to convert validation error to JSONB
CREATE OR REPLACE FUNCTION core.validation_error_to_jsonb(
    error core.hierarchy_validation_error
) RETURNS JSONB AS $$
BEGIN
    IF error IS NULL THEN
        RETURN NULL;
    END IF;

    RETURN jsonb_build_object(
        'code', error.error_code,
        'message', error.error_message,
        'hint', error.hint,
        'detail', error.detail
    );
END;
$$ LANGUAGE plpgsql IMMUTABLE;
</code></pre>
<h4 id="qa-run-full-test-suite">‚úÖ QA: Run Full Test Suite</h4>
<pre><code class="language-bash">uv run pytest tests/unit/schema/test_validation_types.py -v
uv run pytest --tb=short  # Ensure no regressions
</code></pre>
<hr />
<p><strong>TDD Cycle 1.2: Hierarchy Validation Function</strong></p>
<h4 id="red-write-failing-test_1">üî¥ RED: Write Failing Test</h4>
<p><strong>File</strong>: <code>tests/unit/schema/test_validate_hierarchy.py</code> (NEW)</p>
<pre><code class="language-python">&quot;&quot;&quot;Test core.validate_hierarchy_change() function.&quot;&quot;&quot;

import pytest
from tests.utils.db_test import execute_sql, execute_query, setup_hierarchy


class TestValidateHierarchyChange:
    &quot;&quot;&quot;Test hierarchy validation function.&quot;&quot;&quot;

    @pytest.fixture
    def sample_hierarchy(self, db):
        &quot;&quot;&quot;Create sample hierarchy for testing.

        Structure:
            1 (root)
            ‚îú‚îÄ‚îÄ 2
            ‚îÇ   ‚îî‚îÄ‚îÄ 3
            ‚îî‚îÄ‚îÄ 4
        &quot;&quot;&quot;
        execute_sql(db, &quot;&quot;&quot;
            CREATE SCHEMA IF NOT EXISTS test_schema;

            CREATE TABLE test_schema.tb_location (
                pk_location INTEGER PRIMARY KEY,
                id UUID DEFAULT gen_random_uuid(),
                path ltree NOT NULL,
                fk_parent_location INTEGER REFERENCES test_schema.tb_location(pk_location)
            );

            INSERT INTO test_schema.tb_location (pk_location, path, fk_parent_location) VALUES
                (1, '1', NULL),
                (2, '1.2', 1),
                (3, '1.2.3', 2),
                (4, '1.4', 1);
        &quot;&quot;&quot;)
        yield
        execute_sql(db, &quot;DROP SCHEMA test_schema CASCADE;&quot;)

    def test_valid_parent_change(self, db, sample_hierarchy):
        &quot;&quot;&quot;Should return NULL for valid parent change.&quot;&quot;&quot;
        # Move node 3 from under 2 to under 4 (valid)
        result = execute_query(db, &quot;&quot;&quot;
            SELECT core.validate_hierarchy_change(
                'location',
                3,      -- node_pk
                4,      -- new_parent_pk
                20,     -- max_depth
                true,   -- check_cycle
                true    -- check_depth
            ) AS error;
        &quot;&quot;&quot;)

        assert result['error'] is None

    def test_circular_reference_detected(self, db, sample_hierarchy):
        &quot;&quot;&quot;Should detect circular reference (parent is descendant).&quot;&quot;&quot;
        # Try to move node 2 under its child node 3 (circular!)
        result = execute_query(db, &quot;&quot;&quot;
            SELECT core.validate_hierarchy_change(
                'location',
                2,      -- node_pk (parent of 3)
                3,      -- new_parent_pk (child of 2) - CIRCULAR!
                20,
                true,
                true
            ) AS error;
        &quot;&quot;&quot;)

        error = result['error']
        assert error is not None
        assert error['error_code'] == 'circular_reference'
        assert 'descendant' in error['error_message'].lower()
        assert error['detail']['node_pk'] == 2
        assert error['detail']['parent_pk'] == 3

    def test_depth_limit_exceeded(self, db, sample_hierarchy):
        &quot;&quot;&quot;Should detect depth limit violation.&quot;&quot;&quot;
        # Create deep hierarchy (19 levels)
        execute_sql(db, &quot;&quot;&quot;
            INSERT INTO test_schema.tb_location (pk_location, path, fk_parent_location)
            SELECT
                i,
                ('1.' || array_to_string(array_agg(j ORDER BY j), '.'))::ltree,
                i - 1
            FROM generate_series(5, 19) i
            CROSS JOIN LATERAL generate_series(2, i) j
            GROUP BY i;
        &quot;&quot;&quot;)

        # Try to add one more level (would be 21, exceeds max 20)
        result = execute_query(db, &quot;&quot;&quot;
            SELECT core.validate_hierarchy_change(
                'location',
                99,     -- new node
                19,     -- parent at depth 19
                20,     -- max_depth
                false,  -- skip cycle check
                true    -- check depth
            ) AS error;
        &quot;&quot;&quot;)

        error = result['error']
        assert error is not None
        assert error['error_code'] == 'depth_limit_exceeded'
        assert error['detail']['new_depth'] == 20
        assert error['detail']['max_depth'] == 20

    def test_node_not_found(self, db, sample_hierarchy):
        &quot;&quot;&quot;Should return error if node doesn't exist.&quot;&quot;&quot;
        result = execute_query(db, &quot;&quot;&quot;
            SELECT core.validate_hierarchy_change(
                'location',
                999,    -- non-existent node
                1,
                20,
                true,
                true
            ) AS error;
        &quot;&quot;&quot;)

        error = result['error']
        assert error is not None
        assert error['error_code'] == 'node_not_found'
        assert '999' in error['error_message']

    def test_skip_cycle_check_for_performance(self, db, sample_hierarchy):
        &quot;&quot;&quot;Should skip cycle check if check_cycle=false.&quot;&quot;&quot;
        # This would be circular, but we skip the check
        result = execute_query(db, &quot;&quot;&quot;
            SELECT core.validate_hierarchy_change(
                'location',
                2,
                3,
                20,
                false,  -- SKIP cycle check
                false   -- SKIP depth check
            ) AS error;
        &quot;&quot;&quot;)

        # Should pass because checks are skipped
        assert result['error'] is None
</code></pre>
<p><strong>Expected</strong>: ‚ùå FAIL - Function does not exist</p>
<h4 id="green-minimal-implementation_1">üü¢ GREEN: Minimal Implementation</h4>
<p><strong>File</strong>: <code>templates/sql/hierarchy/validate_hierarchy_change.sql.jinja2</code> (NEW)</p>
<pre><code class="language-sql">-- Validate hierarchy changes BEFORE they happen
-- Returns NULL if valid, error object if invalid
-- NO TRIGGERS - Called explicitly from mutations!

CREATE OR REPLACE FUNCTION core.validate_hierarchy_change(
    entity TEXT,
    node_pk INTEGER,                    -- Node being modified
    new_parent_pk INTEGER DEFAULT NULL, -- New parent (NULL for root)
    max_depth INTEGER DEFAULT 20,       -- Framework config
    check_cycle BOOLEAN DEFAULT TRUE,   -- Skip for performance if known safe
    check_depth BOOLEAN DEFAULT TRUE    -- Skip for performance if known safe
) RETURNS core.hierarchy_validation_error AS $$
DECLARE
    v_schema TEXT;
    v_table TEXT;
    v_pk_column TEXT;
    v_parent_column TEXT;
    v_node_path ltree;
    v_parent_path ltree;
    v_new_depth INTEGER;
    v_error core.hierarchy_validation_error;
    dyn_sql TEXT;
BEGIN
    IF entity IS NULL THEN
        RAISE EXCEPTION 'Parameter &quot;entity&quot; must not be NULL';
    END IF;

    -- Construct dynamic identifiers
    v_table := format('tb_%s', entity);
    v_pk_column := format('pk_%s', entity);
    v_parent_column := format('fk_parent_%s', entity);

    -- Find schema dynamically (search expected schemas)
    SELECT table_schema INTO v_schema
    FROM information_schema.tables
    WHERE table_name = v_table
      AND table_schema IN ('core', 'management', 'catalog', 'tenant', 'test_schema')
    LIMIT 1;

    IF v_schema IS NULL THEN
        v_error.error_code := 'table_not_found';
        v_error.error_message := format('Table &quot;tb_%s&quot; not found in any expected schema', entity);
        v_error.hint := 'Verify entity name is correct';
        RETURN v_error;
    END IF;

    -- Get current node's path
    dyn_sql := format($q$
        SELECT path FROM %I.%I WHERE %I = $1;
    $q$, v_schema, v_table, v_pk_column);
    EXECUTE dyn_sql INTO v_node_path USING node_pk;

    IF v_node_path IS NULL THEN
        v_error.error_code := 'node_not_found';
        v_error.error_message := format('%s with pk=%s not found', entity, node_pk);
        v_error.hint := 'Verify the node exists and is not deleted';
        v_error.detail := jsonb_build_object('node_pk', node_pk);
        RETURN v_error;
    END IF;

    -- If making root node, no further validation needed
    IF new_parent_pk IS NULL THEN
        RETURN NULL;  -- Valid (root node)
    END IF;

    -- Get new parent's path
    dyn_sql := format($q$
        SELECT path FROM %I.%I WHERE %I = $1;
    $q$, v_schema, v_table, v_pk_column);
    EXECUTE dyn_sql INTO v_parent_path USING new_parent_pk;

    IF v_parent_path IS NULL THEN
        v_error.error_code := 'parent_not_found';
        v_error.error_message := format('Parent %s with pk=%s not found', entity, new_parent_pk);
        v_error.hint := 'Verify the parent exists and is not deleted';
        v_error.detail := jsonb_build_object('parent_pk', new_parent_pk);
        RETURN v_error;
    END IF;

    -- VALIDATION 1: Check for circular reference (parent is descendant of node)
    IF check_cycle THEN
        IF v_parent_path &lt;@ v_node_path THEN
            v_error.error_code := 'circular_reference';
            v_error.error_message := format(
                'Circular reference: %s (pk=%s) cannot be moved under its own descendant (pk=%s)',
                entity, node_pk, new_parent_pk
            );
            v_error.hint := 'Choose a parent that is not a descendant of this node';
            v_error.detail := jsonb_build_object(
                'node_path', v_node_path::text,
                'parent_path', v_parent_path::text,
                'node_pk', node_pk,
                'parent_pk', new_parent_pk
            );
            RETURN v_error;
        END IF;
    END IF;

    -- VALIDATION 2: Check depth limit (new parent path + 1 level)
    IF check_depth THEN
        v_new_depth := nlevel(v_parent_path) + 1;

        IF v_new_depth &gt; max_depth THEN
            v_error.error_code := 'depth_limit_exceeded';
            v_error.error_message := format(
                'Depth limit exceeded: moving %s (pk=%s) would create depth %s (max: %s)',
                entity, node_pk, v_new_depth, max_depth
            );
            v_error.hint := 'Flatten the hierarchy or increase max_depth in framework config';
            v_error.detail := jsonb_build_object(
                'current_depth', nlevel(v_node_path),
                'new_depth', v_new_depth,
                'max_depth', max_depth,
                'parent_path', v_parent_path::text
            );
            RETURN v_error;
        ELSIF v_new_depth &gt; (max_depth * 0.75) THEN
            -- Soft warning at 75% threshold
            RAISE WARNING 'Approaching depth limit: % of % levels (path: %)',
                v_new_depth, max_depth, v_parent_path || node_pk::text;
        END IF;
    END IF;

    -- All validations passed
    RETURN NULL;
END;
$$ LANGUAGE plpgsql;

COMMENT ON FUNCTION core.validate_hierarchy_change IS
'Validate hierarchy parent changes BEFORE they happen.

Explicit over Implicit: NO TRIGGERS! Mutations call this explicitly.

Returns NULL if valid, returns error object if invalid.

Validations:
1. Circular reference check (parent is not descendant of node)
2. Depth limit check (new depth would not exceed max)

Example usage in mutations:
  DECLARE
    v_validation_error core.hierarchy_validation_error;
  BEGIN
    -- Validate before UPDATE
    v_validation_error := core.validate_hierarchy_change(
        ''location'',
        v_location_pk,
        v_new_parent_pk,
        max_depth =&gt; 20,
        check_cycle =&gt; true,
        check_depth =&gt; true
    );

    IF v_validation_error IS NOT NULL THEN
        -- Return error response
        RETURN error_response(v_validation_error);
    END IF;

    -- Safe to proceed with UPDATE
  END;

Based on explicit pattern from recalculate_tree_path().';
</code></pre>
<p><strong>Expected</strong>: ‚úÖ PASS</p>
<h4 id="refactor-add-performance-optimization">üîß REFACTOR: Add Performance Optimization</h4>
<pre><code class="language-sql">-- Add index hint comments for query planner
-- (Already covered by existing indexes on path column)

-- Consider adding cached depth column if depth checks become bottleneck
-- (Future optimization if needed)
</code></pre>
<h4 id="qa-run-full-test-suite_1">‚úÖ QA: Run Full Test Suite</h4>
<pre><code class="language-bash">uv run pytest tests/unit/schema/test_validate_hierarchy.py -v
uv run pytest tests/unit/schema/ -v
uv run pytest --tb=short
</code></pre>
<hr />
<p><strong>TDD Cycle 1.3: Identifier Sequence Validation</strong></p>
<h4 id="red-write-failing-test_2">üî¥ RED: Write Failing Test</h4>
<p><strong>File</strong>: <code>tests/unit/schema/test_validate_identifier_sequence.py</code> (NEW)</p>
<pre><code class="language-python">&quot;&quot;&quot;Test core.validate_identifier_sequence() function.&quot;&quot;&quot;

import pytest
from tests.utils.db_test import execute_sql, execute_query


class TestValidateIdentifierSequence:
    &quot;&quot;&quot;Test identifier sequence validation function.&quot;&quot;&quot;

    @pytest.fixture
    def sample_table(self, db):
        &quot;&quot;&quot;Create sample table with identifiers.&quot;&quot;&quot;
        execute_sql(db, &quot;&quot;&quot;
            CREATE SCHEMA IF NOT EXISTS test_schema;

            CREATE TABLE test_schema.tb_product (
                pk_product INTEGER PRIMARY KEY,
                tenant_id UUID,
                identifier TEXT NOT NULL,
                sequence_number INTEGER NOT NULL DEFAULT 1,
                UNIQUE (tenant_id, identifier, sequence_number)
            );

            -- Create 50 variants of 'widget'
            INSERT INTO test_schema.tb_product (pk_product, tenant_id, identifier, sequence_number)
            SELECT
                i,
                'tenant-123'::uuid,
                'widget',
                i
            FROM generate_series(1, 50) i;
        &quot;&quot;&quot;)
        yield
        execute_sql(db, &quot;DROP SCHEMA test_schema CASCADE;&quot;)

    def test_valid_sequence_number(self, db, sample_table):
        &quot;&quot;&quot;Should return NULL for valid sequence number.&quot;&quot;&quot;
        result = execute_query(db, &quot;&quot;&quot;
            SELECT core.validate_identifier_sequence(
                'product',
                'widget',
                51,
                'tenant-123'::uuid,
                100  -- max_duplicates
            ) AS error;
        &quot;&quot;&quot;)

        assert result['error'] is None

    def test_sequence_limit_exceeded(self, db, sample_table):
        &quot;&quot;&quot;Should return error when sequence exceeds limit.&quot;&quot;&quot;
        result = execute_query(db, &quot;&quot;&quot;
            SELECT core.validate_identifier_sequence(
                'product',
                'widget',
                101,     -- exceeds max 100
                'tenant-123'::uuid,
                100
            ) AS error;
        &quot;&quot;&quot;)

        error = result['error']
        assert error is not None
        assert error['error_code'] == 'sequence_limit_exceeded'
        assert 'widget' in error['error_message']
        assert error['detail']['sequence_number'] == 101
        assert error['detail']['max_duplicates'] == 100

    def test_warning_at_50_percent(self, db, sample_table, caplog):
        &quot;&quot;&quot;Should raise warning at 50% of limit.&quot;&quot;&quot;
        # 51 is &gt; 50% of 100
        result = execute_query(db, &quot;&quot;&quot;
            SELECT core.validate_identifier_sequence(
                'product',
                'widget',
                51,
                'tenant-123'::uuid,
                100
            ) AS error;
        &quot;&quot;&quot;)

        # Should still be valid
        assert result['error'] is None

        # But should have raised warning
        # (Check PostgreSQL logs or use pg_stat_statements)

    def test_global_scope_no_tenant(self, db, sample_table):
        &quot;&quot;&quot;Should work without tenant_id for global entities.&quot;&quot;&quot;
        execute_sql(db, &quot;&quot;&quot;
            CREATE TABLE test_schema.tb_global (
                pk_global INTEGER PRIMARY KEY,
                identifier TEXT NOT NULL,
                sequence_number INTEGER NOT NULL,
                UNIQUE (identifier, sequence_number)
            );

            INSERT INTO test_schema.tb_global (pk_global, identifier, sequence_number)
            SELECT i, 'item', i FROM generate_series(1, 60) i;
        &quot;&quot;&quot;)

        result = execute_query(db, &quot;&quot;&quot;
            SELECT core.validate_identifier_sequence(
                'global',
                'item',
                61,
                NULL,  -- No tenant
                100
            ) AS error;
        &quot;&quot;&quot;)

        assert result['error'] is None
</code></pre>
<p><strong>Expected</strong>: ‚ùå FAIL - Function does not exist</p>
<h4 id="green-minimal-implementation_2">üü¢ GREEN: Minimal Implementation</h4>
<p><strong>File</strong>: <code>templates/sql/hierarchy/validate_identifier_sequence.sql.jinja2</code> (NEW)</p>
<pre><code class="language-sql">-- Validate identifier sequence BEFORE insert/update
-- Returns NULL if valid, error object if limit exceeded

CREATE OR REPLACE FUNCTION core.validate_identifier_sequence(
    entity TEXT,
    identifier TEXT,
    sequence_number INTEGER,
    tenant_id UUID DEFAULT NULL,  -- For tenant-scoped entities
    max_duplicates INTEGER DEFAULT 100  -- Framework config
) RETURNS core.hierarchy_validation_error AS $$
DECLARE
    v_schema TEXT;
    v_table TEXT;
    v_current_count INTEGER;
    v_error core.hierarchy_validation_error;
    dyn_sql TEXT;
BEGIN
    IF entity IS NULL THEN
        RAISE EXCEPTION 'Parameter &quot;entity&quot; must not be NULL';
    END IF;

    -- Construct dynamic identifiers
    v_table := format('tb_%s', entity);

    -- Find schema dynamically
    SELECT table_schema INTO v_schema
    FROM information_schema.tables
    WHERE table_name = v_table
      AND table_schema IN ('core', 'management', 'catalog', 'tenant', 'test_schema')
    LIMIT 1;

    IF v_schema IS NULL THEN
        v_error.error_code := 'table_not_found';
        v_error.error_message := format('Table &quot;tb_%s&quot; not found', entity);
        RETURN v_error;
    END IF;

    -- Count existing sequences for this identifier
    IF tenant_id IS NOT NULL THEN
        -- Tenant-scoped count
        dyn_sql := format($q$
            SELECT COUNT(*)
            FROM %I.%I
            WHERE tenant_id = $1
              AND identifier = $2;
        $q$, v_schema, v_table);
        EXECUTE dyn_sql INTO v_current_count USING tenant_id, identifier;
    ELSE
        -- Global count
        dyn_sql := format($q$
            SELECT COUNT(*)
            FROM %I.%I
            WHERE identifier = $1;
        $q$, v_schema, v_table);
        EXECUTE dyn_sql INTO v_current_count USING identifier;
    END IF;

    -- Check hard limit
    IF sequence_number &gt; max_duplicates THEN
        v_error.error_code := 'sequence_limit_exceeded';
        v_error.error_message := format(
            'Identifier sequence limit exceeded: &quot;%s&quot; has %s variants (max: %s)',
            identifier, sequence_number, max_duplicates
        );
        v_error.hint := format(
            'Current variant: %s#%s. Use more descriptive naming to reduce collisions.',
            identifier, sequence_number
        );
        v_error.detail := jsonb_build_object(
            'identifier', identifier,
            'sequence_number', sequence_number,
            'current_count', v_current_count,
            'max_duplicates', max_duplicates
        );
        RETURN v_error;
    END IF;

    -- Soft warning at 50% threshold
    IF sequence_number &gt; (max_duplicates * 0.5) THEN
        RAISE WARNING 'High identifier duplication: &quot;%&quot; has % variants (limit: %)',
            identifier, sequence_number, max_duplicates;
    END IF;

    -- Valid
    RETURN NULL;
END;
$$ LANGUAGE plpgsql;

COMMENT ON FUNCTION core.validate_identifier_sequence IS
'Validate identifier sequence numbers BEFORE insert/update.

Explicit over Implicit: NO TRIGGERS! Mutations call this explicitly.

Returns NULL if valid, returns error object if limit exceeded.

Example usage:
  v_validation_error := core.validate_identifier_sequence(
      ''location'',
      ''warehouse-a'',
      42,
      tenant_id =&gt; v_tenant_id,
      max_duplicates =&gt; 100
  );

  IF v_validation_error IS NOT NULL THEN
      RETURN error response;
  END IF;';
</code></pre>
<p><strong>Expected</strong>: ‚úÖ PASS</p>
<h4 id="qa-phase-1-complete">‚úÖ QA: Phase 1 Complete</h4>
<pre><code class="language-bash">uv run pytest tests/unit/schema/test_validate*.py -v
uv run pytest tests/unit/schema/ -v
uv run pytest --tb=short
make lint &amp;&amp; make typecheck
</code></pre>
<p><strong>Deliverables</strong>:
- ‚úÖ <code>core.hierarchy_validation_error</code> type
- ‚úÖ <code>core.validate_hierarchy_change()</code> function
- ‚úÖ <code>core.validate_identifier_sequence()</code> function
- ‚úÖ Comprehensive test coverage</p>
<hr />
<h3 id="phase-2-identifier-recalculation-function-days-9-10"><strong>Phase 2: Identifier Recalculation Function</strong> (Days 9-10)</h3>
<p><strong>Objective</strong>: Implement explicit identifier recalculation (like <code>recalculate_tree_path</code>)</p>
<p><strong>TDD Cycle 2.1: Recalculation Context Extension</strong></p>
<h4 id="red-write-failing-test_3">üî¥ RED: Write Failing Test</h4>
<p><strong>File</strong>: <code>tests/unit/schema/test_recalculate_identifier.py</code> (NEW)</p>
<pre><code class="language-python">&quot;&quot;&quot;Test core.recalculate_identifier() function.&quot;&quot;&quot;

import pytest
from tests.utils.db_test import execute_sql, execute_query


class TestRecalculateIdentifier:
    &quot;&quot;&quot;Test identifier recalculation function.&quot;&quot;&quot;

    @pytest.fixture
    def sample_hierarchy(self, db):
        &quot;&quot;&quot;Create hierarchy with identifiers needing recalculation.&quot;&quot;&quot;
        execute_sql(db, &quot;&quot;&quot;
            CREATE SCHEMA IF NOT EXISTS test_schema;

            CREATE TABLE test_schema.tb_location (
                pk_location INTEGER PRIMARY KEY,
                id UUID DEFAULT gen_random_uuid(),
                tenant_id UUID NOT NULL,
                path ltree NOT NULL,
                fk_parent_location INTEGER REFERENCES test_schema.tb_location(pk_location),
                name TEXT NOT NULL,
                identifier TEXT NOT NULL,
                sequence_number INTEGER NOT NULL DEFAULT 1,
                display_identifier TEXT,
                identifier_recalculated_at TIMESTAMPTZ,
                identifier_recalculated_by UUID
            );

            -- Initial hierarchy (identifiers need recalculation)
            INSERT INTO test_schema.tb_location
                (pk_location, id, tenant_id, path, fk_parent_location, name, identifier, sequence_number)
            VALUES
                (1, gen_random_uuid(), 'tenant-1'::uuid, '1', NULL, 'Building A', 'old-id-1', 1),
                (2, gen_random_uuid(), 'tenant-1'::uuid, '1.2', 1, 'Floor 1', 'old-id-2', 1),
                (3, gen_random_uuid(), 'tenant-1'::uuid, '1.2.3', 2, 'Room 101', 'old-id-3', 1),
                (4, gen_random_uuid(), 'tenant-1'::uuid, '1.4', 1, 'Floor 2', 'old-id-4', 1);
        &quot;&quot;&quot;)
        yield
        execute_sql(db, &quot;DROP SCHEMA test_schema CASCADE;&quot;)

    def test_recalculate_single_node(self, db, sample_hierarchy):
        &quot;&quot;&quot;Should recalculate identifier for single node.&quot;&quot;&quot;
        # Get node id
        node_id = execute_query(db, &quot;SELECT id FROM test_schema.tb_location WHERE pk_location = 2&quot;)['id']
        caller_id = 'user-123'

        # Recalculate
        result = execute_query(db, &quot;&quot;&quot;
            SELECT core.recalculate_identifier(
                'location',
                ROW($1, NULL, $2)::core.recalculation_context
            ) AS updated_count;
        &quot;&quot;&quot;, node_id, caller_id)

        assert result['updated_count'] == 1

        # Check identifier was updated
        updated = execute_query(db, &quot;&quot;&quot;
            SELECT
                identifier,
                display_identifier,
                identifier_recalculated_by
            FROM test_schema.tb_location
            WHERE pk_location = 2;
        &quot;&quot;&quot;)

        assert updated['identifier'] == 'building-a_floor-1'  # parent_name
        assert updated['display_identifier'] == 'building-a_floor-1'
        assert updated['identifier_recalculated_by'] == caller_id

    def test_recalculate_subtree(self, db, sample_hierarchy):
        &quot;&quot;&quot;Should recalculate identifiers for entire subtree.&quot;&quot;&quot;
        node_id = execute_query(db, &quot;SELECT id FROM test_schema.tb_location WHERE pk_location = 1&quot;)['id']
        caller_id = 'user-123'

        # Recalculate from root
        result = execute_query(db, &quot;&quot;&quot;
            SELECT core.recalculate_identifier(
                'location',
                ROW($1, NULL, $2)::core.recalculation_context
            ) AS updated_count;
        &quot;&quot;&quot;, node_id, caller_id)

        # Should update all 4 nodes
        assert result['updated_count'] == 4

        # Verify hierarchy of identifiers
        identifiers = execute_query(db, &quot;&quot;&quot;
            SELECT pk_location, identifier
            FROM test_schema.tb_location
            ORDER BY pk_location;
        &quot;&quot;&quot;, fetch_all=True)

        assert identifiers[0]['identifier'] == 'building-a'  # Root
        assert identifiers[1]['identifier'] == 'building-a_floor-1'
        assert identifiers[2]['identifier'] == 'building-a_floor-1_room-101'
        assert identifiers[3]['identifier'] == 'building-a_floor-2'

    def test_recalculate_tenant_scope(self, db, sample_hierarchy):
        &quot;&quot;&quot;Should recalculate all identifiers in tenant.&quot;&quot;&quot;
        # Add second tenant
        execute_sql(db, &quot;&quot;&quot;
            INSERT INTO test_schema.tb_location
                (pk_location, id, tenant_id, path, fk_parent_location, name, identifier, sequence_number)
            VALUES
                (5, gen_random_uuid(), 'tenant-2'::uuid, '5', NULL, 'Warehouse', 'old-id-5', 1);
        &quot;&quot;&quot;)

        tenant_id = 'tenant-1'
        caller_id = 'user-123'

        # Recalculate tenant scope
        result = execute_query(db, &quot;&quot;&quot;
            SELECT core.recalculate_identifier(
                'location',
                ROW(NULL, $1, $2)::core.recalculation_context
            ) AS updated_count;
        &quot;&quot;&quot;, tenant_id, caller_id)

        # Should update only tenant-1 nodes (4 nodes)
        assert result['updated_count'] == 4

        # Verify tenant-2 unchanged
        tenant2 = execute_query(db, &quot;&quot;&quot;
            SELECT identifier
            FROM test_schema.tb_location
            WHERE tenant_id = 'tenant-2'::uuid;
        &quot;&quot;&quot;)
        assert tenant2['identifier'] == 'old-id-5'  # Unchanged

    def test_idempotent_recalculation(self, db, sample_hierarchy):
        &quot;&quot;&quot;Recalculating again should be idempotent (no changes).&quot;&quot;&quot;
        node_id = execute_query(db, &quot;SELECT id FROM test_schema.tb_location WHERE pk_location = 1&quot;)['id']
        caller_id = 'user-123'

        # First recalculation
        result1 = execute_query(db, &quot;&quot;&quot;
            SELECT core.recalculate_identifier('location', ROW($1, NULL, $2)::core.recalculation_context);
        &quot;&quot;&quot;, node_id, caller_id)

        # Second recalculation (identifiers already correct)
        result2 = execute_query(db, &quot;&quot;&quot;
            SELECT core.recalculate_identifier('location', ROW($1, NULL, $2)::core.recalculation_context);
        &quot;&quot;&quot;, node_id, caller_id)

        # Should update 0 rows (idempotent)
        assert result2 == 0
</code></pre>
<p><strong>Expected</strong>: ‚ùå FAIL - Function does not exist</p>
<h4 id="green-minimal-implementation_3">üü¢ GREEN: Minimal Implementation</h4>
<p><strong>File</strong>: <code>templates/sql/hierarchy/recalculate_identifier.sql.jinja2</code> (NEW)</p>
<pre><code class="language-sql">-- Generic identifier recalculation for ANY entity
-- Pattern: Concatenate parent identifier + safe_slug(name)
-- NO TRIGGERS - Called explicitly from mutations!

CREATE OR REPLACE FUNCTION core.recalculate_identifier(
    entity TEXT,
    ctx core.recalculation_context DEFAULT ROW(NULL, NULL, NULL)::core.recalculation_context
) RETURNS INTEGER AS $$
DECLARE
    v_schema TEXT;
    v_table TEXT;
    v_pk_column TEXT;
    v_parent_column TEXT;
    v_updated_count INTEGER := 0;
    v_root_pk INTEGER;
    dyn_sql TEXT;
BEGIN
    IF entity IS NULL THEN
        RAISE EXCEPTION 'Parameter &quot;entity&quot; must not be NULL';
    END IF;

    -- Construct dynamic identifiers
    v_table := format('tb_%s', entity);
    v_pk_column := format('pk_%s', entity);
    v_parent_column := format('fk_parent_%s', entity);

    -- Find schema dynamically
    SELECT table_schema INTO v_schema
    FROM information_schema.tables
    WHERE table_name = v_table
      AND table_schema IN ('core', 'management', 'catalog', 'tenant', 'test_schema')
    LIMIT 1;

    IF v_schema IS NULL THEN
        RAISE EXCEPTION 'Table &quot;tb_%&quot; not found in any expected schema', entity;
    END IF;

    -- MODE 1: Subtree recalculation (ctx.pk set)
    IF ctx.pk IS NOT NULL THEN
        -- Find root of subtree
        dyn_sql := format($q$
            WITH RECURSIVE t_chain AS (
                SELECT %1$I AS pk, %2$I AS parent
                FROM %3$I.%4$I
                WHERE id = $1

                UNION ALL

                SELECT t.%1$I, t.%2$I
                FROM %3$I.%4$I t
                JOIN t_chain ON t.%1$I = t_chain.parent
            )
            SELECT pk FROM t_chain WHERE parent IS NULL LIMIT 1;
        $q$, v_pk_column, v_parent_column, v_schema, v_table);

        EXECUTE dyn_sql INTO v_root_pk USING ctx.pk;

        IF v_root_pk IS NULL THEN
            -- Given node IS the root
            dyn_sql := format($q$
                SELECT %1$I FROM %2$I.%3$I WHERE id = $1;
            $q$, v_pk_column, v_schema, v_table);
            EXECUTE dyn_sql INTO v_root_pk USING ctx.pk;
        END IF;

        -- Recalculate subtree identifiers
        dyn_sql := format($q$
            WITH RECURSIVE hierarchy AS (
                -- Root: identifier = safe_slug(name)
                SELECT
                    t.%1$I AS pk,
                    public.safe_slug(t.name) AS new_identifier
                FROM %2$I.%3$I t
                WHERE t.%1$I = $1

                UNION ALL

                -- Children: parent_identifier + '_' + safe_slug(name)
                SELECT
                    c.%1$I,
                    h.new_identifier || '_' || public.safe_slug(c.name)
                FROM %2$I.%3$I c
                JOIN hierarchy h ON c.%4$I = h.pk
            ),
            updated AS (
                UPDATE %2$I.%3$I t
                SET
                    identifier = h.new_identifier,
                    display_identifier = h.new_identifier,  -- Assuming sequence_number = 1
                    identifier_recalculated_at = now(),
                    identifier_recalculated_by = $2
                FROM hierarchy h
                WHERE t.%1$I = h.pk
                  AND t.identifier IS DISTINCT FROM h.new_identifier  -- Idempotent
                RETURNING t.%1$I
            )
            SELECT COUNT(*) FROM updated;
        $q$, v_pk_column, v_schema, v_table, v_parent_column);

        EXECUTE dyn_sql INTO v_updated_count USING v_root_pk, ctx.updated_by;

    -- MODE 2: Tenant-scoped recalculation
    ELSIF ctx.pk_tenant IS NOT NULL THEN
        dyn_sql := format($q$
            WITH RECURSIVE hierarchy AS (
                -- Roots in tenant
                SELECT
                    t.%1$I AS pk,
                    public.safe_slug(t.name) AS new_identifier
                FROM %2$I.%3$I t
                WHERE t.tenant_id = $1 AND t.%4$I IS NULL

                UNION ALL

                -- Children
                SELECT
                    c.%1$I,
                    h.new_identifier || '_' || public.safe_slug(c.name)
                FROM %2$I.%3$I c
                JOIN hierarchy h ON c.%4$I = h.pk
            ),
            updated AS (
                UPDATE %2$I.%3$I t
                SET
                    identifier = h.new_identifier,
                    display_identifier = h.new_identifier,
                    identifier_recalculated_at = now(),
                    identifier_recalculated_by = $2
                FROM hierarchy h
                WHERE t.%1$I = h.pk
                  AND t.identifier IS DISTINCT FROM h.new_identifier
                RETURNING t.%1$I
            )
            SELECT COUNT(*) FROM updated;
        $q$, v_pk_column, v_schema, v_table, v_parent_column);

        EXECUTE dyn_sql INTO v_updated_count USING ctx.pk_tenant, ctx.updated_by;

    -- MODE 3: Global recalculation
    ELSE
        dyn_sql := format($q$
            WITH RECURSIVE hierarchy AS (
                -- All roots
                SELECT
                    t.%1$I AS pk,
                    public.safe_slug(t.name) AS new_identifier
                FROM %2$I.%3$I t
                WHERE t.%4$I IS NULL

                UNION ALL

                -- All children
                SELECT
                    c.%1$I,
                    h.new_identifier || '_' || public.safe_slug(c.name)
                FROM %2$I.%3$I c
                JOIN hierarchy h ON c.%4$I = h.pk
            ),
            updated AS (
                UPDATE %2$I.%3$I t
                SET
                    identifier = h.new_identifier,
                    display_identifier = h.new_identifier,
                    identifier_recalculated_at = now(),
                    identifier_recalculated_by = $1
                FROM hierarchy h
                WHERE t.%1$I = h.pk
                  AND t.identifier IS DISTINCT FROM h.new_identifier
                RETURNING t.%1$I
            )
            SELECT COUNT(*) FROM updated;
        $q$, v_pk_column, v_schema, v_table, v_parent_column);

        EXECUTE dyn_sql INTO v_updated_count USING ctx.updated_by;
    END IF;

    RETURN v_updated_count;
END;
$$ LANGUAGE plpgsql;

COMMENT ON FUNCTION core.recalculate_identifier IS
'Generic identifier recalculation for any entity using hierarchical naming.

Explicit over Implicit: NO TRIGGERS! Mutations call this explicitly.

Pattern: parent_identifier + ''_'' + safe_slug(name)
Example: ''building-a_floor-1_room-101''

Three modes:
1. Subtree (ctx.pk set): Recalculate from given node down
2. Tenant (ctx.pk_tenant set, ctx.pk NULL): Recalculate all trees in tenant
3. Global (both NULL): Recalculate entire entity

Returns: Number of rows updated

Example usage in mutations:
  v_count := core.recalculate_identifier(
      ''location'',
      ROW(v_location_id, NULL, p_caller_id)::core.recalculation_context
  );

Based on explicit pattern from recalculate_tree_path().';
</code></pre>
<p><strong>Expected</strong>: ‚úÖ PASS</p>
<h4 id="refactor-handle-deduplication-sequence_number">üîß REFACTOR: Handle Deduplication (sequence_number)</h4>
<p>Update function to handle sequence numbers:</p>
<pre><code class="language-sql">-- Enhanced version that respects sequence_number
-- Update display_identifier calculation:
display_identifier = CASE
    WHEN t.sequence_number &gt; 1
    THEN h.new_identifier || '#' || t.sequence_number
    ELSE h.new_identifier
END
</code></pre>
<h4 id="qa-phase-2-complete">‚úÖ QA: Phase 2 Complete</h4>
<pre><code class="language-bash">uv run pytest tests/unit/schema/test_recalculate_identifier.py -v
uv run pytest tests/unit/schema/ -v
uv run pytest --tb=short
</code></pre>
<p><strong>Deliverables</strong>:
- ‚úÖ <code>core.recalculate_identifier()</code> function
- ‚úÖ Works with existing <code>recalculation_context</code> type
- ‚úÖ Supports subtree/tenant/global modes
- ‚úÖ Idempotent (no changes if already correct)</p>
<hr />
<h3 id="phase-3-team-b-template-integration-day-11"><strong>Phase 3: Team B Template Integration</strong> (Day 11)</h3>
<p><strong>Objective</strong>: Update Team B generators to use explicit pattern</p>
<p><strong>TDD Cycle 3.1: Schema Generator Integration</strong></p>
<h4 id="red-write-failing-test_4">üî¥ RED: Write Failing Test</h4>
<p><strong>File</strong>: <code>tests/unit/schema/test_schema_generator_explicit_pattern.py</code> (NEW)</p>
<pre><code class="language-python">&quot;&quot;&quot;Test SchemaGenerator produces explicit validation pattern.&quot;&quot;&quot;

import pytest
from src.core.ast_models import EntityAST, FieldDefinition
from src.generators.schema.schema_generator import SchemaGenerator


class TestSchemaGeneratorExplicitPattern:
    &quot;&quot;&quot;Test schema generator uses explicit pattern (no triggers).&quot;&quot;&quot;

    def test_no_validation_triggers_generated(self):
        &quot;&quot;&quot;Should NOT generate validation triggers.&quot;&quot;&quot;
        entity = EntityAST(
            name='Location',
            schema='tenant',
            hierarchical=True,
            fields=[
                FieldDefinition(name='name', type='text', required=True)
            ]
        )

        generator = SchemaGenerator()
        sql = generator.generate(entity)

        # Should NOT contain trigger definitions
        assert 'CREATE TRIGGER' not in sql
        assert 'prevent_cycle' not in sql
        assert 'check_sequence_limit' not in sql
        assert 'check_depth_limit' not in sql

    def test_includes_validation_function_references(self):
        &quot;&quot;&quot;Should reference core validation functions in comments.&quot;&quot;&quot;
        entity = EntityAST(
            name='Location',
            schema='tenant',
            hierarchical=True,
            fields=[
                FieldDefinition(name='name', type='text', required=True)
            ]
        )

        generator = SchemaGenerator()
        sql = generator.generate(entity)

        # Should mention validation functions in comments
        assert 'validate_hierarchy_change' in sql
        assert 'recalculate_tree_path' in sql
        assert 'recalculate_identifier' in sql

    def test_generates_audit_fields(self):
        &quot;&quot;&quot;Should generate audit fields for recalculation tracking.&quot;&quot;&quot;
        entity = EntityAST(
            name='Location',
            schema='tenant',
            hierarchical=True,
            fields=[]
        )

        generator = SchemaGenerator()
        sql = generator.generate(entity)

        # Should include recalculation audit fields
        assert 'path_updated_at' in sql
        assert 'path_updated_by' in sql
        assert 'identifier_recalculated_at' in sql
        assert 'identifier_recalculated_by' in sql
</code></pre>
<p><strong>Expected</strong>: ‚ùå FAIL - Generator still produces triggers</p>
<h4 id="green-update-schemagenerator">üü¢ GREEN: Update SchemaGenerator</h4>
<p><strong>File</strong>: <code>src/generators/schema/schema_generator.py</code> (UPDATE)</p>
<pre><code class="language-python">class SchemaGenerator:
    def generate(self, entity: EntityAST) -&gt; str:
        &quot;&quot;&quot;Generate schema DDL with explicit validation pattern.&quot;&quot;&quot;

        parts = []

        # Generate table
        parts.append(self._generate_table(entity))

        # Generate indexes
        parts.append(self._generate_indexes(entity))

        # Generate helper functions (pk/id/identifier lookup)
        parts.append(self._generate_helper_functions(entity))

        # ‚ùå REMOVED: Don't generate validation triggers
        # parts.append(self._generate_validation_triggers(entity))

        # ‚úÖ NEW: Add comment about explicit validation
        if entity.hierarchical:
            parts.append(self._generate_validation_comment(entity))

        return '\n\n'.join(parts)

    def _generate_validation_comment(self, entity: EntityAST) -&gt; str:
        &quot;&quot;&quot;Generate comment explaining explicit validation pattern.&quot;&quot;&quot;
        entity_lower = entity.name.lower()
        schema = entity.schema

        return f&quot;&quot;&quot;
-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
-- VALIDATION PATTERN: Explicit over Implicit (NO TRIGGERS!)
-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
--
-- This entity uses EXPLICIT validation instead of database triggers.
-- Mutations call validation functions directly (visible in code).
--
-- Available validation functions:
--   ‚Ä¢ core.validate_hierarchy_change('{entity_lower}', node_pk, new_parent_pk)
--   ‚Ä¢ core.validate_identifier_sequence('{entity_lower}', identifier, seq_num)
--
-- Available recalculation functions:
--   ‚Ä¢ core.recalculate_tree_path('{entity_lower}', context)
--   ‚Ä¢ core.recalculate_identifier('{entity_lower}', context)
--
-- Example mutation usage:
--   v_error := core.validate_hierarchy_change('{entity_lower}', ...);
--   IF v_error IS NOT NULL THEN RETURN error_response(v_error); END IF;
--
--   UPDATE {schema}.tb_{entity_lower} SET fk_parent_{entity_lower} = ...;
--
--   PERFORM core.recalculate_tree_path('{entity_lower}', ...);
--   PERFORM core.recalculate_identifier('{entity_lower}', ...);
--
-- Benefits: Visible, debuggable, testable, controllable
-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
&quot;&quot;&quot;.strip()
</code></pre>
<p><strong>Expected</strong>: ‚úÖ PASS</p>
<h4 id="qa-phase-3-complete">‚úÖ QA: Phase 3 Complete</h4>
<pre><code class="language-bash">uv run pytest tests/unit/schema/test_schema_generator*.py -v
make teamB-test
</code></pre>
<p><strong>Deliverables</strong>:
- ‚úÖ No triggers generated
- ‚úÖ Clear comments about explicit pattern
- ‚úÖ All Team B tests pass</p>
<hr />
<h3 id="phase-4-team-c-mutation-templates-days-12-13"><strong>Phase 4: Team C Mutation Templates</strong> (Days 12-13)</h3>
<p><strong>Objective</strong>: Update mutation templates to call validations explicitly</p>
<p><strong>TDD Cycle 4.1: Mutation Template with Validation</strong></p>
<h4 id="red-write-failing-test_5">üî¥ RED: Write Failing Test</h4>
<p><strong>File</strong>: <code>tests/unit/actions/test_action_compiler_explicit_validation.py</code> (NEW)</p>
<pre><code class="language-python">&quot;&quot;&quot;Test ActionCompiler generates explicit validation calls.&quot;&quot;&quot;

import pytest
from src.core.ast_models import EntityAST, ActionDefinition, ActionStep
from src.generators.actions.action_compiler import ActionCompiler


class TestActionCompilerExplicitValidation:
    &quot;&quot;&quot;Test action compiler generates explicit validation calls.&quot;&quot;&quot;

    def test_generates_hierarchy_validation_for_parent_change(self):
        &quot;&quot;&quot;Should generate validate_hierarchy_change() call.&quot;&quot;&quot;
        entity = EntityAST(
            name='Location',
            schema='tenant',
            hierarchical=True,
            fields=[]
        )

        action = ActionDefinition(
            name='move_location',
            parameters=['new_parent_id'],
            steps=[
                ActionStep(
                    type='update',
                    target='Location',
                    set_clause='fk_parent_location = $new_parent_id'
                )
            ]
        )

        compiler = ActionCompiler()
        sql = compiler.compile(action, entity)

        # Should include validation call
        assert 'core.validate_hierarchy_change' in sql
        assert 'v_validation_error' in sql
        assert 'IF v_validation_error IS NOT NULL THEN' in sql

        # Should return error response on validation failure
        assert 'RETURN' in sql
        assert 'error_response' in sql or 'error' in sql.lower()

    def test_generates_path_recalculation_call(self):
        &quot;&quot;&quot;Should generate recalculate_tree_path() call after parent change.&quot;&quot;&quot;
        entity = EntityAST(
            name='Location',
            schema='tenant',
            hierarchical=True,
            fields=[]
        )

        action = ActionDefinition(
            name='move_location',
            parameters=['new_parent_id'],
            steps=[
                ActionStep(
                    type='update',
                    target='Location',
                    set_clause='fk_parent_location = $new_parent_id'
                )
            ]
        )

        compiler = ActionCompiler()
        sql = compiler.compile(action, entity)

        # Should include path recalculation
        assert 'core.recalculate_tree_path' in sql
        assert 'location' in sql  # entity name parameter
        assert 'recalculation_context' in sql

    def test_generates_identifier_recalculation_on_rename(self):
        &quot;&quot;&quot;Should generate recalculate_identifier() on name change.&quot;&quot;&quot;
        entity = EntityAST(
            name='Location',
            schema='tenant',
            hierarchical=True,
            fields=[]
        )

        action = ActionDefinition(
            name='rename_location',
            parameters=['new_name'],
            steps=[
                ActionStep(
                    type='update',
                    target='Location',
                    set_clause='name = $new_name'
                )
            ]
        )

        compiler = ActionCompiler()
        sql = compiler.compile(action, entity)

        # Should include identifier recalculation
        assert 'core.recalculate_identifier' in sql

    def test_validation_order_correct(self):
        &quot;&quot;&quot;Validation should happen BEFORE update.&quot;&quot;&quot;
        entity = EntityAST(
            name='Location',
            schema='tenant',
            hierarchical=True,
            fields=[]
        )

        action = ActionDefinition(
            name='move_location',
            parameters=['new_parent_id'],
            steps=[
                ActionStep(
                    type='update',
                    target='Location',
                    set_clause='fk_parent_location = $new_parent_id'
                )
            ]
        )

        compiler = ActionCompiler()
        sql = compiler.compile(action, entity)

        # Validation should come before UPDATE
        validation_pos = sql.find('validate_hierarchy_change')
        update_pos = sql.find('UPDATE')

        assert validation_pos &gt; 0
        assert update_pos &gt; 0
        assert validation_pos &lt; update_pos  # Validation first!
</code></pre>
<p><strong>Expected</strong>: ‚ùå FAIL - Compiler doesn't generate validation calls</p>
<h4 id="green-update-actioncompiler">üü¢ GREEN: Update ActionCompiler</h4>
<p><strong>File</strong>: <code>src/generators/actions/action_compiler.py</code> (UPDATE)</p>
<pre><code class="language-python">class ActionCompiler:
    def _compile_update_step(
        self,
        step: ActionStep,
        entity: EntityAST,
        context: CompilerContext
    ) -&gt; str:
        &quot;&quot;&quot;Compile UPDATE step with explicit validation.&quot;&quot;&quot;

        parts = []

        # Detect if this is a parent field change (hierarchical)
        if entity.hierarchical and self._is_parent_change(step):
            parts.append(self._generate_hierarchy_validation(entity, step))

        # Detect if this is a name change (affects identifier)
        if self._is_name_change(step):
            # Identifier validation happens in recalculation
            pass

        # Generate the actual UPDATE
        parts.append(self._generate_update_sql(step, entity, context))

        # Post-update recalculations
        if entity.hierarchical and self._is_parent_change(step):
            parts.append(self._generate_path_recalculation(entity, context))

        if self._is_name_change(step):
            parts.append(self._generate_identifier_recalculation(entity, context))

        return '\n\n'.join(parts)

    def _generate_hierarchy_validation(
        self,
        entity: EntityAST,
        step: ActionStep
    ) -&gt; str:
        &quot;&quot;&quot;Generate validation call for hierarchy changes.&quot;&quot;&quot;
        entity_lower = entity.name.lower()

        return f&quot;&quot;&quot;
    -- Validate hierarchy change (explicit!)
    v_validation_error := core.validate_hierarchy_change(
        '{entity_lower}',
        v_{entity_lower}_pk,
        v_new_parent_pk,
        max_depth =&gt; 20,  -- Framework config
        check_cycle =&gt; true,
        check_depth =&gt; true
    );

    IF v_validation_error IS NOT NULL THEN
        -- Return structured error
        v_result.status := 'error';
        v_result.message := v_validation_error.error_message;
        v_result.object_data := core.validation_error_to_jsonb(v_validation_error);
        RETURN v_result;
    END IF;
&quot;&quot;&quot;.strip()

    def _generate_path_recalculation(
        self,
        entity: EntityAST,
        context: CompilerContext
    ) -&gt; str:
        &quot;&quot;&quot;Generate path recalculation call.&quot;&quot;&quot;
        entity_lower = entity.name.lower()

        return f&quot;&quot;&quot;
    -- Recalculate paths (explicit!)
    v_paths_updated := core.recalculate_tree_path(
        '{entity_lower}',
        ROW(p_{entity_lower}_id, NULL, p_caller_id)::core.recalculation_context
    );

    -- Track in response metadata
    v_result.extra_metadata := jsonb_build_object(
        'pathsUpdated', v_paths_updated
    );
&quot;&quot;&quot;.strip()

    def _generate_identifier_recalculation(
        self,
        entity: EntityAST,
        context: CompilerContext
    ) -&gt; str:
        &quot;&quot;&quot;Generate identifier recalculation call.&quot;&quot;&quot;
        entity_lower = entity.name.lower()

        return f&quot;&quot;&quot;
    -- Recalculate identifiers (explicit!)
    v_identifiers_updated := core.recalculate_identifier(
        '{entity_lower}',
        ROW(p_{entity_lower}_id, NULL, p_caller_id)::core.recalculation_context
    );

    -- Add to response metadata
    v_result.extra_metadata := jsonb_set(
        COALESCE(v_result.extra_metadata, '{{}}'::jsonb),
        '{{identifiersUpdated}}',
        to_jsonb(v_identifiers_updated)
    );
&quot;&quot;&quot;.strip()

    def _is_parent_change(self, step: ActionStep) -&gt; bool:
        &quot;&quot;&quot;Check if step modifies parent field.&quot;&quot;&quot;
        return 'fk_parent' in step.set_clause.lower()

    def _is_name_change(self, step: ActionStep) -&gt; bool:
        &quot;&quot;&quot;Check if step modifies name field.&quot;&quot;&quot;
        return step.set_clause.lower().strip().startswith('name =')
</code></pre>
<p><strong>Expected</strong>: ‚úÖ PASS</p>
<h4 id="qa-phase-4-complete">‚úÖ QA: Phase 4 Complete</h4>
<pre><code class="language-bash">uv run pytest tests/unit/actions/test_action_compiler*.py -v
make teamC-test
</code></pre>
<p><strong>Deliverables</strong>:
- ‚úÖ Mutations call validations explicitly
- ‚úÖ Validations happen BEFORE updates
- ‚úÖ Recalculations happen AFTER updates
- ‚úÖ Structured error responses</p>
<hr />
<h3 id="phase-5-integration-testing-day-14"><strong>Phase 5: Integration Testing</strong> (Day 14)</h3>
<p><strong>Objective</strong>: End-to-end testing of explicit pattern</p>
<p><strong>TDD Cycle 5.1: Integration Test</strong></p>
<h4 id="red-write-failing-integration-test">üî¥ RED: Write Failing Integration Test</h4>
<p><strong>File</strong>: <code>tests/integration/test_explicit_validation_e2e.py</code> (NEW)</p>
<pre><code class="language-python">&quot;&quot;&quot;End-to-end test of explicit validation pattern.&quot;&quot;&quot;

import pytest
from tests.utils.db_test import execute_sql, execute_query


class TestExplicitValidationE2E:
    &quot;&quot;&quot;Test complete flow: SpecQL ‚Üí SQL ‚Üí Validation ‚Üí Recalculation.&quot;&quot;&quot;

    @pytest.fixture
    def generated_location_schema(self, db):
        &quot;&quot;&quot;Generate Location entity using Team B + C.&quot;&quot;&quot;
        from src.core.specql_parser import SpecQLParser
        from src.generators.schema.schema_generator import SchemaGenerator
        from src.generators.actions.action_compiler import ActionCompiler

        # Parse SpecQL
        yaml_content = &quot;&quot;&quot;
entity: Location
schema: tenant
hierarchical: true

fields:
  name: text

actions:
  - name: move_location
    parameters:
      - new_parent_id: uuid
    steps:
      - update: Location SET fk_parent_location = $new_parent_id
&quot;&quot;&quot;

        parser = SpecQLParser()
        entity = parser.parse(yaml_content)

        # Generate schema (Team B)
        schema_gen = SchemaGenerator()
        schema_sql = schema_gen.generate(entity)

        # Generate actions (Team C)
        action_compiler = ActionCompiler()
        action_sql = action_compiler.compile(entity.actions[0], entity)

        # Execute generated SQL
        execute_sql(db, schema_sql)
        execute_sql(db, action_sql)

        yield

        execute_sql(db, &quot;DROP SCHEMA tenant CASCADE;&quot;)

    def test_move_location_validates_and_recalculates(self, db, generated_location_schema):
        &quot;&quot;&quot;Full flow: move location with validation and recalculation.&quot;&quot;&quot;
        # Create hierarchy
        root_id = execute_query(db, &quot;&quot;&quot;
            INSERT INTO tenant.tb_location (path, fk_parent_location, name, identifier)
            VALUES ('1', NULL, 'Building A', 'building-a')
            RETURNING id;
        &quot;&quot;&quot;)['id']

        child_id = execute_query(db, &quot;&quot;&quot;
            INSERT INTO tenant.tb_location (path, fk_parent_location, name, identifier)
            VALUES ('1.2', (SELECT pk_location FROM tenant.tb_location WHERE id = $1), 'Floor 1', 'building-a_floor-1')
            RETURNING id;
        &quot;&quot;&quot;, root_id)['id']

        # Try to create circular reference (should fail validation)
        result = execute_query(db, &quot;&quot;&quot;
            SELECT tenant.move_location($1, $2);
        &quot;&quot;&quot;, root_id, child_id)

        # Should return error
        assert result['status'] == 'error'
        assert 'circular' in result['message'].lower()

        # Valid move should succeed
        result = execute_query(db, &quot;&quot;&quot;
            SELECT tenant.move_location($1, NULL);  -- Make root
        &quot;&quot;&quot;, child_id)

        assert result['status'] == 'success'
        assert result['extra_metadata']['pathsUpdated'] &gt; 0
</code></pre>
<p><strong>Expected</strong>: ‚ùå FAIL initially, then ‚úÖ PASS</p>
<h4 id="qa-phase-5-complete">‚úÖ QA: Phase 5 Complete</h4>
<pre><code class="language-bash">uv run pytest tests/integration/test_explicit*.py -v
make integration
</code></pre>
<hr />
<h3 id="phase-6-documentation-migration-day-15"><strong>Phase 6: Documentation &amp; Migration</strong> (Day 15)</h3>
<p><strong>Objective</strong>: Document pattern and provide migration guide</p>
<p><strong>Deliverables</strong>:</p>
<ol>
<li><strong>User Documentation</strong> (<code>docs/guides/EXPLICIT_VALIDATION_GUIDE.md</code>)</li>
<li><strong>Migration Guide</strong> (<code>docs/migration/TRIGGER_TO_EXPLICIT_MIGRATION.md</code>)</li>
<li><strong>API Reference</strong> (Update function comments)</li>
</ol>
<hr />
<h2 id="summary">üìä Summary</h2>
<h3 id="timeline">Timeline</h3>
<table>
<thead>
<tr>
<th>Phase</th>
<th>Days</th>
<th>Focus</th>
<th>Deliverables</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Phase 1</strong></td>
<td>7-8</td>
<td>Core types &amp; validation functions</td>
<td>Types, validate functions, tests</td>
</tr>
<tr>
<td><strong>Phase 2</strong></td>
<td>9-10</td>
<td>Identifier recalculation</td>
<td>recalculate_identifier(), tests</td>
</tr>
<tr>
<td><strong>Phase 3</strong></td>
<td>11</td>
<td>Team B integration</td>
<td>Schema generator updates</td>
</tr>
<tr>
<td><strong>Phase 4</strong></td>
<td>12-13</td>
<td>Team C integration</td>
<td>Mutation compiler updates</td>
</tr>
<tr>
<td><strong>Phase 5</strong></td>
<td>14</td>
<td>Integration testing</td>
<td>End-to-end tests</td>
</tr>
<tr>
<td><strong>Phase 6</strong></td>
<td>15</td>
<td>Documentation</td>
<td>Guides, migration docs</td>
</tr>
</tbody>
</table>
<p><strong>Total</strong>: 7 days (1.5 weeks)</p>
<h3 id="files-createdmodified">Files Created/Modified</h3>
<p><strong>New SQL Templates</strong> (6 files):
- <code>templates/sql/hierarchy/validate_hierarchy_change.sql.jinja2</code>
- <code>templates/sql/hierarchy/validate_identifier_sequence.sql.jinja2</code>
- <code>templates/sql/hierarchy/recalculate_identifier.sql.jinja2</code></p>
<p><strong>Updated SQL Templates</strong> (1 file):
- <code>templates/sql/000_types.sql.jinja2</code> (add validation error type)</p>
<p><strong>Updated Python Generators</strong> (2 files):
- <code>src/generators/schema/schema_generator.py</code>
- <code>src/generators/actions/action_compiler.py</code></p>
<p><strong>New Tests</strong> (6 files):
- <code>tests/unit/schema/test_validation_types.py</code>
- <code>tests/unit/schema/test_validate_hierarchy.py</code>
- <code>tests/unit/schema/test_validate_identifier_sequence.py</code>
- <code>tests/unit/schema/test_recalculate_identifier.py</code>
- <code>tests/unit/schema/test_schema_generator_explicit_pattern.py</code>
- <code>tests/unit/actions/test_action_compiler_explicit_validation.py</code>
- <code>tests/integration/test_explicit_validation_e2e.py</code></p>
<p><strong>Documentation</strong> (3 files):
- <code>docs/guides/EXPLICIT_VALIDATION_GUIDE.md</code>
- <code>docs/migration/TRIGGER_TO_EXPLICIT_MIGRATION.md</code>
- Update existing team docs</p>
<p><strong>Total Effort</strong>: ~1200 lines SQL + 800 lines Python + 1500 lines tests = 3500 lines</p>
<hr />
<h2 id="final-acceptance-criteria">‚úÖ Final Acceptance Criteria</h2>
<ul>
<li>[ ] Zero triggers for validation logic</li>
<li>[ ] All validations return structured errors (not exceptions)</li>
<li>[ ] Mutations call validations explicitly (visible in code)</li>
<li>[ ] Path recalculation explicit (existing ‚úÖ)</li>
<li>[ ] Identifier recalculation explicit (NEW ‚úÖ)</li>
<li>[ ] Team B generates no triggers</li>
<li>[ ] Team C generates explicit calls</li>
<li>[ ] 90%+ test coverage</li>
<li>[ ] Integration tests pass</li>
<li>[ ] Documentation complete</li>
<li>[ ] Migration guide written</li>
</ul>
<hr />
<h2 id="benefits-achieved">üéØ Benefits Achieved</h2>
<p>‚úÖ <strong>Visibility</strong>: All operations visible in generated code
‚úÖ <strong>Debuggability</strong>: Clear call sites, easy to trace
‚úÖ <strong>Testability</strong>: Functions testable in isolation
‚úÖ <strong>Control</strong>: Can skip validations when safe
‚úÖ <strong>Consistency</strong>: Same pattern for all framework operations
‚úÖ <strong>Performance</strong>: No hidden trigger cascades
‚úÖ <strong>Maintainability</strong>: Easier to understand and modify</p>
<hr />
<p><strong>Status</strong>: üéØ Ready for Implementation
<strong>Priority</strong>: CRITICAL (refactors Phase 7 of Team B)
<strong>Timeline</strong>: Days 7-15 of Team B (Week 2)
<strong>Dependencies</strong>: Phases 1-6 of Team B complete</p>
              
            </div>
          </div><footer>

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
          
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="Versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    
    
    
  </span>
</div>
    <script src="../../js/jquery-3.6.0.min.js"></script>
    <script>var base_url = "../..";</script>
    <script src="../../js/theme_extra.js"></script>
    <script src="../../js/theme.js"></script>
      <script src="../../search/main.js"></script>
    <script>
        jQuery(function () {
            SphinxRtdTheme.Navigation.enable(true);
        });
    </script>

</body>
</html>
