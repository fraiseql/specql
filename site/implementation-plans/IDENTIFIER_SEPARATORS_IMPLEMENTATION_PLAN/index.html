<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
      <link rel="shortcut icon" href="../../img/favicon.ico" />
    <title>Implementation Plan: Identifier Separators (Dot Hierarchy + Composition) - SpecQL Documentation</title>
    <link rel="stylesheet" href="../../css/theme.css" />
    <link rel="stylesheet" href="../../css/theme_extra.css" />
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github.min.css" />
    
      <script>
        // Current page data
        var mkdocs_page_name = "Implementation Plan: Identifier Separators (Dot Hierarchy + Composition)";
        var mkdocs_page_input_path = "implementation-plans/IDENTIFIER_SEPARATORS_IMPLEMENTATION_PLAN.md";
        var mkdocs_page_url = null;
      </script>
    
    <!--[if lt IE 9]>
      <script src="../../js/html5shiv.min.js"></script>
    <![endif]-->
      <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
      <script>hljs.highlightAll();</script> 
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
          <a href="../.." class="icon icon-home"> SpecQL Documentation
        </a><div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../../search.html" method="get">
      <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../..">Home</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="" href="../../getting-started/">Getting Started</a>
                </li>
              </ul>
              <p class="caption"><span class="caption-text">Guides</span></p>
              <ul>
                  <li class="toctree-l1"><a class="" href="../../guides/mutation-patterns/">Mutation Patterns</a>
                  </li>
                  <li class="toctree-l1"><a class="" href="../../guides/test-generation/">Test Generation</a>
                  </li>
                  <li class="toctree-l1"><a class="" href="../../guides/cli/">CLI</a>
                  </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="" href="../../reference/">Reference</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="" href="../../examples/">Examples</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="" href="../../tutorials/">Tutorials</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="" href="../../best-practices/">Best Practices</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="" href="../../troubleshooting/">Troubleshooting</a>
                </li>
              </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">
      <nav class="wy-nav-top" role="navigation" aria-label="Mobile navigation menu">
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../..">SpecQL Documentation</a>
        
      </nav>
      <div class="wy-nav-content">
        <div class="rst-content"><div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../.." class="icon icon-home" aria-label="Docs"></a></li>
      <li class="breadcrumb-item active">Implementation Plan: Identifier Separators (Dot Hierarchy + Composition)</li>
    <li class="wy-breadcrumbs-aside">
    </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
            <div class="section" itemprop="articleBody">
              
                <h1 id="implementation-plan-identifier-separators-dot-hierarchy-composition">Implementation Plan: Identifier Separators (Dot Hierarchy + Composition)</h1>
<p><strong>Status</strong>: üéØ Detailed Phased Plan (TDD Methodology)
<strong>Timeline</strong>: 5 days (Team A/B/C coordination)
<strong>Dependencies</strong>: Team A parser complete, <code>safe_slug()</code> function exists
<strong>Related Docs</strong>:
- <code>IDENTIFIER_SEPARATORS_STRATEGY.md</code>
- <code>IDENTIFIER_STRATEGIES_SPECQL.md</code>
- PrintOptim allocation pattern</p>
<hr />
<h2 id="overview">üìã Overview</h2>
<p>Implement <strong>3-level separator hierarchy</strong> based on PrintOptim production patterns:
1. <strong>Tenant prefix</strong>: <code>|</code> (pipe)
2. <strong>Hierarchy levels</strong>: <code>.</code> (dot) ‚Üê <strong>Change from underscore</strong>
3. <strong>Cross-hierarchy composition</strong>: <code>‚àò</code> (ring operator) ‚Üê <strong>New feature</strong></p>
<p><strong>Total Effort</strong>: 5 days across Teams A, B, C</p>
<hr />
<h2 id="success-criteria">üéØ Success Criteria</h2>
<ul>
<li>[ ] Default hierarchy separator changed to <code>.</code> (dot)</li>
<li>[ ] Tenant prefix remains <code>|</code> (backward compatible)</li>
<li>[ ] New <code>‚àò</code> composition separator for cross-hierarchy</li>
<li>[ ] <code>strip_tenant_prefix</code> works in composite identifiers</li>
<li>[ ] <code>composite_hierarchical</code> strategy implemented</li>
<li>[ ] All existing tests pass with new defaults</li>
<li>[ ] 90%+ test coverage</li>
<li>[ ] Documentation updated</li>
</ul>
<hr />
<h2 id="phased-implementation-tdd">üìÖ Phased Implementation (TDD)</h2>
<h3 id="phase-1-separator-constants-utilities-day-1"><strong>Phase 1: Separator Constants &amp; Utilities</strong> (Day 1)</h3>
<p><strong>Objective</strong>: Define separator constants and utility functions</p>
<p><strong>TDD Cycle 1.1: Separator Constants</strong></p>
<h4 id="red-write-failing-test">üî¥ RED: Write Failing Test</h4>
<p><strong>File</strong>: <code>tests/unit/core/test_separator_constants.py</code> (NEW)</p>
<pre><code class="language-python">&quot;&quot;&quot;Test separator constants and utilities.&quot;&quot;&quot;

import pytest
from src.core.separators import Separators


class TestSeparatorConstants:
    &quot;&quot;&quot;Test separator constant definitions.&quot;&quot;&quot;

    def test_tenant_separator_is_pipe(self):
        &quot;&quot;&quot;Tenant separator should be pipe.&quot;&quot;&quot;
        assert Separators.TENANT == &quot;|&quot;

    def test_hierarchy_separator_is_dot(self):
        &quot;&quot;&quot;Hierarchy separator should be dot (NEW default).&quot;&quot;&quot;
        assert Separators.HIERARCHY == &quot;.&quot;

    def test_composition_separator_is_ring(self):
        &quot;&quot;&quot;Composition separator should be ring operator.&quot;&quot;&quot;
        assert Separators.COMPOSITION == &quot;‚àò&quot;

    def test_deduplication_suffix_is_hash(self):
        &quot;&quot;&quot;Deduplication suffix should be hash.&quot;&quot;&quot;
        assert Separators.DEDUPLICATION == &quot;#&quot;

    def test_ordering_separator_is_dash(self):
        &quot;&quot;&quot;Ordering separator should be dash.&quot;&quot;&quot;
        assert Separators.ORDERING == &quot;-&quot;

    def test_all_separators_unique(self):
        &quot;&quot;&quot;All separators should be unique characters.&quot;&quot;&quot;
        separators = [
            Separators.TENANT,
            Separators.HIERARCHY,
            Separators.COMPOSITION,
            Separators.DEDUPLICATION,
            Separators.ORDERING
        ]
        assert len(separators) == len(set(separators))

    def test_composition_fallback_is_tilde(self):
        &quot;&quot;&quot;Fallback for composition separator should be tilde.&quot;&quot;&quot;
        assert Separators.COMPOSITION_FALLBACK == &quot;~&quot;
</code></pre>
<p><strong>Expected</strong>: ‚ùå FAIL - Module does not exist</p>
<h4 id="green-minimal-implementation">üü¢ GREEN: Minimal Implementation</h4>
<p><strong>File</strong>: <code>src/core/separators.py</code> (NEW)</p>
<pre><code class="language-python">&quot;&quot;&quot;Separator constants for identifier generation.&quot;&quot;&quot;


class Separators:
    &quot;&quot;&quot;Identifier separator constants.

    Three-level hierarchy:
    1. TENANT (|): Separates tenant from entity identifier
    2. HIERARCHY (.): Separates parent from child within one tree
    3. COMPOSITION (‚àò): Combines identifiers from different hierarchies

    Examples:
        Simple:       acme-corp|coffee-maker
        Hierarchical: acme-corp|warehouse.floor1.room101
        Composite:    acme-corp|2025-Q1‚àòmachine.child‚àòlocation.child
    &quot;&quot;&quot;

    # Level 1: Tenant scoping
    TENANT = &quot;|&quot;

    # Level 2: Hierarchy depth (within single tree)
    HIERARCHY = &quot;.&quot;

    # Level 3: Cross-hierarchy composition
    COMPOSITION = &quot;‚àò&quot;  # U+2218 Ring Operator
    COMPOSITION_FALLBACK = &quot;~&quot;  # If ‚àò causes encoding issues

    # Other separators
    DEDUPLICATION = &quot;#&quot;
    ORDERING = &quot;-&quot;

    # Legacy support (old default was underscore)
    HIERARCHY_LEGACY = &quot;_&quot;


# Default separator configuration
DEFAULT_SEPARATORS = {
    &quot;tenant&quot;: Separators.TENANT,
    &quot;hierarchy&quot;: Separators.HIERARCHY,
    &quot;composition&quot;: Separators.COMPOSITION,
    &quot;deduplication&quot;: Separators.DEDUPLICATION,
    &quot;ordering&quot;: Separators.ORDERING
}
</code></pre>
<p><strong>Expected</strong>: ‚úÖ PASS</p>
<h4 id="refactor-add-utility-functions">üîß REFACTOR: Add Utility Functions</h4>
<p><strong>File</strong>: <code>src/core/separators.py</code> (UPDATE)</p>
<pre><code class="language-python">def strip_tenant_prefix(identifier: str, tenant_identifier: str) -&gt; str:
    &quot;&quot;&quot;Strip tenant prefix from identifier.

    Args:
        identifier: Full identifier (e.g., &quot;acme-corp|warehouse.floor1&quot;)
        tenant_identifier: Tenant identifier (e.g., &quot;acme-corp&quot;)

    Returns:
        Identifier without tenant prefix (e.g., &quot;warehouse.floor1&quot;)

    Examples:
        &gt;&gt;&gt; strip_tenant_prefix(&quot;acme-corp|warehouse.floor1&quot;, &quot;acme-corp&quot;)
        'warehouse.floor1'
        &gt;&gt;&gt; strip_tenant_prefix(&quot;no-prefix&quot;, &quot;acme-corp&quot;)
        'no-prefix'
    &quot;&quot;&quot;
    prefix = f&quot;{tenant_identifier}{Separators.TENANT}&quot;
    if identifier.startswith(prefix):
        return identifier[len(prefix):]
    return identifier


def join_with_composition(components: list[str]) -&gt; str:
    &quot;&quot;&quot;Join components with composition separator.

    Args:
        components: List of identifier components

    Returns:
        Joined identifier

    Examples:
        &gt;&gt;&gt; join_with_composition([&quot;2025-Q1&quot;, &quot;machine.child&quot;, &quot;location.parent&quot;])
        '2025-Q1‚àòmachine.child‚àòlocation.parent'
    &quot;&quot;&quot;
    return Separators.COMPOSITION.join(components)


def split_composition(identifier: str) -&gt; list[str]:
    &quot;&quot;&quot;Split identifier by composition separator.

    Args:
        identifier: Composite identifier

    Returns:
        List of components

    Examples:
        &gt;&gt;&gt; split_composition(&quot;2025-Q1‚àòmachine‚àòlocation&quot;)
        ['2025-Q1', 'machine', 'location']
    &quot;&quot;&quot;
    return identifier.split(Separators.COMPOSITION)
</code></pre>
<h4 id="qa-phase-1-complete">‚úÖ QA: Phase 1 Complete</h4>
<pre><code class="language-bash">uv run pytest tests/unit/core/test_separator_constants.py -v
uv run pytest tests/unit/core/test_separators.py -v  # Utility tests
uv run pytest tests/unit/core/ -v
uv run pytest --tb=short
make lint &amp;&amp; make typecheck
</code></pre>
<p><strong>Deliverables</strong>:
- ‚úÖ <code>Separators</code> class with all constants
- ‚úÖ Utility functions for stripping/joining
- ‚úÖ Comprehensive tests</p>
<hr />
<h3 id="phase-2-team-a-parse-separator-config-day-1"><strong>Phase 2: Team A - Parse Separator Config</strong> (Day 1)</h3>
<p><strong>Objective</strong>: Parse separator configuration from SpecQL YAML</p>
<p><strong>TDD Cycle 2.1: Parse Separator Overrides</strong></p>
<h4 id="red-write-failing-test_1">üî¥ RED: Write Failing Test</h4>
<p><strong>File</strong>: <code>tests/unit/core/test_specql_parser_separators.py</code> (NEW)</p>
<pre><code class="language-python">&quot;&quot;&quot;Test SpecQL parser separator configuration.&quot;&quot;&quot;

import pytest
from src.core.specql_parser import SpecQLParser
from src.core.separators import Separators


class TestParseIdentifierSeparators:
    &quot;&quot;&quot;Test parsing of separator configuration.&quot;&quot;&quot;

    def test_default_separators_when_not_specified(self):
        &quot;&quot;&quot;Should use default separators if not specified.&quot;&quot;&quot;
        yaml_content = &quot;&quot;&quot;
entity: Location
hierarchical: true
fields:
  name: text
&quot;&quot;&quot;
        parser = SpecQLParser()
        entity = parser.parse(yaml_content)

        # Should use defaults (no explicit config)
        assert entity.identifier is None or entity.identifier.separator == Separators.HIERARCHY

    def test_parse_explicit_hierarchy_separator(self):
        &quot;&quot;&quot;Should parse explicit hierarchy separator override.&quot;&quot;&quot;
        yaml_content = &quot;&quot;&quot;
entity: Location
hierarchical: true
identifier:
  separator: &quot;_&quot;  # Override to underscore
fields:
  name: text
&quot;&quot;&quot;
        parser = SpecQLParser()
        entity = parser.parse(yaml_content)

        assert entity.identifier is not None
        assert entity.identifier.separator == &quot;_&quot;

    def test_parse_composition_separator(self):
        &quot;&quot;&quot;Should parse composition separator for composite strategy.&quot;&quot;&quot;
        yaml_content = &quot;&quot;&quot;
entity: Allocation
identifier:
  strategy: composite_hierarchical
  composition_separator: &quot;‚àò&quot;
  components:
    - field: machine.identifier
      strip_tenant_prefix: true
    - field: location.identifier
      strip_tenant_prefix: true
&quot;&quot;&quot;
        parser = SpecQLParser()
        entity = parser.parse(yaml_content)

        assert entity.identifier.strategy == &quot;composite_hierarchical&quot;
        assert entity.identifier.composition_separator == &quot;‚àò&quot;
        assert len(entity.identifier.components) == 2
        assert entity.identifier.components[0].strip_tenant_prefix is True

    def test_parse_strip_tenant_prefix_option(self):
        &quot;&quot;&quot;Should parse strip_tenant_prefix for components.&quot;&quot;&quot;
        yaml_content = &quot;&quot;&quot;
entity: Allocation
identifier:
  strategy: composite_hierarchical
  components:
    - field: daterange
      strip_tenant_prefix: false
    - field: machine.identifier
      strip_tenant_prefix: true
&quot;&quot;&quot;
        parser = SpecQLParser()
        entity = parser.parse(yaml_content)

        assert entity.identifier.components[0].strip_tenant_prefix is False
        assert entity.identifier.components[1].strip_tenant_prefix is True

    def test_default_composition_separator(self):
        &quot;&quot;&quot;Should default to ring operator for composition separator.&quot;&quot;&quot;
        yaml_content = &quot;&quot;&quot;
entity: Allocation
identifier:
  strategy: composite_hierarchical
  components:
    - field: machine.identifier
&quot;&quot;&quot;
        parser = SpecQLParser()
        entity = parser.parse(yaml_content)

        # Default composition separator
        assert entity.identifier.composition_separator == Separators.COMPOSITION or \
               entity.identifier.composition_separator is None  # Will use default
</code></pre>
<p><strong>Expected</strong>: ‚ùå FAIL - Parser doesn't support these fields</p>
<h4 id="green-minimal-implementation_1">üü¢ GREEN: Minimal Implementation</h4>
<p><strong>File</strong>: <code>src/core/ast_models.py</code> (UPDATE)</p>
<pre><code class="language-python">@dataclass
class IdentifierComponent:
    &quot;&quot;&quot;Component of identifier calculation.&quot;&quot;&quot;
    field: str
    transform: str = &quot;slugify&quot;
    format: Optional[str] = None
    separator: str = &quot;&quot;
    replace: Optional[Dict[str, str]] = None
    strip_tenant_prefix: bool = False  # NEW: Strip tenant prefix from referenced identifiers


@dataclass
class IdentifierConfig:
    &quot;&quot;&quot;Identifier calculation strategy.&quot;&quot;&quot;
    strategy: str

    # Components
    prefix: List[IdentifierComponent] = field(default_factory=list)
    components: List[IdentifierComponent] = field(default_factory=list)

    # Separators (NEW)
    separator: str = Separators.HIERARCHY  # Default changed from &quot;_&quot; to &quot;.&quot;
    composition_separator: str = Separators.COMPOSITION  # For composite_hierarchical

    # ... existing fields ...
</code></pre>
<p><strong>File</strong>: <code>src/core/specql_parser.py</code> (UPDATE)</p>
<pre><code class="language-python">from src.core.separators import Separators

class SpecQLParser:
    def _parse_identifier_config(self, yaml_data: dict) -&gt; Optional[IdentifierConfig]:
        &quot;&quot;&quot;Parse identifier configuration from YAML.&quot;&quot;&quot;

        if &quot;identifier&quot; not in yaml_data:
            return None

        id_config = yaml_data[&quot;identifier&quot;]

        # Parse separators
        hierarchy_separator = id_config.get(&quot;separator&quot;, Separators.HIERARCHY)
        composition_separator = id_config.get(&quot;composition_separator&quot;, Separators.COMPOSITION)

        # Parse components
        components = self._parse_identifier_components(id_config.get(&quot;components&quot;, []))

        return IdentifierConfig(
            strategy=id_config.get(&quot;strategy&quot;, &quot;simple&quot;),
            separator=hierarchy_separator,
            composition_separator=composition_separator,
            components=components,
            # ... other fields ...
        )

    def _parse_identifier_components(
        self,
        components: List[Union[str, dict]]
    ) -&gt; List[IdentifierComponent]:
        &quot;&quot;&quot;Parse identifier components (with strip_tenant_prefix support).&quot;&quot;&quot;

        result = []

        for comp in components:
            if isinstance(comp, str):
                # Shorthand
                result.append(IdentifierComponent(field=comp, transform=&quot;slugify&quot;))
            else:
                # Detailed config
                result.append(IdentifierComponent(
                    field=comp[&quot;field&quot;],
                    transform=comp.get(&quot;transform&quot;, &quot;slugify&quot;),
                    format=comp.get(&quot;format&quot;),
                    separator=comp.get(&quot;separator&quot;, &quot;&quot;),
                    replace=comp.get(&quot;replace&quot;),
                    strip_tenant_prefix=comp.get(&quot;strip_tenant_prefix&quot;, False)  # NEW
                ))

        return result
</code></pre>
<p><strong>Expected</strong>: ‚úÖ PASS</p>
<h4 id="qa-phase-2-complete">‚úÖ QA: Phase 2 Complete</h4>
<pre><code class="language-bash">uv run pytest tests/unit/core/test_specql_parser_separators.py -v
uv run pytest tests/unit/core/test_specql_parser.py -v
uv run pytest --tb=short
</code></pre>
<p><strong>Deliverables</strong>:
- ‚úÖ Parser supports <code>separator</code>, <code>composition_separator</code>
- ‚úÖ Parser supports <code>strip_tenant_prefix</code> on components
- ‚úÖ Default separator is <code>.</code> (dot)</p>
<hr />
<h3 id="phase-3-team-c-hierarchical-with-dot-separator-day-2"><strong>Phase 3: Team C - Hierarchical with Dot Separator</strong> (Day 2)</h3>
<p><strong>Objective</strong>: Update hierarchical identifier generation to use dot separator</p>
<p><strong>TDD Cycle 3.1: Simple Hierarchical with Dot</strong></p>
<h4 id="red-write-failing-test_2">üî¥ RED: Write Failing Test</h4>
<p><strong>File</strong>: <code>tests/unit/actions/test_identifier_hierarchical_dot.py</code> (NEW)</p>
<pre><code class="language-python">&quot;&quot;&quot;Test hierarchical identifier generation with dot separator.&quot;&quot;&quot;

import pytest
from tests.utils.db_test import execute_sql, execute_query


class TestHierarchicalDotSeparator:
    &quot;&quot;&quot;Test hierarchical identifiers use dot by default.&quot;&quot;&quot;

    @pytest.fixture
    def location_hierarchy(self, db):
        &quot;&quot;&quot;Create location hierarchy for testing.&quot;&quot;&quot;
        execute_sql(db, &quot;&quot;&quot;
            CREATE SCHEMA IF NOT EXISTS tenant;

            CREATE TABLE tenant.tb_location (
                pk_location INTEGER PRIMARY KEY,
                id UUID DEFAULT gen_random_uuid(),
                tenant_id UUID NOT NULL,
                fk_parent_location INTEGER REFERENCES tenant.tb_location(pk_location),
                name TEXT NOT NULL,
                identifier TEXT,
                base_identifier TEXT,
                sequence_number INTEGER DEFAULT 1,
                identifier_recalculated_at TIMESTAMPTZ,
                identifier_recalculated_by UUID
            );

            -- Create tenant
            CREATE TABLE management.tb_tenant (
                pk_tenant INTEGER PRIMARY KEY,
                id UUID DEFAULT gen_random_uuid(),
                identifier TEXT NOT NULL
            );

            INSERT INTO management.tb_tenant (pk_tenant, id, identifier)
            VALUES (1, gen_random_uuid(), 'acme-corp');

            -- Create hierarchy
            INSERT INTO tenant.tb_location (pk_location, tenant_id, fk_parent_location, name)
            VALUES
                (1, (SELECT id FROM management.tb_tenant WHERE pk_tenant = 1), NULL, 'Warehouse A'),
                (2, (SELECT id FROM management.tb_tenant WHERE pk_tenant = 1), 1, 'Floor 1'),
                (3, (SELECT id FROM management.tb_tenant WHERE pk_tenant = 1), 2, 'Room 101');
        &quot;&quot;&quot;)
        yield
        execute_sql(db, &quot;DROP SCHEMA tenant CASCADE; DROP SCHEMA management CASCADE;&quot;)

    def test_hierarchical_uses_dot_separator(self, db, location_hierarchy):
        &quot;&quot;&quot;Hierarchical identifiers should use dot separator by default.&quot;&quot;&quot;
        # Generate recalculate function (Team C generates this)
        # Simulated generated function
        execute_sql(db, &quot;&quot;&quot;
            CREATE OR REPLACE FUNCTION tenant.recalculate_location_identifier()
            RETURNS INTEGER AS $$
            DECLARE
                v_count INTEGER := 0;
            BEGIN
                WITH RECURSIVE hierarchy AS (
                    -- Root nodes
                    SELECT
                        l.pk_location,
                        (SELECT identifier FROM management.tb_tenant WHERE id = l.tenant_id)
                            || '|' || public.safe_slug(l.name) AS base_identifier
                    FROM tenant.tb_location l
                    WHERE l.fk_parent_location IS NULL

                    UNION ALL

                    -- Child nodes (use DOT separator)
                    SELECT
                        child.pk_location,
                        parent.base_identifier || '.' || public.safe_slug(child.name)
                    FROM tenant.tb_location child
                    JOIN hierarchy parent ON child.fk_parent_location = parent.pk_location
                )
                UPDATE tenant.tb_location l
                SET
                    identifier = h.base_identifier,
                    base_identifier = h.base_identifier
                FROM hierarchy h
                WHERE l.pk_location = h.pk_location;

                GET DIAGNOSTICS v_count = ROW_COUNT;
                RETURN v_count;
            END;
            $$ LANGUAGE plpgsql;
        &quot;&quot;&quot;)

        # Execute recalculation
        result = execute_query(db, &quot;SELECT tenant.recalculate_location_identifier()&quot;)
        assert result &gt;= 3  # Updated 3 nodes

        # Verify identifiers use dot separator
        locations = execute_query(db, &quot;&quot;&quot;
            SELECT pk_location, identifier
            FROM tenant.tb_location
            ORDER BY pk_location
        &quot;&quot;&quot;, fetch_all=True)

        assert locations[0]['identifier'] == 'acme-corp|warehouse-a'  # Root
        assert locations[1]['identifier'] == 'acme-corp|warehouse-a.floor-1'  # Child (DOT!)
        assert locations[2]['identifier'] == 'acme-corp|warehouse-a.floor-1.room-101'  # Grandchild (DOT!)

    def test_explicit_underscore_override(self, db, location_hierarchy):
        &quot;&quot;&quot;Should support explicit underscore override for backward compatibility.&quot;&quot;&quot;
        # Generate function with underscore separator (explicit override)
        execute_sql(db, &quot;&quot;&quot;
            CREATE OR REPLACE FUNCTION tenant.recalculate_location_identifier_underscore()
            RETURNS INTEGER AS $$
            BEGIN
                WITH RECURSIVE hierarchy AS (
                    SELECT
                        l.pk_location,
                        (SELECT identifier FROM management.tb_tenant WHERE id = l.tenant_id)
                            || '|' || public.safe_slug(l.name) AS base_identifier
                    FROM tenant.tb_location l
                    WHERE l.fk_parent_location IS NULL

                    UNION ALL

                    SELECT
                        child.pk_location,
                        parent.base_identifier || '_' || public.safe_slug(child.name)  -- Underscore override
                    FROM tenant.tb_location child
                    JOIN hierarchy parent ON child.fk_parent_location = parent.pk_location
                )
                UPDATE tenant.tb_location l
                SET identifier = h.base_identifier
                FROM hierarchy h
                WHERE l.pk_location = h.pk_location;

                RETURN (SELECT COUNT(*) FROM tenant.tb_location);
            END;
            $$ LANGUAGE plpgsql;
        &quot;&quot;&quot;)

        execute_query(db, &quot;SELECT tenant.recalculate_location_identifier_underscore()&quot;)

        locations = execute_query(db, &quot;&quot;&quot;
            SELECT identifier FROM tenant.tb_location ORDER BY pk_location
        &quot;&quot;&quot;, fetch_all=True)

        assert locations[1]['identifier'] == 'acme-corp|warehouse-a_floor-1'  # Underscore!
</code></pre>
<p><strong>Expected</strong>: ‚ùå FAIL - Generated function doesn't exist yet</p>
<h4 id="green-minimal-implementation_2">üü¢ GREEN: Minimal Implementation</h4>
<p><strong>File</strong>: <code>src/generators/actions/identifier_recalc_generator.py</code> (UPDATE)</p>
<pre><code class="language-python">from src.core.separators import Separators

class IdentifierRecalcGenerator:
    def _generate_hierarchical_strategy(self, entity: EntityDefinition) -&gt; str:
        &quot;&quot;&quot;Generate hierarchical identifier recalculation with DOT separator.&quot;&quot;&quot;

        entity_lower = entity.name.lower()
        schema = entity.schema
        parent_field = f&quot;fk_parent_{entity_lower}&quot;

        # Get separator (default is now DOT)
        separator = Separators.HIERARCHY
        if entity.identifier and entity.identifier.separator:
            separator = entity.identifier.separator

        # Check for tenant prefix
        has_tenant_prefix = self._should_apply_tenant_prefix(entity)
        tenant_expr = &quot;&quot;
        if has_tenant_prefix:
            tenant_lookup = self._get_tenant_identifier_expression(entity)
            tenant_expr = f&quot;{tenant_lookup} || '{Separators.TENANT}' || &quot;

        # Build component expression
        component_expr = self._build_component_expression(
            entity.identifier.components if entity.identifier else [
                IdentifierComponent(field=&quot;name&quot;, transform=&quot;slugify&quot;)
            ]
        )

        return f&quot;&quot;&quot;
-- Recalculate hierarchical identifiers (separator: '{separator}')
CREATE OR REPLACE FUNCTION {schema}.recalculate_{entity_lower}_identifier(
    ctx core.recalculation_context DEFAULT ROW(NULL, NULL, NULL)::core.recalculation_context
) RETURNS INTEGER AS $$
DECLARE
    v_updated_count INTEGER := 0;
BEGIN
    -- Build hierarchical identifiers using recursive CTE
    WITH RECURSIVE hierarchy AS (
        -- Root nodes
        SELECT
            t.pk_{entity_lower},
            {tenant_expr}{component_expr} AS base_identifier
        FROM {schema}.tb_{entity_lower} t
        WHERE t.{parent_field} IS NULL

        UNION ALL

        -- Child nodes (use configured separator: '{separator}')
        SELECT
            child.pk_{entity_lower},
            parent.base_identifier || '{separator}' || {component_expr}
        FROM {schema}.tb_{entity_lower} child
        JOIN hierarchy parent ON child.{parent_field} = parent.pk_{entity_lower}
    )
    UPDATE {schema}.tb_{entity_lower} t
    SET
        identifier = h.base_identifier,
        base_identifier = h.base_identifier,
        identifier_recalculated_at = now(),
        identifier_recalculated_by = ctx.updated_by
    FROM hierarchy h
    WHERE t.pk_{entity_lower} = h.pk_{entity_lower}
      AND (
          t.identifier IS DISTINCT FROM h.base_identifier OR
          t.base_identifier IS DISTINCT FROM h.base_identifier
      );

    GET DIAGNOSTICS v_updated_count = ROW_COUNT;
    RETURN v_updated_count;
END;
$$ LANGUAGE plpgsql;

COMMENT ON FUNCTION {schema}.recalculate_{entity_lower}_identifier IS
'Recalculate hierarchical identifiers for {entity.name}.
Separator: {separator} (default: dot for hierarchy)
Pattern: {{tenant}}|{{parent}}{separator}{{child}}';
&quot;&quot;&quot;.strip()
</code></pre>
<p><strong>Expected</strong>: ‚úÖ PASS</p>
<h4 id="qa-phase-3-complete">‚úÖ QA: Phase 3 Complete</h4>
<pre><code class="language-bash">uv run pytest tests/unit/actions/test_identifier_hierarchical_dot.py -v
uv run pytest tests/unit/actions/ -v
uv run pytest --tb=short
</code></pre>
<p><strong>Deliverables</strong>:
- ‚úÖ Hierarchical generation uses dot by default
- ‚úÖ Explicit override to underscore works
- ‚úÖ Tenant prefix still uses pipe</p>
<hr />
<h3 id="phase-4-team-c-composite-hierarchical-strategy-days-3-4"><strong>Phase 4: Team C - Composite Hierarchical Strategy</strong> (Days 3-4)</h3>
<p><strong>Objective</strong>: Implement cross-hierarchy composition with ring operator</p>
<p><strong>TDD Cycle 4.1: Strip Tenant Prefix Logic</strong></p>
<h4 id="red-write-failing-test_3">üî¥ RED: Write Failing Test</h4>
<p><strong>File</strong>: <code>tests/unit/actions/test_strip_tenant_prefix.py</code> (NEW)</p>
<pre><code class="language-python">&quot;&quot;&quot;Test tenant prefix stripping for composite identifiers.&quot;&quot;&quot;

import pytest
from tests.utils.db_test import execute_sql, execute_query


class TestStripTenantPrefix:
    &quot;&quot;&quot;Test stripping tenant prefix from referenced identifiers.&quot;&quot;&quot;

    @pytest.fixture
    def composite_setup(self, db):
        &quot;&quot;&quot;Create entities for composite testing.&quot;&quot;&quot;
        execute_sql(db, &quot;&quot;&quot;
            CREATE SCHEMA tenant;
            CREATE SCHEMA management;

            CREATE TABLE management.tb_tenant (
                pk_tenant INTEGER PRIMARY KEY,
                id UUID DEFAULT gen_random_uuid(),
                identifier TEXT NOT NULL
            );

            CREATE TABLE tenant.tb_machine (
                pk_machine INTEGER PRIMARY KEY,
                id UUID DEFAULT gen_random_uuid(),
                tenant_id UUID NOT NULL,
                identifier TEXT NOT NULL
            );

            CREATE TABLE tenant.tb_location (
                pk_location INTEGER PRIMARY KEY,
                id UUID DEFAULT gen_random_uuid(),
                tenant_id UUID NOT NULL,
                identifier TEXT NOT NULL
            );

            INSERT INTO management.tb_tenant (pk_tenant, id, identifier)
            VALUES (1, gen_random_uuid(), 'acme-corp');

            INSERT INTO tenant.tb_machine (pk_machine, tenant_id, identifier)
            VALUES (1, (SELECT id FROM management.tb_tenant WHERE pk_tenant = 1), 'acme-corp|hp.laser.s123');

            INSERT INTO tenant.tb_location (pk_location, tenant_id, identifier)
            VALUES (1, (SELECT id FROM management.tb_tenant WHERE pk_tenant = 1), 'acme-corp|warehouse.floor1');
        &quot;&quot;&quot;)
        yield
        execute_sql(db, &quot;DROP SCHEMA tenant CASCADE; DROP SCHEMA management CASCADE;&quot;)

    def test_strip_tenant_prefix_from_machine(self, db, composite_setup):
        &quot;&quot;&quot;Should strip tenant prefix from machine identifier.&quot;&quot;&quot;
        result = execute_query(db, &quot;&quot;&quot;
            SELECT
                m.identifier AS full_identifier,
                REGEXP_REPLACE(
                    m.identifier,
                    '^' || (SELECT identifier FROM management.tb_tenant WHERE id = m.tenant_id) || '\\|',
                    ''
                ) AS stripped_identifier
            FROM tenant.tb_machine m
            WHERE pk_machine = 1;
        &quot;&quot;&quot;)

        assert result['full_identifier'] == 'acme-corp|hp.laser.s123'
        assert result['stripped_identifier'] == 'hp.laser.s123'  # Prefix stripped!

    def test_composite_identifier_without_duplicate_tenant(self, db, composite_setup):
        &quot;&quot;&quot;Composite identifier should not have duplicate tenant prefix.&quot;&quot;&quot;
        # Simulate allocation identifier construction
        result = execute_query(db, &quot;&quot;&quot;
            SELECT
                (SELECT identifier FROM management.tb_tenant WHERE pk_tenant = 1)
                    || '|2025-Q1‚àò'
                    || REGEXP_REPLACE(m.identifier, '^' || (SELECT identifier FROM management.tb_tenant WHERE id = m.tenant_id) || '\\|', '')
                    || '‚àò'
                    || REGEXP_REPLACE(l.identifier, '^' || (SELECT identifier FROM management.tb_tenant WHERE id = l.tenant_id) || '\\|', '')
                AS composite_identifier
            FROM tenant.tb_machine m, tenant.tb_location l
            WHERE m.pk_machine = 1 AND l.pk_location = 1;
        &quot;&quot;&quot;)

        composite = result['composite_identifier']

        # Should be: acme-corp|2025-Q1‚àòhp.laser.s123‚àòwarehouse.floor1
        assert composite == 'acme-corp|2025-Q1‚àòhp.laser.s123‚àòwarehouse.floor1'

        # Should NOT be: acme-corp|2025-Q1‚àòacme-corp|hp.laser.s123‚àòacme-corp|warehouse.floor1
        assert 'acme-corp|acme-corp' not in composite
        assert composite.count('acme-corp') == 1  # Only once at start!
</code></pre>
<p><strong>Expected</strong>: ‚ùå FAIL - SQL pattern doesn't exist in generator yet</p>
<h4 id="green-minimal-implementation_3">üü¢ GREEN: Minimal Implementation</h4>
<p><strong>File</strong>: <code>src/generators/actions/identifier_recalc_generator.py</code> (UPDATE)</p>
<pre><code class="language-python">def _generate_composite_hierarchical_strategy(
    self,
    entity: EntityDefinition
) -&gt; str:
    &quot;&quot;&quot;Generate composite hierarchical identifier (allocation pattern).&quot;&quot;&quot;

    entity_lower = entity.name.lower()
    schema = entity.schema

    # Get separators
    composition_sep = entity.identifier.composition_separator or Separators.COMPOSITION

    # Check for tenant prefix
    has_tenant_prefix = self._should_apply_tenant_prefix(entity)
    tenant_field = self._detect_tenant_field(entity) if has_tenant_prefix else None

    # Build component expressions
    component_exprs = []
    for comp in entity.identifier.components:
        expr = f&quot;t.{comp.field}&quot;

        # Apply transforms
        if comp.transform == &quot;slugify&quot;:
            expr = f&quot;public.safe_slug({expr})&quot;
        elif comp.transform == &quot;uppercase&quot;:
            expr = f&quot;UPPER({expr})&quot;
        elif comp.transform == &quot;lowercase&quot;:
            expr = f&quot;LOWER({expr})&quot;

        # Strip tenant prefix if requested
        if comp.strip_tenant_prefix and has_tenant_prefix and tenant_field:
            tenant_lookup = self._get_tenant_identifier_expression(entity)
            expr = f&quot;&quot;&quot;REGEXP_REPLACE(
                {expr},
                '^' || {tenant_lookup} || '\\{Separators.TENANT}',
                ''
            )&quot;&quot;&quot;

        # Apply character replacements
        if comp.replace:
            for old_char, new_char in comp.replace.items():
                expr = f&quot;REPLACE({expr}, '{old_char}', '{new_char}')&quot;

        component_exprs.append(expr)

    # Join components with composition separator
    components_joined = f&quot; || '{composition_sep}' || &quot;.join(component_exprs)

    # Add tenant prefix if applicable
    if has_tenant_prefix:
        tenant_lookup = self._get_tenant_identifier_expression(entity)
        base_identifier_expr = f&quot;{tenant_lookup} || '{Separators.TENANT}' || {components_joined}&quot;
    else:
        base_identifier_expr = components_joined

    return f&quot;&quot;&quot;
-- Recalculate composite hierarchical identifiers (allocation pattern)
-- Composition separator: '{composition_sep}'
CREATE OR REPLACE FUNCTION {schema}.recalculate_{entity_lower}_identifier(
    ctx core.recalculation_context DEFAULT ROW(NULL, NULL, NULL)::core.recalculation_context
) RETURNS INTEGER AS $$
DECLARE
    v_updated_count INTEGER := 0;
BEGIN
    -- Create temp table
    DROP TABLE IF EXISTS tmp_{entity_lower}_identifiers;
    CREATE TEMP TABLE tmp_{entity_lower}_identifiers (
        pk_{entity_lower} INTEGER,
        base_identifier TEXT,
        unique_identifier TEXT,
        sequence_number INTEGER
    ) ON COMMIT DROP;

    -- Calculate composite identifiers
    INSERT INTO tmp_{entity_lower}_identifiers (pk_{entity_lower}, base_identifier)
    SELECT
        t.pk_{entity_lower},
        {base_identifier_expr} AS base_identifier
    FROM {schema}.tb_{entity_lower} t
    WHERE
        CASE
            WHEN ctx.pk IS NOT NULL THEN t.id = ctx.pk
            WHEN ctx.pk_tenant IS NOT NULL THEN t.tenant_id = ctx.pk_tenant
            ELSE true
        END;

    -- Deduplicate (same logic as simple strategy)
    -- ... deduplication loop ...

    -- Apply updates
    UPDATE {schema}.tb_{entity_lower} t
    SET
        identifier = tmp.unique_identifier,
        base_identifier = tmp.base_identifier,
        sequence_number = tmp.sequence_number,
        identifier_recalculated_at = now(),
        identifier_recalculated_by = ctx.updated_by
    FROM tmp_{entity_lower}_identifiers tmp
    WHERE t.pk_{entity_lower} = tmp.pk_{entity_lower}
      AND (
          t.identifier IS DISTINCT FROM tmp.unique_identifier OR
          t.sequence_number IS DISTINCT FROM tmp.sequence_number
      );

    GET DIAGNOSTICS v_updated_count = ROW_COUNT;
    RETURN v_updated_count;
END;
$$ LANGUAGE plpgsql;

COMMENT ON FUNCTION {schema}.recalculate_{entity_lower}_identifier IS
'Recalculate composite hierarchical identifiers for {entity.name}.
Strategy: composite_hierarchical
Pattern: {{tenant}}|{{comp1}}{composition_sep}{{comp2}}{composition_sep}...
Components have tenant prefix stripped to avoid duplication.';
&quot;&quot;&quot;.strip()
</code></pre>
<p><strong>Expected</strong>: ‚úÖ PASS</p>
<h4 id="refactor-extract-deduplication-logic">üîß REFACTOR: Extract Deduplication Logic</h4>
<p>Create shared deduplication template to avoid duplication:</p>
<p><strong>File</strong>: <code>src/generators/actions/templates/deduplication_loop.sql.jinja2</code> (NEW)</p>
<pre><code class="language-sql">-- Deduplicate identifiers (WITHIN TENANT if applicable)
FOR v_record IN
    SELECT pk_{{ entity_lower }}, base_identifier
    FROM tmp_{{ entity_lower }}_identifiers
LOOP
    v_new_identifier := v_record.base_identifier;
    v_suffix := 1;

    -- Find unique identifier
    LOOP
        EXIT WHEN NOT EXISTS (
            SELECT 1 FROM {{ schema }}.tb_{{ entity_lower }}
            WHERE identifier = v_new_identifier
              AND pk_{{ entity_lower }} != v_record.pk_{{ entity_lower }}
              AND deleted_at IS NULL
        ) AND NOT EXISTS (
            SELECT 1 FROM tmp_{{ entity_lower }}_identifiers
            WHERE unique_identifier = v_new_identifier
              AND pk_{{ entity_lower }} != v_record.pk_{{ entity_lower }}
        );

        v_suffix := v_suffix + 1;
        v_new_identifier := v_record.base_identifier || '{{ dedup_separator }}' || v_suffix;
    END LOOP;

    -- Update temp table
    UPDATE tmp_{{ entity_lower }}_identifiers
    SET
        unique_identifier = v_new_identifier,
        sequence_number = v_suffix
    WHERE pk_{{ entity_lower }} = v_record.pk_{{ entity_lower }};
END LOOP;
</code></pre>
<p><strong>TDD Cycle 4.2: Integration Test</strong></p>
<h4 id="red-integration-test">üî¥ RED: Integration Test</h4>
<p><strong>File</strong>: <code>tests/integration/test_composite_hierarchical_e2e.py</code> (NEW)</p>
<pre><code class="language-python">&quot;&quot;&quot;End-to-end test of composite hierarchical identifiers.&quot;&quot;&quot;

import pytest
from tests.utils.db_test import execute_sql, execute_query


class TestCompositeHierarchicalE2E:
    &quot;&quot;&quot;Test complete allocation-style composite identifiers.&quot;&quot;&quot;

    @pytest.fixture
    def allocation_schema(self, db):
        &quot;&quot;&quot;Create allocation schema with dependencies.&quot;&quot;&quot;
        # Create all dependent entities
        execute_sql(db, &quot;&quot;&quot;
            CREATE SCHEMA tenant;
            CREATE SCHEMA management;

            -- Tenant
            CREATE TABLE management.tb_tenant (
                pk_tenant INTEGER PRIMARY KEY,
                id UUID DEFAULT gen_random_uuid(),
                identifier TEXT NOT NULL
            );

            -- Machine (hierarchical)
            CREATE TABLE tenant.tb_machine (
                pk_machine INTEGER PRIMARY KEY,
                id UUID DEFAULT gen_random_uuid(),
                tenant_id UUID NOT NULL,
                fk_parent_machine INTEGER REFERENCES tenant.tb_machine(pk_machine),
                name TEXT NOT NULL,
                identifier TEXT
            );

            -- Location (hierarchical)
            CREATE TABLE tenant.tb_location (
                pk_location INTEGER PRIMARY KEY,
                id UUID DEFAULT gen_random_uuid(),
                tenant_id UUID NOT NULL,
                fk_parent_location INTEGER REFERENCES tenant.tb_location(pk_location),
                name TEXT NOT NULL,
                identifier TEXT
            );

            -- Allocation (composite)
            CREATE TABLE tenant.tb_allocation (
                pk_allocation INTEGER PRIMARY KEY,
                id UUID DEFAULT gen_random_uuid(),
                tenant_id UUID NOT NULL,
                allocation_daterange TEXT NOT NULL,
                fk_machine INTEGER REFERENCES tenant.tb_machine(pk_machine),
                fk_location INTEGER REFERENCES tenant.tb_location(pk_location),
                identifier TEXT,
                base_identifier TEXT,
                sequence_number INTEGER DEFAULT 1
            );

            -- Sample data
            INSERT INTO management.tb_tenant VALUES (1, gen_random_uuid(), 'acme-corp');

            -- Machine hierarchy
            INSERT INTO tenant.tb_machine VALUES
                (1, gen_random_uuid(), (SELECT id FROM management.tb_tenant), NULL, 'HP', 'acme-corp|hp'),
                (2, gen_random_uuid(), (SELECT id FROM management.tb_tenant), 1, 'LaserJet', 'acme-corp|hp.laserjet'),
                (3, gen_random_uuid(), (SELECT id FROM management.tb_tenant), 2, 'S123', 'acme-corp|hp.laserjet.s123');

            -- Location hierarchy
            INSERT INTO tenant.tb_location VALUES
                (1, gen_random_uuid(), (SELECT id FROM management.tb_tenant), NULL, 'Warehouse', 'acme-corp|warehouse'),
                (2, gen_random_uuid(), (SELECT id FROM management.tb_tenant), 1, 'Floor 1', 'acme-corp|warehouse.floor1');

            -- Allocation
            INSERT INTO tenant.tb_allocation (pk_allocation, tenant_id, allocation_daterange, fk_machine, fk_location)
            VALUES (1, (SELECT id FROM management.tb_tenant), '2025-Q1', 3, 2);
        &quot;&quot;&quot;)
        yield
        execute_sql(db, &quot;DROP SCHEMA tenant CASCADE; DROP SCHEMA management CASCADE;&quot;)

    def test_allocation_composite_identifier(self, db, allocation_schema):
        &quot;&quot;&quot;Should generate allocation identifier with composition separator.&quot;&quot;&quot;
        # Generate recalculate function (from SpecQL)
        # ... generator creates this function ...

        # Execute recalculation
        execute_query(db, &quot;SELECT tenant.recalculate_allocation_identifier()&quot;)

        # Verify composite identifier
        result = execute_query(db, &quot;&quot;&quot;
            SELECT identifier, base_identifier
            FROM tenant.tb_allocation
            WHERE pk_allocation = 1;
        &quot;&quot;&quot;)

        # Expected: acme-corp|2025-Q1‚àòhp.laserjet.s123‚àòwarehouse.floor1
        identifier = result['identifier']

        assert identifier.startswith('acme-corp|')  # Tenant prefix
        assert '‚àò' in identifier  # Composition separator
        assert identifier.count('acme-corp') == 1  # Only one tenant prefix!
        assert 'hp.laserjet.s123' in identifier  # Machine hierarchy with dots
        assert 'warehouse.floor1' in identifier  # Location hierarchy with dots
        assert identifier == 'acme-corp|2025-Q1‚àòhp.laserjet.s123‚àòwarehouse.floor1'
</code></pre>
<p><strong>Expected</strong>: ‚ùå FAIL initially, then ‚úÖ PASS</p>
<h4 id="qa-phase-4-complete">‚úÖ QA: Phase 4 Complete</h4>
<pre><code class="language-bash">uv run pytest tests/unit/actions/test_strip_tenant_prefix.py -v
uv run pytest tests/integration/test_composite_hierarchical_e2e.py -v
uv run pytest tests/unit/actions/ -v
uv run pytest --tb=short
</code></pre>
<p><strong>Deliverables</strong>:
- ‚úÖ <code>composite_hierarchical</code> strategy implemented
- ‚úÖ Tenant prefix stripping works
- ‚úÖ Ring operator <code>‚àò</code> used for composition
- ‚úÖ Each component hierarchy uses dot separator</p>
<hr />
<h3 id="phase-5-documentation-migration-day-5"><strong>Phase 5: Documentation &amp; Migration</strong> (Day 5)</h3>
<p><strong>Objective</strong>: Update docs, create migration guide, verify backward compatibility</p>
<p><strong>TDD Cycle 5.1: Backward Compatibility Test</strong></p>
<h4 id="red-backward-compatibility-test">üî¥ RED: Backward Compatibility Test</h4>
<p><strong>File</strong>: <code>tests/integration/test_backward_compatibility.py</code> (NEW)</p>
<pre><code class="language-python">&quot;&quot;&quot;Test backward compatibility with underscore separator.&quot;&quot;&quot;

import pytest
from tests.utils.db_test import execute_sql, execute_query


class TestBackwardCompatibility:
    &quot;&quot;&quot;Ensure explicit underscore override still works.&quot;&quot;&quot;

    def test_explicit_underscore_override_works(self, db):
        &quot;&quot;&quot;Entities with explicit underscore config should still work.&quot;&quot;&quot;
        # SpecQL with explicit underscore
        yaml_content = &quot;&quot;&quot;
entity: LegacyLocation
schema: tenant
hierarchical: true
identifier:
  separator: &quot;_&quot;  # Explicit override to old default
fields:
  name: text
&quot;&quot;&quot;
        # Generate and test
        # ... parser + generator + execute ...

        # Should use underscore, not dot
        # identifier should be: acme-corp|parent_child_grandchild
        pass

    def test_new_entities_use_dot_by_default(self, db):
        &quot;&quot;&quot;New entities without explicit config should use dot.&quot;&quot;&quot;
        # SpecQL without separator specified
        yaml_content = &quot;&quot;&quot;
entity: ModernLocation
schema: tenant
hierarchical: true
fields:
  name: text
&quot;&quot;&quot;
        # Generate and test
        # Should use dot: acme-corp|parent.child.grandchild
        pass
</code></pre>
<p><strong>Expected</strong>: ‚ùå FAIL, then ‚úÖ PASS after ensuring override works</p>
<h4 id="green-documentation">üü¢ GREEN: Documentation</h4>
<p><strong>Deliverables</strong>:</p>
<ol>
<li><strong>Update <code>IDENTIFIER_STRATEGIES_SPECQL.md</code></strong></li>
<li>Change all examples to use dot separator</li>
<li>Show composition separator examples</li>
<li>
<p>Document backward compatibility</p>
</li>
<li>
<p><strong>Create Migration Guide</strong>: <code>docs/migration/SEPARATOR_MIGRATION_GUIDE.md</code></p>
</li>
</ol>
<pre><code class="language-markdown"># Migration Guide: Underscore to Dot Hierarchy Separator

## Summary

Default hierarchy separator changed from `_` to `.` in version X.Y.Z.

## Impact

**Low** - Explicit override available, existing data unaffected.

## For Existing Entities

### Option 1: Keep Underscore (Explicit Override)

```yaml
identifier:
  separator: &quot;_&quot;  # Maintain old behavior
</code></pre>
<h3 id="option-2-migrate-to-dot-recommended">Option 2: Migrate to Dot (Recommended)</h3>
<ol>
<li>Update SpecQL YAML (remove explicit <code>separator: "_"</code>)</li>
<li>Regenerate functions</li>
<li>Run identifier recalculation</li>
<li>Update any hardcoded identifier strings</li>
</ol>
<h2 id="for-new-entities">For New Entities</h2>
<p>No action needed - dot separator is now default.</p>
<h2 id="examples">Examples</h2>
<p><strong>Before</strong>:</p>
<pre><code>acme-corp|warehouse_floor1_room101
</code></pre>
<p><strong>After</strong>:</p>
<pre><code>acme-corp|warehouse.floor1.room101
</code></pre>
<pre><code>
3. **Update Examples in Docs**

All documentation examples should show new defaults:
- Dot for hierarchy
- Ring for composition
- Pipe for tenant

#### ‚úÖ QA: Phase 5 Complete

```bash
uv run pytest tests/integration/test_backward_compatibility.py -v
uv run pytest tests/integration/ -v
uv run pytest --tb=short
make lint &amp;&amp; make typecheck
make test
</code></pre>
<p><strong>Deliverables</strong>:
- ‚úÖ Backward compatibility tested
- ‚úÖ Migration guide written
- ‚úÖ All documentation updated
- ‚úÖ Examples show new defaults</p>
<hr />
<h2 id="summary">üìä Summary</h2>
<h3 id="timeline">Timeline</h3>
<table>
<thead>
<tr>
<th>Phase</th>
<th>Days</th>
<th>Focus</th>
<th>Team</th>
<th>Deliverables</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>1</strong></td>
<td>1</td>
<td>Separator constants</td>
<td>All</td>
<td>Constants, utilities, tests</td>
</tr>
<tr>
<td><strong>2</strong></td>
<td>1</td>
<td>Parse config</td>
<td>A</td>
<td>Parser updates, AST changes</td>
</tr>
<tr>
<td><strong>3</strong></td>
<td>1</td>
<td>Hierarchical dot</td>
<td>C</td>
<td>Updated generator, tests</td>
</tr>
<tr>
<td><strong>4</strong></td>
<td>2</td>
<td>Composite strategy</td>
<td>C</td>
<td>New strategy, strip logic</td>
</tr>
<tr>
<td><strong>5</strong></td>
<td>1</td>
<td>Docs &amp; migration</td>
<td>All</td>
<td>Guides, compat tests</td>
</tr>
</tbody>
</table>
<p><strong>Total</strong>: 5 days (1 week)</p>
<h3 id="files-createdmodified">Files Created/Modified</h3>
<p><strong>New Files</strong> (8):
- <code>src/core/separators.py</code>
- <code>tests/unit/core/test_separator_constants.py</code>
- <code>tests/unit/core/test_separators.py</code>
- <code>tests/unit/core/test_specql_parser_separators.py</code>
- <code>tests/unit/actions/test_identifier_hierarchical_dot.py</code>
- <code>tests/unit/actions/test_strip_tenant_prefix.py</code>
- <code>tests/integration/test_composite_hierarchical_e2e.py</code>
- <code>tests/integration/test_backward_compatibility.py</code>
- <code>src/generators/actions/templates/deduplication_loop.sql.jinja2</code>
- <code>docs/migration/SEPARATOR_MIGRATION_GUIDE.md</code></p>
<p><strong>Updated Files</strong> (4):
- <code>src/core/ast_models.py</code>
- <code>src/core/specql_parser.py</code>
- <code>src/generators/actions/identifier_recalc_generator.py</code>
- <code>IDENTIFIER_STRATEGIES_SPECQL.md</code></p>
<p><strong>Total Effort</strong>: ~800 lines code + 1200 lines tests + 300 lines docs = 2300 lines</p>
<hr />
<h2 id="final-acceptance-criteria">‚úÖ Final Acceptance Criteria</h2>
<ul>
<li>[ ] <code>Separators</code> class with all constants</li>
<li>[ ] Default hierarchy separator is <code>.</code> (dot)</li>
<li>[ ] Composition separator is <code>‚àò</code> (ring operator)</li>
<li>[ ] <code>strip_tenant_prefix</code> works correctly</li>
<li>[ ] <code>composite_hierarchical</code> strategy implemented</li>
<li>[ ] Tenant prefix still uses <code>|</code> (pipe)</li>
<li>[ ] Backward compatibility: explicit <code>_</code> override works</li>
<li>[ ] 90%+ test coverage</li>
<li>[ ] All integration tests pass</li>
<li>[ ] Documentation complete</li>
<li>[ ] Migration guide written</li>
</ul>
<hr />
<p><strong>Status</strong>: üéØ Ready for Implementation
<strong>Priority</strong>: HIGH (affects all identifier generation)
<strong>Dependencies</strong>: <code>safe_slug()</code> function, Team A parser complete
<strong>Methodology</strong>: Strict TDD - RED ‚Üí GREEN ‚Üí REFACTOR ‚Üí QA at each phase</p>
              
            </div>
          </div><footer>

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
          
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="Versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    
    
    
  </span>
</div>
    <script src="../../js/jquery-3.6.0.min.js"></script>
    <script>var base_url = "../..";</script>
    <script src="../../js/theme_extra.js"></script>
    <script src="../../js/theme.js"></script>
      <script src="../../search/main.js"></script>
    <script>
        jQuery(function () {
            SphinxRtdTheme.Navigation.enable(true);
        });
    </script>

</body>
</html>
