<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
      <link rel="shortcut icon" href="../../img/favicon.ico" />
    <title>PrintOptim Business Logic Library - Implementation Plan - SpecQL Documentation</title>
    <link rel="stylesheet" href="../../css/theme.css" />
    <link rel="stylesheet" href="../../css/theme_extra.css" />
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github.min.css" />
    
      <script>
        // Current page data
        var mkdocs_page_name = "PrintOptim Business Logic Library - Implementation Plan";
        var mkdocs_page_input_path = "business_logic_library/BUSINESS_LOGIC_LIBRARY_PLAN.md";
        var mkdocs_page_url = null;
      </script>
    
    <!--[if lt IE 9]>
      <script src="../../js/html5shiv.min.js"></script>
    <![endif]-->
      <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
      <script>hljs.highlightAll();</script> 
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
          <a href="../.." class="icon icon-home"> SpecQL Documentation
        </a><div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../../search.html" method="get">
      <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../..">Home</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="" href="../../getting-started/">Getting Started</a>
                </li>
              </ul>
              <p class="caption"><span class="caption-text">Guides</span></p>
              <ul>
                  <li class="toctree-l1"><a class="" href="../../guides/mutation-patterns/">Mutation Patterns</a>
                  </li>
                  <li class="toctree-l1"><a class="" href="../../guides/test-generation/">Test Generation</a>
                  </li>
                  <li class="toctree-l1"><a class="" href="../../guides/cli/">CLI</a>
                  </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="" href="../../reference/">Reference</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="" href="../../examples/">Examples</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="" href="../../tutorials/">Tutorials</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="" href="../../best-practices/">Best Practices</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="" href="../../troubleshooting/">Troubleshooting</a>
                </li>
              </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">
      <nav class="wy-nav-top" role="navigation" aria-label="Mobile navigation menu">
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../..">SpecQL Documentation</a>
        
      </nav>
      <div class="wy-nav-content">
        <div class="rst-content"><div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../.." class="icon icon-home" aria-label="Docs"></a></li>
      <li class="breadcrumb-item active">PrintOptim Business Logic Library - Implementation Plan</li>
    <li class="wy-breadcrumbs-aside">
    </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
            <div class="section" itemprop="articleBody">
              
                <h1 id="printoptim-business-logic-library-implementation-plan">PrintOptim Business Logic Library - Implementation Plan</h1>
<p><strong>Date</strong>: 2025-11-10
<strong>Status</strong>: ğŸ“‹ Planning Phase
<strong>Goal</strong>: Domain-agnostic, reusable business logic patterns for all 74 PrintOptim entities</p>
<hr />
<h2 id="executive-summary">ğŸ¯ Executive Summary</h2>
<p>Build a <strong>comprehensive business logic library</strong> that abstracts common patterns from PrintOptim's reference implementation into reusable, declarative components. This library will enable developers to express complex business operations in YAML, with complete SQL implementations auto-generated by SpecQL.</p>
<p><strong>Impact</strong>:
- <strong>74 entities</strong> Ã— <strong>~8 business actions/entity</strong> = <strong>~600 business functions</strong>
- Current: Manual implementation (~150-400 lines SQL each) = <strong>~120,000 lines</strong>
- Target: Declarative YAML (~10-20 lines each) = <strong>~6,000 lines</strong> (95% reduction)</p>
<hr />
<h2 id="current-state-analysis">ğŸ“Š Current State Analysis</h2>
<h3 id="reference-implementation-inventory">Reference Implementation Inventory</h3>
<p>Based on <code>reference_sql/0_schema/03_functions/</code>, PrintOptim has <strong>177 function files</strong>:</p>
<table>
<thead>
<tr>
<th>Category</th>
<th>Count</th>
<th>Avg Lines</th>
<th>Total Lines</th>
<th>Examples</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>CRUD Create</strong></td>
<td>32</td>
<td>250</td>
<td>8,000</td>
<td><code>create_contract</code>, <code>create_machine</code></td>
</tr>
<tr>
<td><strong>CRUD Update</strong></td>
<td>29</td>
<td>300</td>
<td>8,700</td>
<td><code>update_contract</code>, <code>update_machine</code></td>
</tr>
<tr>
<td><strong>CRUD Delete</strong></td>
<td>25</td>
<td>200</td>
<td>5,000</td>
<td><code>delete_machine</code>, <code>delete_contract_item</code></td>
</tr>
<tr>
<td><strong>Identifier Recalc</strong></td>
<td>20</td>
<td>80</td>
<td>1,600</td>
<td><code>recalcid_contract</code>, <code>recalcid_machine</code></td>
</tr>
<tr>
<td><strong>View Refresh</strong></td>
<td>~20</td>
<td>150</td>
<td>3,000</td>
<td><code>refresh_single_contract</code>, <code>refresh_contracts_by_org</code></td>
</tr>
<tr>
<td><strong>State Transitions</strong></td>
<td>15</td>
<td>250</td>
<td>3,750</td>
<td><code>decommission_machine</code>, <code>activate_contract</code></td>
</tr>
<tr>
<td><strong>Multi-Entity Ops</strong></td>
<td>12</td>
<td>300</td>
<td>3,600</td>
<td><code>allocate_to_stock</code>, <code>create_order_with_items</code></td>
</tr>
<tr>
<td><strong>Batch Operations</strong></td>
<td>8</td>
<td>200</td>
<td>1,600</td>
<td><code>bulk_update_prices</code>, <code>batch_import_products</code></td>
</tr>
<tr>
<td><strong>Business Rules</strong></td>
<td>16</td>
<td>180</td>
<td>2,880</td>
<td><code>validate_allocation</code>, <code>check_contract_eligibility</code></td>
</tr>
<tr>
<td><strong>Total</strong></td>
<td><strong>177</strong></td>
<td><strong>~220</strong></td>
<td><strong>~38,130</strong></td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="pattern-analysis">Pattern Analysis</h3>
<p>I've analyzed the reference SQL and identified <strong>8 core patterns</strong> that cover <strong>95%</strong> of business logic:</p>
<ol>
<li><strong>State Machine</strong> (28% of functions)</li>
<li><strong>Partial Update</strong> (16% of functions)</li>
<li><strong>Multi-Entity Coordination</strong> (15% of functions)</li>
<li><strong>Validation Chain</strong> (12% of functions)</li>
<li><strong>Batch Processing</strong> (10% of functions)</li>
<li><strong>Cascading Operations</strong> (8% of functions)</li>
<li><strong>Conditional Routing</strong> (6% of functions)</li>
<li><strong>Temporal Logic</strong> (5% of functions)</li>
</ol>
<hr />
<h2 id="architecture-overview">ğŸ—ï¸ Architecture Overview</h2>
<h3 id="three-layer-architecture">Three-Layer Architecture</h3>
<pre><code>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  LAYER 1: Entity Business Logic (YAML)                      â”‚
â”‚  entities/tenant/machine.yaml                                â”‚
â”‚  - Declares: &quot;what&quot; operations exist                         â”‚
â”‚  - References: stdlib pattern library                        â”‚
â”‚  - Configuration: pattern-specific parameters                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  LAYER 2: Pattern Library (YAML + Templates)                â”‚
â”‚  stdlib/patterns/{category}/{pattern}.yaml                   â”‚
â”‚  - Defines: reusable pattern abstractions                    â”‚
â”‚  - Parameters: configurable inputs                           â”‚
â”‚  - Template: SQL generation logic                            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  LAYER 3: Code Generator (Python/Jinja2)                    â”‚
â”‚  Team C: Parser + Generator                                  â”‚
â”‚  - Reads: Entity YAML + Pattern definitions                  â”‚
â”‚  - Validates: Pattern usage and parameters                   â”‚
â”‚  - Generates: Complete PL/pgSQL implementations              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â–¼
                    PostgreSQL Functions
</code></pre>
<hr />
<h2 id="repository-structure">ğŸ“ Repository Structure</h2>
<pre><code>printoptim_specql/
â”œâ”€â”€ entities/
â”‚   â”œâ”€â”€ tenant/
â”‚   â”‚   â”œâ”€â”€ machine.yaml              # Uses patterns
â”‚   â”‚   â”œâ”€â”€ contract.yaml             # Uses patterns
â”‚   â”‚   â””â”€â”€ allocation.yaml           # Uses patterns
â”‚   â”œâ”€â”€ catalog/
â”‚   â””â”€â”€ common/
â”‚
â”œâ”€â”€ stdlib/
â”‚   â”œâ”€â”€ entities/                     # Reference entities (existing)
â”‚   â”‚   â”œâ”€â”€ common/
â”‚   â”‚   â”œâ”€â”€ tenant/
â”‚   â”‚   â””â”€â”€ catalog/
â”‚   â”‚
â”‚   â””â”€â”€ patterns/                     # NEW: Business logic library
â”‚       â”œâ”€â”€ README.md                 # Pattern library documentation
â”‚       â”œâ”€â”€ pattern_catalog.yaml      # Index of all patterns
â”‚       â”‚
â”‚       â”œâ”€â”€ core/                     # Core CRUD enhancements
â”‚       â”‚   â”œâ”€â”€ partial_update.yaml
â”‚       â”‚   â”œâ”€â”€ duplicate_check.yaml
â”‚       â”‚   â”œâ”€â”€ identifier_recalc.yaml
â”‚       â”‚   â””â”€â”€ projection_refresh.yaml
â”‚       â”‚
â”‚       â”œâ”€â”€ state_machine/            # State transition patterns
â”‚       â”‚   â”œâ”€â”€ simple_transition.yaml
â”‚       â”‚   â”œâ”€â”€ guarded_transition.yaml
â”‚       â”‚   â”œâ”€â”€ multi_step_workflow.yaml
â”‚       â”‚   â””â”€â”€ state_machine_config.yaml
â”‚       â”‚
â”‚       â”œâ”€â”€ multi_entity/             # Cross-entity operations
â”‚       â”‚   â”œâ”€â”€ coordinated_update.yaml
â”‚       â”‚   â”œâ”€â”€ parent_child_cascade.yaml
â”‚       â”‚   â”œâ”€â”€ get_or_create.yaml
â”‚       â”‚   â””â”€â”€ transactional_group.yaml
â”‚       â”‚
â”‚       â”œâ”€â”€ validation/               # Validation patterns
â”‚       â”‚   â”œâ”€â”€ dependency_check.yaml
â”‚       â”‚   â”œâ”€â”€ business_rule.yaml
â”‚       â”‚   â”œâ”€â”€ constraint_validation.yaml
â”‚       â”‚   â””â”€â”€ temporal_validation.yaml
â”‚       â”‚
â”‚       â”œâ”€â”€ batch/                    # Batch operation patterns
â”‚       â”‚   â”œâ”€â”€ bulk_operation.yaml
â”‚       â”‚   â”œâ”€â”€ batch_import.yaml
â”‚       â”‚   â”œâ”€â”€ error_handling.yaml
â”‚       â”‚   â””â”€â”€ progress_tracking.yaml
â”‚       â”‚
â”‚       â”œâ”€â”€ conditional/              # Conditional logic patterns
â”‚       â”‚   â”œâ”€â”€ if_then_else.yaml
â”‚       â”‚   â”œâ”€â”€ switch_case.yaml
â”‚       â”‚   â””â”€â”€ guard_clause.yaml
â”‚       â”‚
â”‚       â”œâ”€â”€ temporal/                 # Time-based patterns
â”‚       â”‚   â”œâ”€â”€ effective_dating.yaml
â”‚       â”‚   â”œâ”€â”€ expiration_check.yaml
â”‚       â”‚   â””â”€â”€ version_control.yaml
â”‚       â”‚
â”‚       â””â”€â”€ common/                   # Common utilities
â”‚           â”œâ”€â”€ event_logging.yaml
â”‚           â”œâ”€â”€ notification.yaml
â”‚           â”œâ”€â”€ audit_trail.yaml
â”‚           â””â”€â”€ soft_delete.yaml
â”‚
â”œâ”€â”€ templates/                        # SQL generation templates
â”‚   â””â”€â”€ patterns/
â”‚       â”œâ”€â”€ state_machine.sql.j2
â”‚       â”œâ”€â”€ multi_entity.sql.j2
â”‚       â”œâ”€â”€ validation.sql.j2
â”‚       â””â”€â”€ ...
â”‚
â”œâ”€â”€ tests/
â”‚   â”œâ”€â”€ unit/
â”‚   â”‚   â””â”€â”€ patterns/                 # Pattern unit tests
â”‚   â”‚       â”œâ”€â”€ test_state_machine.py
â”‚   â”‚       â”œâ”€â”€ test_multi_entity.py
â”‚   â”‚       â””â”€â”€ ...
â”‚   â””â”€â”€ integration/
â”‚       â””â”€â”€ patterns/                 # Pattern integration tests
â”‚
â””â”€â”€ docs/
    â”œâ”€â”€ patterns/                     # Pattern documentation
    â”‚   â”œâ”€â”€ pattern_guide.md
    â”‚   â”œâ”€â”€ state_machine_guide.md
    â”‚   â”œâ”€â”€ multi_entity_guide.md
    â”‚   â””â”€â”€ examples/
    â””â”€â”€ BUSINESS_LOGIC_LIBRARY_PLAN.md  # This document
</code></pre>
<hr />
<h2 id="pattern-library-design">ğŸ¨ Pattern Library Design</h2>
<h3 id="pattern-definition-schema">Pattern Definition Schema</h3>
<p>Each pattern is defined in YAML with this structure:</p>
<pre><code class="language-yaml"># stdlib/patterns/state_machine/simple_transition.yaml
pattern:
  name: simple_transition
  category: state_machine
  version: 1.0.0
  description: |
    Transition an entity from one state to another with validations
    and side effects. Supports pre-conditions, post-conditions, and
    cascading updates to related entities.

  # Pattern parameters (configurable by users)
  parameters:
    - name: from_states
      type: array&lt;enum_value&gt;
      required: true
      description: &quot;Valid source states for this transition&quot;

    - name: to_state
      type: enum_value
      required: true
      description: &quot;Target state after transition&quot;

    - name: validations
      type: array&lt;validation_rule&gt;
      required: false
      description: &quot;Pre-conditions that must pass before transition&quot;

    - name: side_effects
      type: array&lt;side_effect&gt;
      required: false
      description: &quot;Updates to perform on success&quot;

    - name: require_all_validations
      type: boolean
      default: true
      description: &quot;If false, any validation passing allows transition&quot;

    - name: input_fields
      type: map&lt;field_name, field_spec&gt;
      required: false
      description: &quot;Additional fields required for this transition&quot;

  # Validation rule schema
  validation_rule:
    - name: dependency_check
      parameters:
        entity: string              # Related entity to check
        field: string               # FK field linking to current entity
        condition: sql_expression   # SQL WHERE clause
        error_code: string          # NOOP error code
        error_message: string       # User-facing error message

    - name: state_guard
      parameters:
        expression: sql_expression  # Boolean SQL expression
        error_code: string
        error_message: string

    - name: permission_check
      parameters:
        required_role: string       # Role required to perform transition
        error_code: string
        error_message: string

  # Side effect schema
  side_effect:
    - name: update_field
      parameters:
        field: string               # Field to update
        value: expression           # New value (supports $variables)

    - name: update_related
      parameters:
        entity: string              # Related entity
        relationship: string        # FK field name
        updates: map&lt;field, value&gt;  # Fields to update
        condition: sql_expression   # Optional WHERE clause

    - name: insert_event
      parameters:
        entity: string              # Event entity
        event_data: map&lt;field, value&gt;

    - name: refresh_projection
      parameters:
        projection_name: string
        scope: enum[entity, related, all]

  # SQL generation template reference
  template: patterns/state_machine.sql.j2

  # Test cases for this pattern
  tests:
    - name: valid_transition
      input: {from_state: &quot;active&quot;, to_state: &quot;decommissioned&quot;}
      expected: success

    - name: invalid_source_state
      input: {from_state: &quot;archived&quot;, to_state: &quot;decommissioned&quot;}
      expected: noop:invalid_state_transition

    - name: validation_failure
      input: {from_state: &quot;active&quot;, to_state: &quot;decommissioned&quot;}
      setup: create_active_allocation
      expected: noop:has_active_allocations

  # Examples of usage
  examples:
    - entity: Machine
      action: decommission
      yaml: |
        actions:
          - name: decommission_machine
            pattern: stdlib/patterns/state_machine/simple_transition
            from_states: [active, maintenance]
            to_state: decommissioned
            validations:
              - type: dependency_check
                entity: Allocation
                field: machine
                condition: &quot;status = 'active'&quot;
                error_code: &quot;has_active_allocations&quot;
                error_message: &quot;Cannot decommission machine with active allocations&quot;
            side_effects:
              - type: update_field
                field: decommission_date
                value: now()
              - type: update_related
                entity: MachineItem
                relationship: machine
                updates:
                  status: archived
              - type: insert_event
                entity: MachineEvent
                event_data:
                  event_type: decommissioned
                  event_data: $input_payload
            input_fields:
              decommission_date:
                type: date
                required: true
              decommission_reason:
                type: text
                required: true

  # Dependencies on other patterns
  dependencies:
    - stdlib/patterns/core/projection_refresh
    - stdlib/patterns/common/event_logging
</code></pre>
<hr />
<h2 id="phase-1-core-crud-enhancements-weeks-1-4">ğŸ¯ Phase 1: Core CRUD Enhancements (Weeks 1-4)</h2>
<h3 id="objective">Objective</h3>
<p>Fix the 4 critical gaps in SpecQL's CRUD implementation to match reference SQL behavior.</p>
<h3 id="patterns-to-implement">Patterns to Implement</h3>
<h4 id="11-partial-update-pattern">1.1 Partial Update Pattern</h4>
<p><strong>File</strong>: <code>stdlib/patterns/core/partial_update.yaml</code></p>
<pre><code class="language-yaml">pattern:
  name: partial_update
  category: core
  description: &quot;Update only fields present in input payload using CASE expressions&quot;

  parameters:
    - name: fields
      type: array&lt;field_name&gt;
      description: &quot;Fields that support partial updates&quot;
      default: all_entity_fields

    - name: track_changes
      type: boolean
      default: true
      description: &quot;Track which fields were updated in mutation_result&quot;

    - name: compare_before_after
      type: boolean
      default: true
      description: &quot;Return NOOP if no actual changes detected&quot;

    - name: immutable_fields
      type: array&lt;field_name&gt;
      default: []
      description: &quot;Fields that cannot be updated after creation&quot;
</code></pre>
<p><strong>Generated SQL</strong> (from template):</p>
<pre><code class="language-sql">-- For each updateable field, generate CASE expression
UPDATE {schema}.tb_{entity}
SET
    {%- for field in fields %}
    {{ field.name }} = CASE
        WHEN input_payload ? '{{ field.name }}' THEN
            {%- if field.type == 'ref' %}
            {{ field.name }}_pk_resolved  -- FK resolution happened earlier
            {%- else %}
            input_data.{{ field.name }}
            {%- endif %}
        ELSE {{ field.name }}
    END,
    {%- endfor %}
    updated_at = now(),
    updated_by = auth_user_id
WHERE id = v_{{ entity }}_id
  AND tenant_id = auth_tenant_id;

-- Track updated fields
v_updated_fields := ARRAY(
    SELECT key FROM jsonb_object_keys(input_payload) AS key
    WHERE key = ANY(ARRAY[{{ fields | map(attribute='name') | join(', ') }}])
);

-- Compare before/after if requested
{% if compare_before_after %}
IF v_payload_before = v_payload_after THEN
    RETURN app.log_and_return_mutation(
        ..., 'NOOP', 'noop:no_changes',
        'No changes detected', ...
    );
END IF;
{% endif %}
</code></pre>
<p><strong>Usage in Entity</strong>:</p>
<pre><code class="language-yaml"># entities/tenant/contract.yaml
entity: Contract
schema: tenant

actions:
  - name: update_contract
    pattern: stdlib/patterns/core/partial_update
    compare_before_after: true
    immutable_fields: [customer_org, created_at]
</code></pre>
<hr />
<h4 id="12-duplicate-detection-pattern">1.2 Duplicate Detection Pattern</h4>
<p><strong>File</strong>: <code>stdlib/patterns/core/duplicate_check.yaml</code></p>
<pre><code class="language-yaml">pattern:
  name: duplicate_check
  category: core
  description: &quot;Check business uniqueness constraints before INSERT&quot;

  parameters:
    - name: constraints
      type: array&lt;constraint_definition&gt;
      required: true
      description: &quot;Business uniqueness constraints to check&quot;

    - name: return_conflict_object
      type: boolean
      default: true
      description: &quot;Include existing entity in NOOP response&quot;

    - name: upsert_on_conflict
      type: boolean
      default: false
      description: &quot;Update instead of NOOP if duplicate found&quot;

  constraint_definition:
    fields: array&lt;field_name&gt;      # Fields that form unique key
    scope: enum[global, tenant]    # Uniqueness scope
    error_code: string             # NOOP error code
    error_message: string          # User-facing message
    conflict_resolution: enum[noop, update, error]
</code></pre>
<p><strong>Generated SQL</strong>:</p>
<pre><code class="language-sql">-- Check for duplicate based on business key
SELECT id INTO v_existing_id
FROM {{ schema }}.tb_{{ entity }}
WHERE {% for field in constraint.fields %}
    {{ field }} = input_data.{{ field }}
    {%- if not loop.last %} AND {% endif %}
{%- endfor %}
{%- if constraint.scope == 'tenant' %}
  AND tenant_id = auth_tenant_id
{%- endif %}
  AND deleted_at IS NULL;

IF v_existing_id IS NOT NULL THEN
    {%- if return_conflict_object %}
    SELECT row_to_json(t.*) INTO v_conflict_object
    FROM {{ schema }}.tb_{{ entity }} t
    WHERE t.id = v_existing_id;
    {%- endif %}

    {%- if upsert_on_conflict %}
    -- Update existing entity instead of NOOP
    v_{{ entity }}_id := v_existing_id;
    PERFORM {{ schema }}.update_{{ entity }}(...);
    {%- else %}
    -- Return NOOP with conflict details
    RETURN app.log_and_return_mutation(
        auth_tenant_id,
        auth_user_id,
        '{{ entity }}',
        v_existing_id,
        'NOOP',
        '{{ constraint.error_code }}',
        ARRAY[]::TEXT[],
        '{{ constraint.error_message }}',
        v_conflict_object,
        v_conflict_object,
        jsonb_build_object(
            'conflict_fields', ARRAY[{{ constraint.fields | join(', ') }}],
            'conflict_values', jsonb_build_object(
                {%- for field in constraint.fields %}
                '{{ field }}', input_data.{{ field }}
                {%- if not loop.last %}, {% endif %}
                {%- endfor %}
            )
        )
    );
    {%- endif %}
END IF;
</code></pre>
<p><strong>Usage in Entity</strong>:</p>
<pre><code class="language-yaml"># entities/tenant/contract.yaml
entity: Contract
schema: tenant

fields:
  customer_org: ref(Organization)
  provider_org: ref(Organization)
  customer_contract_id: text

actions:
  - name: create_contract
    pattern: stdlib/patterns/core/duplicate_check
    constraints:
      - fields: [customer_org, provider_org, customer_contract_id]
        scope: tenant
        error_code: &quot;noop:contract_already_exists&quot;
        error_message: &quot;Contract already exists for this customer/provider/contract_id&quot;
        conflict_resolution: noop
        return_conflict_object: true
</code></pre>
<hr />
<h4 id="13-identifier-recalculation-pattern">1.3 Identifier Recalculation Pattern</h4>
<p><strong>File</strong>: <code>stdlib/patterns/core/identifier_recalc.yaml</code></p>
<pre><code class="language-yaml">pattern:
  name: identifier_recalc
  category: core
  description: &quot;Auto-calculate business identifier after INSERT/UPDATE&quot;

  parameters:
    - name: pattern
      type: string
      required: true
      description: &quot;Identifier format pattern&quot;
      examples:
        - &quot;CONTRACT-{year}-{seq:03d}&quot;
        - &quot;MACHINE-{customer_code}-{seq:05d}&quot;
        - &quot;{manufacturer_code}-{model_code}-{serial_number}&quot;

    - name: sequence
      type: sequence_config
      required: false
      description: &quot;Sequence number configuration&quot;

    - name: recalculate_on
      type: array&lt;enum[create, update]&gt;
      default: [create]
      description: &quot;When to trigger recalculation&quot;

    - name: depends_on
      type: array&lt;field_name&gt;
      description: &quot;Fields that trigger recalc when updated&quot;

  sequence_config:
    scope: array&lt;field_name&gt;        # Reset per these fields (e.g., per customer)
    group_by: array&lt;field_name&gt;     # Additional grouping (e.g., per year)
    start_value: integer            # Starting sequence number
    increment: integer              # Increment amount
</code></pre>
<p><strong>Generated SQL</strong>:</p>
<pre><code class="language-sql">-- Generate recalculation function
CREATE OR REPLACE FUNCTION {{ schema }}.recalcid_{{ entity }}(
    entity_id UUID,
    tenant_id UUID,
    user_id UUID
) RETURNS VOID
LANGUAGE plpgsql AS $$
DECLARE
    v_identifier TEXT;
    v_parts JSONB := '{}'::JSONB;
    {%- for var in pattern.variables %}
    v_{{ var.name }} {{ var.type }};
    {%- endfor %}
BEGIN
    -- Load entity data
    SELECT
        {%- for field in pattern.depends_on %}
        {{ field }},
        {%- endfor %}
        id
    INTO
        {%- for field in pattern.depends_on %}
        v_{{ field }},
        {%- endfor %}
        entity_id
    FROM {{ schema }}.tb_{{ entity }}
    WHERE id = entity_id
      AND tenant_id = tenant_id;

    {%- if pattern.has_sequence %}
    -- Calculate sequence number
    SELECT COALESCE(MAX(sequence_number), {{ sequence.start_value }}) + {{ sequence.increment }}
    INTO v_sequence_number
    FROM {{ schema }}.tb_{{ entity }}
    WHERE tenant_id = tenant_id
    {%- for field in sequence.scope %}
      AND {{ field }} = v_{{ field }}
    {%- endfor %}
    {%- for field in sequence.group_by %}
      AND {{ field }} = v_{{ field }}
    {%- endfor %};

    -- Store sequence number
    UPDATE {{ schema }}.tb_{{ entity }}
    SET sequence_number = v_sequence_number
    WHERE id = entity_id;
    {%- endif %}

    -- Build identifier from pattern
    v_identifier := '{{ pattern.template }}';
    {%- for var in pattern.variables %}
    v_identifier := replace(v_identifier, '{{ var.placeholder }}', {{ var.sql_expression }});
    {%- endfor %}

    -- Update identifier
    UPDATE {{ schema }}.tb_{{ entity }}
    SET identifier = v_identifier, updated_at = now()
    WHERE id = entity_id
      AND tenant_id = tenant_id;
END;
$$;

-- Call recalculation in create/update actions
{%- if 'create' in recalculate_on %}
-- In create action
PERFORM {{ schema }}.recalcid_{{ entity }}(
    v_{{ entity }}_id,
    auth_tenant_id,
    auth_user_id
);
{%- endif %}

{%- if 'update' in recalculate_on %}
-- In update action
IF {% for field in depends_on %}input_payload ? '{{ field }}'{% if not loop.last %} OR {% endif %}{% endfor %} THEN
    PERFORM {{ schema }}.recalcid_{{ entity }}(
        v_{{ entity }}_id,
        auth_tenant_id,
        auth_user_id
    );
END IF;
{%- endif %}
</code></pre>
<p><strong>Usage in Entity</strong>:</p>
<pre><code class="language-yaml"># entities/tenant/contract.yaml
entity: Contract
schema: tenant

fields:
  signature_date: date
  customer_org: ref(Organization)
  provider_org: ref(Organization)

identifier:
  pattern: &quot;CONTRACT-{customer_org.code}-{signature_date:YYYY}-{seq:03d}&quot;
  sequence:
    scope: [customer_org]
    group_by: [signature_date:YYYY]
    start_value: 1
    increment: 1
  recalculate_on: [create, update]
  depends_on: [customer_org, signature_date]
</code></pre>
<hr />
<h4 id="14-projection-refresh-pattern">1.4 Projection Refresh Pattern</h4>
<p><strong>File</strong>: <code>stdlib/patterns/core/projection_refresh.yaml</code></p>
<pre><code class="language-yaml">pattern:
  name: projection_refresh
  category: core
  description: &quot;Refresh GraphQL materialized views after mutations&quot;

  parameters:
    - name: projections
      type: array&lt;projection_config&gt;
      required: true
      description: &quot;Projections to refresh&quot;

    - name: refresh_strategy
      type: enum[immediate, deferred, async]
      default: immediate
      description: &quot;When to refresh the projection&quot;

    - name: scope
      type: enum[entity, related, all]
      default: entity
      description: &quot;How much to refresh&quot;

  projection_config:
    name: string                    # Projection identifier
    view_name: string               # Materialized view name
    entity_scope: array&lt;entity&gt;     # Entities included in view
    refresh_on: array&lt;action&gt;       # Actions that trigger refresh
    includes: map&lt;field, fields&gt;    # Related entities to JOIN
</code></pre>
<p><strong>Generated SQL</strong>:</p>
<pre><code class="language-sql">-- Generate refresh function
CREATE OR REPLACE FUNCTION {{ schema }}.refresh_{{ entity }}_projection(
    entity_id UUID,
    tenant_id UUID
) RETURNS VOID
LANGUAGE plpgsql AS $$
BEGIN
    {%- if refresh_strategy == 'immediate' %}
    -- Delete stale row
    DELETE FROM {{ projection.view_name }}
    WHERE id = entity_id
      AND tenant_id = tenant_id;

    -- Rebuild projection row
    INSERT INTO {{ projection.view_name }}
    SELECT
        e.id,
        e.tenant_id,
        jsonb_build_object(
            'id', e.id,
            'identifier', e.identifier,
            {%- for field in entity.fields %}
            '{{ field.name }}', e.{{ field.name }},
            {%- endfor %}
            {%- for rel_name, rel_config in projection.includes %}
            '{{ rel_name }}', (
                SELECT jsonb_build_object(
                    {%- for field in rel_config.fields %}
                    '{{ field }}', r.{{ field }}
                    {%- if not loop.last %}, {% endif %}
                    {%- endfor %}
                )
                FROM {{ rel_config.schema }}.tb_{{ rel_config.entity }} r
                WHERE r.id = e.{{ rel_name }}_id
            ),
            {%- endfor %}
            'meta', jsonb_build_object(
                'created_at', e.created_at,
                'updated_at', e.updated_at
            )
        ) AS data
    FROM {{ schema }}.tb_{{ entity }} e
    WHERE e.id = entity_id
      AND e.tenant_id = tenant_id;
    {%- elif refresh_strategy == 'async' %}
    -- Queue for async refresh
    INSERT INTO core.projection_refresh_queue (
        projection_name, entity_id, tenant_id, priority
    ) VALUES (
        '{{ projection.name }}', entity_id, tenant_id, 10
    );
    {%- endif %}
END;
$$;

-- Call in mutation actions
{%- for action in projection.refresh_on %}
-- In {{ action }} action
PERFORM {{ schema }}.refresh_{{ entity }}_projection(
    v_{{ entity }}_id,
    auth_tenant_id
);
{%- endfor %}

-- Return from projection in mutation_result
SELECT data INTO v_payload_after
FROM {{ projection.view_name }}
WHERE id = v_{{ entity }}_id
  AND tenant_id = auth_tenant_id;
</code></pre>
<p><strong>Usage in Entity</strong>:</p>
<pre><code class="language-yaml"># entities/tenant/contract.yaml
entity: Contract
schema: tenant

fields:
  customer_org: ref(Organization)
  provider_org: ref(Organization)
  currency: ref(Currency)

projections:
  - name: graphql_view
    materialize: true
    refresh_on: [create, update, delete]
    refresh_strategy: immediate
    includes:
      customer_org:
        fields: [id, name, code]
        schema: management
      provider_org:
        fields: [id, name, code]
        schema: management
      currency:
        fields: [iso_code, symbol, name]
        schema: catalog
      contract_items:
        fields: [id, description, quantity, unit_price]
        schema: tenant
        type: many

actions:
  - name: create_contract
    refresh_projection: graphql_view
  - name: update_contract
    refresh_projection: graphql_view
</code></pre>
<hr />
<h3 id="phase-1-deliverables">Phase 1 Deliverables</h3>
<ul>
<li>[ ] <code>stdlib/patterns/core/partial_update.yaml</code></li>
<li>[ ] <code>stdlib/patterns/core/duplicate_check.yaml</code></li>
<li>[ ] <code>stdlib/patterns/core/identifier_recalc.yaml</code></li>
<li>[ ] <code>stdlib/patterns/core/projection_refresh.yaml</code></li>
<li>[ ] SQL generation templates for each pattern</li>
<li>[ ] Unit tests for each pattern (10+ test cases each)</li>
<li>[ ] Integration tests with real entities (Contract, Machine, Product)</li>
<li>[ ] Documentation and usage examples</li>
<li>[ ] Migration guide from manual implementations</li>
</ul>
<p><strong>Timeline</strong>: 4 weeks
<strong>Team</strong>: Team C (Parser + Generator)
<strong>Dependencies</strong>: None (foundational patterns)</p>
<hr />
<h2 id="phase-2-state-machine-patterns-weeks-5-7">ğŸ¯ Phase 2: State Machine Patterns (Weeks 5-7)</h2>
<h3 id="objective_1">Objective</h3>
<p>Enable declarative state machine transitions with guards, validations, and side effects.</p>
<h3 id="patterns-to-implement_1">Patterns to Implement</h3>
<h4 id="21-simple-state-transition-pattern">2.1 Simple State Transition Pattern</h4>
<p><strong>File</strong>: <code>stdlib/patterns/state_machine/simple_transition.yaml</code></p>
<p>This is the full pattern definition shown in the "Pattern Definition Schema" section above.</p>
<p><strong>Real-World Examples from PrintOptim</strong>:</p>
<pre><code class="language-yaml"># entities/tenant/machine.yaml
actions:
  - name: decommission_machine
    pattern: stdlib/patterns/state_machine/simple_transition
    from_states: [active, maintenance]
    to_state: decommissioned
    validations:
      - type: dependency_check
        entity: Allocation
        field: machine
        condition: &quot;status = 'active'&quot;
        error_code: &quot;has_active_allocations&quot;
        error_message: &quot;Cannot decommission machine with active allocations&quot;
    side_effects:
      - type: update_field
        field: decommission_date
        value: now()
      - type: update_field
        field: decommission_reason
        value: $input.reason
      - type: update_related
        entity: MachineItem
        relationship: machine
        updates:
          status: archived
      - type: insert_event
        entity: MachineEvent
        event_data:
          event_type: decommissioned
          reason: $input.reason
    input_fields:
      decommission_date:
        type: date
        required: true
      decommission_reason:
        type: text
        required: true

  - name: activate_machine
    pattern: stdlib/patterns/state_machine/simple_transition
    from_states: [available, maintenance]
    to_state: active
    validations:
      - type: business_rule
        expression: &quot;EXISTS (SELECT 1 FROM tenant.tb_allocation WHERE machine_id = $entity_id)&quot;
        error_code: &quot;no_allocation&quot;
        error_message: &quot;Machine must be allocated before activation&quot;
    side_effects:
      - type: update_field
        field: activation_date
        value: now()
</code></pre>
<hr />
<h4 id="22-multi-step-workflow-pattern">2.2 Multi-Step Workflow Pattern</h4>
<p><strong>File</strong>: <code>stdlib/patterns/state_machine/multi_step_workflow.yaml</code></p>
<pre><code class="language-yaml">pattern:
  name: multi_step_workflow
  category: state_machine
  description: &quot;Orchestrate multi-step workflows with rollback on failure&quot;

  parameters:
    - name: steps
      type: array&lt;workflow_step&gt;
      required: true
      description: &quot;Sequential steps in the workflow&quot;

    - name: rollback_on_error
      type: boolean
      default: true
      description: &quot;Rollback all steps if any step fails&quot;

    - name: continue_on_warning
      type: boolean
      default: false
      description: &quot;Continue workflow despite warnings&quot;

  workflow_step:
    name: string                    # Step identifier
    action: enum[validate, update, create, delete, notify]
    entity: string                  # Target entity
    condition: sql_expression       # Skip step if condition false
    on_success: string              # Next step
    on_failure: enum[abort, continue, retry]
    params: map                     # Step-specific parameters
</code></pre>
<p><strong>Usage Example</strong>:</p>
<pre><code class="language-yaml"># entities/tenant/contract.yaml
actions:
  - name: cancel_contract
    pattern: stdlib/patterns/state_machine/multi_step_workflow
    from_states: [active]
    to_state: cancelled
    rollback_on_error: true
    steps:
      - name: check_cancellation_eligibility
        action: validate
        condition: &quot;cancellation_date &gt;= start_date + INTERVAL '30 days'&quot;
        error_code: &quot;early_cancellation_not_allowed&quot;
        on_failure: abort

      - name: suspend_active_allocations
        action: update
        entity: Allocation
        relationship: contract
        updates:
          status: suspended
        on_failure: abort

      - name: calculate_cancellation_fees
        action: create
        entity: Charge
        values:
          contract: $entity_id
          charge_type: cancellation_fee
          amount: &quot;SELECT calculate_cancellation_fee($entity_id)&quot;
        on_failure: continue

      - name: update_contract_status
        action: update
        entity: Contract
        updates:
          status: cancelled
          cancellation_date: now()
        on_failure: abort

      - name: notify_provider
        action: notify
        recipients: [provider_org.contact_email]
        template: contract_cancelled
        on_failure: continue
</code></pre>
<hr />
<h4 id="23-guarded-transition-pattern">2.3 Guarded Transition Pattern</h4>
<p><strong>File</strong>: <code>stdlib/patterns/state_machine/guarded_transition.yaml</code></p>
<pre><code class="language-yaml">pattern:
  name: guarded_transition
  category: state_machine
  description: &quot;State transition with complex guard conditions&quot;

  parameters:
    - name: guards
      type: array&lt;guard_condition&gt;
      required: true
      description: &quot;Guard conditions that must pass&quot;

    - name: guard_logic
      type: enum[all, any]
      default: all
      description: &quot;Require all guards or any guard to pass&quot;

  guard_condition:
    type: enum[field_value, dependency_count, business_rule, permission]
    condition: sql_expression
    error_code: string
    error_message: string
</code></pre>
<p><strong>Usage Example</strong>:</p>
<pre><code class="language-yaml"># entities/tenant/machine.yaml
actions:
  - name: return_to_stock
    pattern: stdlib/patterns/state_machine/guarded_transition
    from_states: [allocated, maintenance, decommissioned]
    to_state: in_stock
    guard_logic: all
    guards:
      - type: dependency_count
        condition: &quot;(SELECT COUNT(*) FROM tenant.tb_allocation WHERE machine_id = $entity_id AND status = 'active') = 0&quot;
        error_code: &quot;has_active_allocations&quot;
        error_message: &quot;Cannot return machine to stock with active allocations&quot;

      - type: business_rule
        condition: &quot;maintenance_status = 'complete' OR status != 'maintenance'&quot;
        error_code: &quot;maintenance_incomplete&quot;
        error_message: &quot;Cannot return machine to stock until maintenance is complete&quot;

      - type: field_value
        condition: &quot;deleted_at IS NULL&quot;
        error_code: &quot;machine_deleted&quot;
        error_message: &quot;Cannot return deleted machine to stock&quot;
</code></pre>
<hr />
<h3 id="phase-2-deliverables">Phase 2 Deliverables</h3>
<ul>
<li>[ ] <code>stdlib/patterns/state_machine/simple_transition.yaml</code></li>
<li>[ ] <code>stdlib/patterns/state_machine/multi_step_workflow.yaml</code></li>
<li>[ ] <code>stdlib/patterns/state_machine/guarded_transition.yaml</code></li>
<li>[ ] <code>stdlib/patterns/state_machine/state_machine_config.yaml</code> (helper)</li>
<li>[ ] SQL generation templates</li>
<li>[ ] Comprehensive test suite (30+ test cases)</li>
<li>[ ] Real-world examples (Machine, Contract, Allocation)</li>
<li>[ ] State machine visualization tools</li>
<li>[ ] Documentation</li>
</ul>
<p><strong>Timeline</strong>: 3 weeks
<strong>Dependencies</strong>: Phase 1 (uses projection_refresh, event_logging)</p>
<hr />
<h2 id="phase-3-multi-entity-patterns-weeks-8-10">ğŸ¯ Phase 3: Multi-Entity Patterns (Weeks 8-10)</h2>
<h3 id="objective_2">Objective</h3>
<p>Enable coordinated operations across multiple related entities with transactional integrity.</p>
<h3 id="patterns-to-implement_2">Patterns to Implement</h3>
<h4 id="31-coordinated-update-pattern">3.1 Coordinated Update Pattern</h4>
<p><strong>File</strong>: <code>stdlib/patterns/multi_entity/coordinated_update.yaml</code></p>
<pre><code class="language-yaml">pattern:
  name: coordinated_update
  category: multi_entity
  description: &quot;Update multiple entities in coordinated transaction&quot;

  parameters:
    - name: operations
      type: array&lt;entity_operation&gt;
      required: true
      description: &quot;Operations to perform across entities&quot;

    - name: transaction_isolation
      type: enum[read_committed, repeatable_read, serializable]
      default: read_committed
      description: &quot;Transaction isolation level&quot;

    - name: operation_order
      type: enum[sequential, parallel]
      default: sequential
      description: &quot;Execute operations sequentially or in parallel&quot;

  entity_operation:
    action: enum[create, update, delete, upsert]
    entity: string
    condition: sql_expression       # Only execute if condition true
    values: map&lt;field, value&gt;       # For create/update
    where: map&lt;field, value&gt;        # For update/delete
    store_result_as: string         # Variable name for result
    on_error: enum[abort, continue, retry]
</code></pre>
<p><strong>Usage Example</strong>:</p>
<pre><code class="language-yaml"># entities/tenant/allocation.yaml
actions:
  - name: allocate_to_stock
    pattern: stdlib/patterns/multi_entity/coordinated_update
    description: &quot;Allocate machine to stock location&quot;
    transaction_isolation: repeatable_read
    operation_order: sequential

    operations:
      # Step 1: Validate machine availability
      - action: validate
        entity: Machine
        where:
          id: $input.machine_id
          status: available
        on_error: abort
        error_code: &quot;machine_not_available&quot;

      # Step 2: Get or create stock location
      - action: upsert
        entity: Location
        where:
          code: STOCK
          customer_org: $auth_tenant_id
        values:
          code: STOCK
          name: Stock
          customer_org: $auth_tenant_id
        store_result_as: stock_location_id
        on_error: abort

      # Step 3: Create allocation
      - action: create
        entity: Allocation
        values:
          customer_org: $auth_tenant_id
          machine: $input.machine_id
          location: $stock_location_id
          allocation_type: stock
          status: active
          allocated_at: now()
        store_result_as: allocation_id
        on_error: abort

      # Step 4: Update machine status
      - action: update
        entity: Machine
        where:
          id: $input.machine_id
        values:
          status: in_stock
          current_location: $stock_location_id
        on_error: abort

      # Step 5: Log event
      - action: create
        entity: AllocationEvent
        values:
          allocation: $allocation_id
          event_type: allocated_to_stock
          event_data: $input_payload
        on_error: continue  # Don't abort if logging fails

    return_entity: Allocation
    return_id: $allocation_id
</code></pre>
<hr />
<h4 id="32-parent-child-cascade-pattern">3.2 Parent-Child Cascade Pattern</h4>
<p><strong>File</strong>: <code>stdlib/patterns/multi_entity/parent_child_cascade.yaml</code></p>
<pre><code class="language-yaml">pattern:
  name: parent_child_cascade
  category: multi_entity
  description: &quot;Cascade operations from parent to child entities&quot;

  parameters:
    - name: parent_action
      type: enum[create, update, delete]
      required: true

    - name: child_operations
      type: array&lt;cascade_operation&gt;
      required: true

    - name: cascade_strategy
      type: enum[immediate, deferred]
      default: immediate

  cascade_operation:
    entity: string                  # Child entity
    relationship: string            # FK field name
    action: enum[create, update, delete, nothing]
    condition: sql_expression       # Only cascade if condition true
    values: map&lt;field, value&gt;       # For create/update
</code></pre>
<p><strong>Usage Example</strong>:</p>
<pre><code class="language-yaml"># entities/tenant/contract.yaml
actions:
  - name: create_contract_with_items
    pattern: stdlib/patterns/multi_entity/parent_child_cascade
    parent_action: create

    child_operations:
      # Create financing conditions
      - entity: ContractFinancingCondition
        relationship: contract
        action: create
        condition: &quot;$input.financing_condition_ids IS NOT NULL&quot;
        values:
          contract: $parent_id
          financing_condition: $each.financing_condition_id
        iterate_over: $input.financing_condition_ids

      # Create contract items
      - entity: ContractItem
        relationship: contract
        action: create
        condition: &quot;$input.contract_items IS NOT NULL&quot;
        values:
          contract: $parent_id
          item_identifier: $each.item_identifier
          description: $each.description
          product: $each.product_id
          quantity: $each.quantity
          unit_price: $each.unit_price
        iterate_over: $input.contract_items

    input_fields:
      # Parent contract fields
      customer_contract_id: {type: text, required: true}
      signature_date: {type: date, required: true}
      # Child arrays
      financing_condition_ids: {type: array&lt;uuid&gt;}
      contract_items:
        type: array
        items:
          item_identifier: text
          description: text
          product_id: uuid
          quantity: decimal
          unit_price: decimal
</code></pre>
<hr />
<h4 id="33-get-or-create-pattern">3.3 Get-or-Create Pattern</h4>
<p><strong>File</strong>: <code>stdlib/patterns/multi_entity/get_or_create.yaml</code></p>
<pre><code class="language-yaml">pattern:
  name: get_or_create
  category: multi_entity
  description: &quot;Get existing entity or create if not found&quot;

  parameters:
    - name: lookup_fields
      type: array&lt;field_name&gt;
      required: true
      description: &quot;Fields to use for lookup&quot;

    - name: create_if_missing
      type: map&lt;field, value&gt;
      required: true
      description: &quot;Values for new entity if not found&quot;

    - name: update_if_found
      type: map&lt;field, value&gt;
      required: false
      description: &quot;Update existing entity with these values&quot;

    - name: return_field
      type: field_name
      default: id
      description: &quot;Field to return (usually id or pk)&quot;
</code></pre>
<p><strong>Usage Example</strong>:</p>
<pre><code class="language-yaml"># Helper pattern used in other actions
- step: get_or_create_stock_location
  pattern: stdlib/patterns/multi_entity/get_or_create
  entity: Location
  lookup_fields:
    code: STOCK
    customer_org: $auth_tenant_id
  create_if_missing:
    code: STOCK
    name: Stock
    location_type: warehouse
    customer_org: $auth_tenant_id
  store_result_as: stock_location_id
</code></pre>
<hr />
<h3 id="phase-3-deliverables">Phase 3 Deliverables</h3>
<ul>
<li>[ ] <code>stdlib/patterns/multi_entity/coordinated_update.yaml</code></li>
<li>[ ] <code>stdlib/patterns/multi_entity/parent_child_cascade.yaml</code></li>
<li>[ ] <code>stdlib/patterns/multi_entity/get_or_create.yaml</code></li>
<li>[ ] <code>stdlib/patterns/multi_entity/transactional_group.yaml</code></li>
<li>[ ] SQL generation templates with transaction handling</li>
<li>[ ] Comprehensive test suite (40+ test cases)</li>
<li>[ ] Real-world examples (Allocation, Contract+Items, Order+Lines)</li>
<li>[ ] Performance benchmarks</li>
<li>[ ] Documentation</li>
</ul>
<p><strong>Timeline</strong>: 3 weeks
<strong>Dependencies</strong>: Phase 1 and Phase 2</p>
<hr />
<h2 id="phase-4-validation-batch-patterns-weeks-11-13">ğŸ¯ Phase 4: Validation &amp; Batch Patterns (Weeks 11-13)</h2>
<h3 id="objective_3">Objective</h3>
<p>Enable complex validation rules and efficient batch operations.</p>
<h3 id="patterns-to-implement_3">Patterns to Implement</h3>
<h4 id="41-validation-chain-pattern">4.1 Validation Chain Pattern</h4>
<p><strong>File</strong>: <code>stdlib/patterns/validation/validation_chain.yaml</code></p>
<pre><code class="language-yaml">pattern:
  name: validation_chain
  category: validation
  description: &quot;Chain multiple validation rules with short-circuit logic&quot;

  parameters:
    - name: validations
      type: array&lt;validation_rule&gt;
      required: true

    - name: stop_on_first_failure
      type: boolean
      default: true

    - name: collect_all_errors
      type: boolean
      default: false

  validation_rule:
    type: enum[required, range, pattern, custom, dependency]
    field: string
    condition: sql_expression
    error_code: string
    error_message: string
    severity: enum[error, warning]
</code></pre>
<hr />
<h4 id="42-bulk-operation-pattern">4.2 Bulk Operation Pattern</h4>
<p><strong>File</strong>: <code>stdlib/patterns/batch/bulk_operation.yaml</code></p>
<pre><code class="language-yaml">pattern:
  name: bulk_operation
  category: batch
  description: &quot;Process multiple records with error handling&quot;

  parameters:
    - name: batch_input
      type: array
      required: true

    - name: operation
      type: enum[create, update, delete]
      required: true

    - name: error_handling
      type: enum[stop_on_error, continue_on_error, rollback_on_any_error]
      default: continue_on_error

    - name: batch_size
      type: integer
      default: 100

    - name: return_summary
      type: boolean
      default: true
</code></pre>
<p><strong>Usage Example</strong>:</p>
<pre><code class="language-yaml"># entities/tenant/contract_item.yaml
actions:
  - name: bulk_update_prices
    pattern: stdlib/patterns/batch/bulk_operation
    description: &quot;Update prices for multiple contract items&quot;
    operation: update
    error_handling: continue_on_error

    batch_input: $input.price_updates  # Array of {id, unit_price}

    for_each_item:
      entity: ContractItem
      where:
        id: $item.id
        customer_org: $auth_tenant_id
      update:
        unit_price: $item.unit_price

    return_summary:
      total_count: count($input.price_updates)
      success_count: count(success)
      failed_count: count(failed)
      failed_items: collect(failed, [id, error])
</code></pre>
<hr />
<h3 id="phase-4-deliverables">Phase 4 Deliverables</h3>
<ul>
<li>[ ] <code>stdlib/patterns/validation/validation_chain.yaml</code></li>
<li>[ ] <code>stdlib/patterns/validation/dependency_check.yaml</code></li>
<li>[ ] <code>stdlib/patterns/validation/business_rule.yaml</code></li>
<li>[ ] <code>stdlib/patterns/batch/bulk_operation.yaml</code></li>
<li>[ ] <code>stdlib/patterns/batch/batch_import.yaml</code></li>
<li>[ ] <code>stdlib/patterns/batch/error_handling.yaml</code></li>
<li>[ ] SQL generation templates with batching</li>
<li>[ ] Performance optimization for large batches</li>
<li>[ ] Test suite (30+ test cases)</li>
<li>[ ] Real-world examples</li>
<li>[ ] Documentation</li>
</ul>
<p><strong>Timeline</strong>: 3 weeks
<strong>Dependencies</strong>: Phase 1-3</p>
<hr />
<h2 id="phase-5-advanced-patterns-weeks-14-16">ğŸ¯ Phase 5: Advanced Patterns (Weeks 14-16)</h2>
<h3 id="objective_4">Objective</h3>
<p>Implement specialized patterns for conditional logic, temporal operations, and common utilities.</p>
<h3 id="patterns-to-implement_4">Patterns to Implement</h3>
<h4 id="51-conditional-routing-pattern">5.1 Conditional Routing Pattern</h4>
<ul>
<li>If-then-else logic</li>
<li>Switch-case routing</li>
<li>Guard clauses</li>
</ul>
<h4 id="52-temporal-logic-pattern">5.2 Temporal Logic Pattern</h4>
<ul>
<li>Effective dating</li>
<li>Expiration checking</li>
<li>Version control</li>
</ul>
<h4 id="53-common-utilities-pattern">5.3 Common Utilities Pattern</h4>
<ul>
<li>Event logging</li>
<li>Notification dispatching</li>
<li>Audit trail generation</li>
</ul>
<h3 id="phase-5-deliverables">Phase 5 Deliverables</h3>
<ul>
<li>[ ] 8-10 advanced patterns</li>
<li>[ ] SQL generation templates</li>
<li>[ ] Test suite (30+ test cases)</li>
<li>[ ] Documentation</li>
<li>[ ] Performance benchmarks</li>
</ul>
<p><strong>Timeline</strong>: 3 weeks
<strong>Dependencies</strong>: Phase 1-4</p>
<hr />
<h2 id="phase-6-migration-optimization-weeks-17-20">ğŸ¯ Phase 6: Migration &amp; Optimization (Weeks 17-20)</h2>
<h3 id="objective_5">Objective</h3>
<p>Migrate all PrintOptim reference business logic to pattern library and optimize performance.</p>
<h3 id="tasks">Tasks</h3>
<h4 id="61-entity-migration-weeks-17-18">6.1 Entity Migration (Weeks 17-18)</h4>
<p><strong>Migrate all 74 entities to use pattern library</strong>:</p>
<pre><code class="language-bash"># Entities to migrate
entities/
â”œâ”€â”€ common/ (23 entities)      # Reference data patterns
â”œâ”€â”€ tenant/ (24 entities)      # Business logic patterns
â”œâ”€â”€ catalog/ (26 entities)     # Product catalog patterns
â””â”€â”€ management/ (1 entity)     # Organization patterns
</code></pre>
<p><strong>Migration Process per Entity</strong>:
1. Analyze current manual implementation (reference SQL)
2. Map to pattern library patterns
3. Write YAML configuration using patterns
4. Generate SQL and compare with reference
5. Run tests (unit + integration)
6. Performance benchmark
7. Document migration</p>
<p><strong>Example Migration</strong>:</p>
<pre><code class="language-yaml"># Before: Manual implementation (150+ lines SQL)
# reference_sql/0_schema/03_functions/.../decommission_machine.sql

# After: Pattern-based (20 lines YAML)
# entities/tenant/machine.yaml
actions:
  - name: decommission_machine
    pattern: stdlib/patterns/state_machine/simple_transition
    from_states: [active, maintenance]
    to_state: decommissioned
    validations: [...]
    side_effects: [...]
</code></pre>
<hr />
<h4 id="62-performance-optimization-week-19">6.2 Performance Optimization (Week 19)</h4>
<p><strong>Optimization Targets</strong>:
- Query performance (target: &lt;50ms p95)
- Transaction throughput (target: 100+ TPS)
- Batch operation efficiency (target: 1000+ records/sec)
- Projection refresh speed (target: &lt;100ms)</p>
<p><strong>Optimization Techniques</strong>:
- Index optimization
- Query plan analysis
- Batch operation tuning
- Connection pooling
- Prepared statement caching</p>
<hr />
<h4 id="63-testing-documentation-week-20">6.3 Testing &amp; Documentation (Week 20)</h4>
<p><strong>Comprehensive Test Suite</strong>:
- [ ] Unit tests for each pattern (300+ tests)
- [ ] Integration tests for entity actions (500+ tests)
- [ ] Performance benchmarks (100+ scenarios)
- [ ] Regression tests vs reference SQL
- [ ] Load testing (10,000+ concurrent operations)</p>
<p><strong>Documentation</strong>:
- [ ] Pattern library guide (comprehensive)
- [ ] Entity migration guide
- [ ] Performance tuning guide
- [ ] Troubleshooting guide
- [ ] API reference (auto-generated)</p>
<hr />
<h2 id="success-metrics">ğŸ“Š Success Metrics</h2>
<h3 id="quantitative-metrics">Quantitative Metrics</h3>
<table>
<thead>
<tr>
<th>Metric</th>
<th>Target</th>
<th>Measurement</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Code Reduction</strong></td>
<td>95%</td>
<td>Lines of SQL vs YAML</td>
</tr>
<tr>
<td><strong>Pattern Coverage</strong></td>
<td>95%</td>
<td>Business logic expressible via patterns</td>
</tr>
<tr>
<td><strong>Migration Complete</strong></td>
<td>100%</td>
<td>All 74 entities migrated</td>
</tr>
<tr>
<td><strong>Test Coverage</strong></td>
<td>90%+</td>
<td>Pattern library code coverage</td>
</tr>
<tr>
<td><strong>Performance</strong></td>
<td>No regression</td>
<td>Benchmark vs reference SQL</td>
</tr>
<tr>
<td><strong>Query Performance</strong></td>
<td>&lt;50ms p95</td>
<td>Query execution time</td>
</tr>
<tr>
<td><strong>Throughput</strong></td>
<td>100+ TPS</td>
<td>Transactions per second</td>
</tr>
<tr>
<td><strong>Generation Time</strong></td>
<td>&lt;5 sec</td>
<td>Full schema generation</td>
</tr>
</tbody>
</table>
<h3 id="qualitative-metrics">Qualitative Metrics</h3>
<ul>
<li>[ ] Developers can express business logic without writing SQL</li>
<li>[ ] New patterns can be added without breaking existing code</li>
<li>[ ] Generated SQL is readable and debuggable</li>
<li>[ ] Error messages are clear and actionable</li>
<li>[ ] Documentation is comprehensive and up-to-date</li>
<li>[ ] Pattern library is intuitive to use</li>
<li>[ ] Onboarding time reduced (target: 2 days â†’ 2 hours)</li>
</ul>
<hr />
<h2 id="testing-strategy">ğŸ§ª Testing Strategy</h2>
<h3 id="test-pyramid">Test Pyramid</h3>
<pre><code>                    â–²
                   / \
                  /   \
                 /  E2E \ (50 tests)
                /_______\
               /         \
              / Integration\ (200 tests)
             /_____________\
            /               \
           /   Unit Tests    \ (500 tests)
          /___________________\
</code></pre>
<h3 id="test-categories">Test Categories</h3>
<h4 id="1-pattern-unit-tests">1. Pattern Unit Tests</h4>
<p>Test each pattern in isolation with mock data.</p>
<p><strong>Example</strong>:</p>
<pre><code class="language-python">def test_simple_transition_valid():
    &quot;&quot;&quot;Test valid state transition&quot;&quot;&quot;
    entity = create_test_entity(status='active')
    result = apply_pattern(
        pattern='simple_transition',
        entity=entity,
        config={
            'from_states': ['active'],
            'to_state': 'decommissioned'
        }
    )
    assert result.status == 'success'
    assert entity.status == 'decommissioned'

def test_simple_transition_invalid_source():
    &quot;&quot;&quot;Test transition from invalid source state&quot;&quot;&quot;
    entity = create_test_entity(status='archived')
    result = apply_pattern(
        pattern='simple_transition',
        entity=entity,
        config={
            'from_states': ['active'],
            'to_state': 'decommissioned'
        }
    )
    assert result.status == 'noop:invalid_state_transition'
</code></pre>
<h4 id="2-integration-tests">2. Integration Tests</h4>
<p>Test patterns integrated with real entities and database.</p>
<p><strong>Example</strong>:</p>
<pre><code class="language-python">def test_decommission_machine_e2e(db):
    &quot;&quot;&quot;End-to-end test of machine decommissioning&quot;&quot;&quot;
    # Setup
    machine = create_machine(db, status='active')
    allocation = create_allocation(db, machine=machine, status='completed')

    # Execute
    result = decommission_machine(db, machine.id)

    # Verify
    assert result.status == 'success'
    assert machine.reload().status == 'decommissioned'
    assert machine.decommission_date is not None

    # Verify side effects
    items = get_machine_items(db, machine.id)
    assert all(item.status == 'archived' for item in items)

    # Verify events
    events = get_machine_events(db, machine.id)
    assert any(e.event_type == 'decommissioned' for e in events)
</code></pre>
<h4 id="3-performance-tests">3. Performance Tests</h4>
<p>Benchmark pattern execution time and resource usage.</p>
<p><strong>Example</strong>:</p>
<pre><code class="language-python">def test_bulk_update_performance(db, benchmark):
    &quot;&quot;&quot;Benchmark bulk update with 1000 items&quot;&quot;&quot;
    items = create_contract_items(db, count=1000)
    updates = [{'id': item.id, 'unit_price': 99.99} for item in items]

    result = benchmark(bulk_update_prices, db, updates)

    assert result.success_count == 1000
    assert benchmark.stats['mean'] &lt; 0.5  # &lt; 500ms
</code></pre>
<h4 id="4-regression-tests">4. Regression Tests</h4>
<p>Compare generated SQL behavior with reference implementation.</p>
<p><strong>Example</strong>:</p>
<pre><code class="language-python">def test_decommission_machine_regression(db):
    &quot;&quot;&quot;Ensure generated function matches reference behavior&quot;&quot;&quot;
    machine = create_machine(db, status='active')

    # Execute with generated function
    result_generated = generated.decommission_machine(db, machine.id)
    machine_generated = machine.reload()

    # Execute with reference function
    machine = create_machine(db, status='active')
    result_reference = reference.decommission_machine(db, machine.id)
    machine_reference = machine.reload()

    # Compare results
    assert result_generated.status == result_reference.status
    assert machine_generated.status == machine_reference.status
    assert machine_generated.decommission_date == machine_reference.decommission_date
</code></pre>
<hr />
<h2 id="documentation-structure">ğŸ“š Documentation Structure</h2>
<pre><code>docs/
â”œâ”€â”€ patterns/
â”‚   â”œâ”€â”€ README.md                     # Pattern library overview
â”‚   â”œâ”€â”€ pattern_catalog.md            # All available patterns
â”‚   â”œâ”€â”€ getting_started.md            # Quick start guide
â”‚   â”‚
â”‚   â”œâ”€â”€ core/                         # Core CRUD patterns
â”‚   â”‚   â”œâ”€â”€ partial_update.md
â”‚   â”‚   â”œâ”€â”€ duplicate_check.md
â”‚   â”‚   â”œâ”€â”€ identifier_recalc.md
â”‚   â”‚   â””â”€â”€ projection_refresh.md
â”‚   â”‚
â”‚   â”œâ”€â”€ state_machine/                # State machine patterns
â”‚   â”‚   â”œâ”€â”€ simple_transition.md
â”‚   â”‚   â”œâ”€â”€ multi_step_workflow.md
â”‚   â”‚   â””â”€â”€ guarded_transition.md
â”‚   â”‚
â”‚   â”œâ”€â”€ multi_entity/                 # Multi-entity patterns
â”‚   â”‚   â”œâ”€â”€ coordinated_update.md
â”‚   â”‚   â”œâ”€â”€ parent_child_cascade.md
â”‚   â”‚   â””â”€â”€ get_or_create.md
â”‚   â”‚
â”‚   â”œâ”€â”€ validation/                   # Validation patterns
â”‚   â”‚   â””â”€â”€ validation_chain.md
â”‚   â”‚
â”‚   â”œâ”€â”€ batch/                        # Batch patterns
â”‚   â”‚   â””â”€â”€ bulk_operation.md
â”‚   â”‚
â”‚   â””â”€â”€ examples/                     # Real-world examples
â”‚       â”œâ”€â”€ machine_lifecycle.md
â”‚       â”œâ”€â”€ contract_management.md
â”‚       â””â”€â”€ allocation_workflow.md
â”‚
â”œâ”€â”€ migration/
â”‚   â”œâ”€â”€ migration_guide.md            # How to migrate entities
â”‚   â”œâ”€â”€ reference_mapping.md          # Reference SQL â†’ Pattern mapping
â”‚   â””â”€â”€ troubleshooting.md            # Common migration issues
â”‚
â””â”€â”€ api/
    â”œâ”€â”€ pattern_reference.md          # Pattern API reference
    â”œâ”€â”€ template_reference.md         # Template API reference
    â””â”€â”€ generator_reference.md        # Generator API reference
</code></pre>
<hr />
<h2 id="team-responsibilities">ğŸ‘¥ Team &amp; Responsibilities</h2>
<h3 id="team-c-parser-generator">Team C (Parser + Generator)</h3>
<p><strong>Lead</strong>: [TBD]
<strong>Size</strong>: 2-3 developers</p>
<p><strong>Responsibilities</strong>:
- Design pattern DSL and YAML schema
- Implement SQL generation templates (Jinja2)
- Build pattern parser and validator
- Create test framework for patterns
- Performance optimization</p>
<h3 id="team-b-schema-generator">Team B (Schema Generator)</h3>
<p><strong>Support Role</strong></p>
<p><strong>Responsibilities</strong>:
- Integrate pattern library with schema generation
- Ensure generated SQL follows PrintOptim conventions
- Helper function generation for patterns</p>
<h3 id="team-d-graphqlfraiseql">Team D (GraphQL/FraiseQL)</h3>
<p><strong>Support Role</strong></p>
<p><strong>Responsibilities</strong>:
- Ensure patterns generate correct FraiseQL metadata
- GraphQL projection integration</p>
<h3 id="team-e-maestrobusiness-logic">Team E (Maestro/Business Logic)</h3>
<p><strong>Support Role</strong></p>
<p><strong>Responsibilities</strong>:
- Validate patterns against business requirements
- Provide domain expertise for pattern design
- Test pattern library with real business scenarios</p>
<hr />
<h2 id="implementation-timeline">ğŸš€ Implementation Timeline</h2>
<h3 id="overall-timeline-20-weeks-5-months">Overall Timeline: 20 Weeks (5 Months)</h3>
<pre><code>Weeks 1-4:   Phase 1 - Core CRUD Enhancements
Weeks 5-7:   Phase 2 - State Machine Patterns
Weeks 8-10:  Phase 3 - Multi-Entity Patterns
Weeks 11-13: Phase 4 - Validation &amp; Batch Patterns
Weeks 14-16: Phase 5 - Advanced Patterns
Weeks 17-20: Phase 6 - Migration &amp; Optimization

Parallel tracks:
- Documentation (ongoing)
- Testing (ongoing)
- Performance tuning (ongoing)
</code></pre>
<h3 id="milestones">Milestones</h3>
<table>
<thead>
<tr>
<th>Week</th>
<th>Milestone</th>
<th>Deliverable</th>
</tr>
</thead>
<tbody>
<tr>
<td>4</td>
<td>Phase 1 Complete</td>
<td>Core CRUD patterns working</td>
</tr>
<tr>
<td>7</td>
<td>Phase 2 Complete</td>
<td>State machine patterns working</td>
</tr>
<tr>
<td>10</td>
<td>Phase 3 Complete</td>
<td>Multi-entity patterns working</td>
</tr>
<tr>
<td>13</td>
<td>Phase 4 Complete</td>
<td>Validation &amp; batch patterns working</td>
</tr>
<tr>
<td>16</td>
<td>Phase 5 Complete</td>
<td>All patterns implemented</td>
</tr>
<tr>
<td>18</td>
<td>Migration Complete</td>
<td>All 74 entities migrated</td>
</tr>
<tr>
<td>20</td>
<td>Production Ready</td>
<td>Tested, documented, optimized</td>
</tr>
</tbody>
</table>
<hr />
<h2 id="business-impact">ğŸ’° Business Impact</h2>
<h3 id="development-velocity">Development Velocity</h3>
<p><strong>Before Pattern Library</strong>:
- Implementing business action: 2-4 hours
- Testing: 1-2 hours
- Documentation: 30-60 minutes
- <strong>Total per action</strong>: ~4-7 hours</p>
<p><strong>After Pattern Library</strong>:
- Declaring action in YAML: 15-30 minutes
- Auto-generated tests: 0 minutes
- Auto-generated docs: 0 minutes
- <strong>Total per action</strong>: ~15-30 minutes</p>
<p><strong>Speedup</strong>: <strong>10-20x faster</strong> âš¡</p>
<h3 id="code-maintenance">Code Maintenance</h3>
<p><strong>Before</strong>:
- 120,000+ lines of manual SQL
- Inconsistent patterns across entities
- Hard to refactor (find/replace nightmare)
- High risk of introducing bugs</p>
<p><strong>After</strong>:
- ~6,000 lines of declarative YAML
- 100% consistent patterns
- Easy to refactor (change pattern definition)
- Low risk (comprehensive test suite)</p>
<p><strong>Maintainability</strong>: <strong>20x better</strong> ğŸ¯</p>
<h3 id="quality-assurance">Quality Assurance</h3>
<p><strong>Before</strong>:
- Manual testing required for each function
- Inconsistent error handling
- Missing edge cases
- Performance varies</p>
<p><strong>After</strong>:
- Auto-generated comprehensive tests
- Consistent error handling (NOOP pattern)
- Edge cases covered by pattern library
- Performance guaranteed by benchmarks</p>
<p><strong>Quality</strong>: <strong>10x better</strong> âœ…</p>
<h3 id="time-to-market">Time to Market</h3>
<p><strong>New Feature with 10 Business Actions</strong>:</p>
<p><strong>Before</strong>: 10 actions Ã— 7 hours = <strong>70 hours</strong> (8.75 days)
<strong>After</strong>: 10 actions Ã— 0.5 hours = <strong>5 hours</strong> (0.6 days)</p>
<p><strong>Speedup</strong>: <strong>14x faster</strong> ğŸš€</p>
<h3 id="roi-calculation">ROI Calculation</h3>
<p><strong>Investment</strong>:
- Pattern library development: 20 weeks Ã— 2.5 developers = 50 person-weeks
- Migration: 74 entities Ã— 2 hours = 148 hours â‰ˆ 4 person-weeks
- <strong>Total</strong>: ~54 person-weeks (13.5 person-months)</p>
<p><strong>Return</strong>:
- Current: 600 business actions Ã— 7 hours = 4,200 hours (105 person-weeks)
- Future: 600 business actions Ã— 0.5 hours = 300 hours (7.5 person-weeks)
- <strong>Savings</strong>: 97.5 person-weeks (24 person-months)</p>
<p><strong>ROI</strong>: <strong>180% return</strong> in first year ğŸ’°</p>
<p><strong>Break-even</strong>: After ~50 new business actions (~5 weeks of development)</p>
<hr />
<h2 id="success-criteria">ğŸ¯ Success Criteria</h2>
<h3 id="must-have-launch-blockers">Must Have (Launch Blockers)</h3>
<ul>
<li>[ ] All Priority 1 patterns implemented (Core CRUD, State Machine)</li>
<li>[ ] Pattern library generates correct SQL for 90%+ of use cases</li>
<li>[ ] Generated SQL passes all reference implementation tests</li>
<li>[ ] Documentation complete for all patterns</li>
<li>[ ] Performance benchmarks meet targets</li>
<li>[ ] 74 PrintOptim entities successfully migrated</li>
<li>[ ] Zero regression from reference implementation</li>
</ul>
<h3 id="should-have-post-launch">Should Have (Post-Launch)</h3>
<ul>
<li>[ ] Advanced patterns (conditional, temporal, utilities)</li>
<li>[ ] Pattern composition (combine multiple patterns)</li>
<li>[ ] Custom pattern support (user-defined patterns)</li>
<li>[ ] Visual pattern designer (GUI)</li>
<li>[ ] Pattern versioning system</li>
<li>[ ] Pattern marketplace (community patterns)</li>
</ul>
<h3 id="could-have-future">Could Have (Future)</h3>
<ul>
<li>[ ] AI-assisted pattern suggestion</li>
<li>[ ] Pattern performance profiler</li>
<li>[ ] Pattern impact analysis</li>
<li>[ ] Multi-database support (MySQL, Oracle)</li>
<li>[ ] Pattern migration tools (from other ORMs)</li>
</ul>
<hr />
<h2 id="maintenance-plan">ğŸ”„ Maintenance Plan</h2>
<h3 id="pattern-library-versioning">Pattern Library Versioning</h3>
<pre><code>stdlib/patterns/
â”œâ”€â”€ v1.0/          # Current stable version
â”œâ”€â”€ v1.1/          # Next minor version (backwards compatible)
â””â”€â”€ v2.0/          # Next major version (breaking changes)
</code></pre>
<p><strong>Versioning Rules</strong>:
- <strong>Patch</strong> (1.0.1): Bug fixes, no API changes
- <strong>Minor</strong> (1.1.0): New patterns, backwards compatible
- <strong>Major</strong> (2.0.0): Breaking changes to pattern API</p>
<h3 id="pattern-deprecation-policy">Pattern Deprecation Policy</h3>
<ol>
<li><strong>Announce</strong>: Deprecation notice in release notes</li>
<li><strong>Warn</strong>: Emit warnings when deprecated pattern used</li>
<li><strong>Migrate</strong>: Provide migration guide to new pattern</li>
<li><strong>Remove</strong>: Remove after 2 major versions (minimum 6 months)</li>
</ol>
<h3 id="community-contributions">Community Contributions</h3>
<p><strong>Pattern Contribution Process</strong>:
1. Submit pattern proposal (GitHub issue)
2. Community discussion and feedback
3. Implementation by contributor
4. Code review by maintainers
5. Test suite validation
6. Documentation approval
7. Merge into stdlib/patterns/community/
8. After 6 months + positive feedback â†’ move to stdlib/patterns/core/</p>
<hr />
<h2 id="training-plan">ğŸ“ Training Plan</h2>
<h3 id="developer-onboarding-2-hours">Developer Onboarding (2 hours)</h3>
<p><strong>Session 1: Pattern Library Overview (30 min)</strong>
- What are patterns?
- Why use patterns?
- Pattern library structure
- Demo: Simple state transition</p>
<p><strong>Session 2: Core Patterns (45 min)</strong>
- Partial updates
- Duplicate detection
- Identifier recalculation
- Projection refresh
- Hands-on: Migrate a simple entity</p>
<p><strong>Session 3: Advanced Patterns (30 min)</strong>
- State machines
- Multi-entity operations
- Validation chains
- Batch operations
- Hands-on: Implement complex business action</p>
<p><strong>Session 4: Best Practices (15 min)</strong>
- Choosing the right pattern
- Composing patterns
- Debugging generated SQL
- Performance considerations</p>
<h3 id="ongoing-learning">Ongoing Learning</h3>
<ul>
<li><strong>Weekly office hours</strong>: Q&amp;A with pattern library maintainers</li>
<li><strong>Pattern showcase</strong>: Monthly demos of new/interesting patterns</li>
<li><strong>Documentation updates</strong>: Continuous improvement based on feedback</li>
<li><strong>Video tutorials</strong>: Screen recordings for common scenarios</li>
</ul>
<hr />
<h2 id="support-plan">ğŸ“ Support Plan</h2>
<h3 id="developer-support-channels">Developer Support Channels</h3>
<ol>
<li><strong>Documentation</strong>: First stop for all questions</li>
<li><strong>GitHub Issues</strong>: Bug reports, feature requests</li>
<li><strong>Slack Channel</strong>: Real-time Q&amp;A (#pattern-library)</li>
<li><strong>Office Hours</strong>: Weekly 1-hour session</li>
<li><strong>Email</strong>: pattern-library@printoptim.com</li>
</ol>
<h3 id="sla-commitments">SLA Commitments</h3>
<table>
<thead>
<tr>
<th>Priority</th>
<th>Response Time</th>
<th>Resolution Time</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>P0</strong> (Production down)</td>
<td>1 hour</td>
<td>4 hours</td>
</tr>
<tr>
<td><strong>P1</strong> (Major bug)</td>
<td>4 hours</td>
<td>24 hours</td>
</tr>
<tr>
<td><strong>P2</strong> (Minor bug)</td>
<td>24 hours</td>
<td>1 week</td>
</tr>
<tr>
<td><strong>P3</strong> (Enhancement)</td>
<td>1 week</td>
<td>Best effort</td>
</tr>
</tbody>
</table>
<hr />
<h2 id="conclusion">ğŸ‰ Conclusion</h2>
<p>This business logic library will transform PrintOptim development from <strong>manual SQL implementation</strong> to <strong>declarative pattern composition</strong>, achieving:</p>
<ul>
<li><strong>95% code reduction</strong> (120,000 â†’ 6,000 lines)</li>
<li><strong>10-20x development speedup</strong> (7 hours â†’ 30 minutes per action)</li>
<li><strong>180% ROI</strong> in first year (24 person-months saved)</li>
<li><strong>100% consistency</strong> (all business logic follows same patterns)</li>
<li><strong>Production-ready quality</strong> (comprehensive test suite, benchmarks)</li>
</ul>
<p>The pattern library enables developers to <strong>focus on business logic</strong> rather than SQL plumbing, accelerating PrintOptim's path to the <strong>$100M+ multi-language code generation vision</strong>.</p>
<hr />
<p><strong>Next Steps</strong>:
1. âœ… Review this implementation plan
2. â³ Approve budget and timeline
3. â³ Assign Team C developers
4. â³ Set up project infrastructure
5. â³ Begin Phase 1 implementation
6. â³ Weekly progress reviews</p>
<p><strong>Status</strong>: ğŸ“‹ <strong>Planning Complete</strong> - Ready for Review &amp; Approval</p>
              
            </div>
          </div><footer>

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
          
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="Versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    
    
    
  </span>
</div>
    <script src="../../js/jquery-3.6.0.min.js"></script>
    <script>var base_url = "../..";</script>
    <script src="../../js/theme_extra.js"></script>
    <script src="../../js/theme.js"></script>
      <script src="../../search/main.js"></script>
    <script>
        jQuery(function () {
            SphinxRtdTheme.Navigation.enable(true);
        });
    </script>

</body>
</html>
