<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
      <link rel="shortcut icon" href="../../img/favicon.ico" />
    <title>Implementation Plan: SpecQL-Based Schema Generator - SpecQL Documentation</title>
    <link rel="stylesheet" href="../../css/theme.css" />
    <link rel="stylesheet" href="../../css/theme_extra.css" />
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github.min.css" />
    
      <script>
        // Current page data
        var mkdocs_page_name = "Implementation Plan: SpecQL-Based Schema Generator";
        var mkdocs_page_input_path = "architecture/IMPLEMENTATION_PLAN_SPECQL.md";
        var mkdocs_page_url = null;
      </script>
    
    <!--[if lt IE 9]>
      <script src="../../js/html5shiv.min.js"></script>
    <![endif]-->
      <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
      <script>hljs.highlightAll();</script> 
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
          <a href="../.." class="icon icon-home"> SpecQL Documentation
        </a><div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../../search.html" method="get">
      <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../..">Home</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="" href="../../getting-started/">Getting Started</a>
                </li>
              </ul>
              <p class="caption"><span class="caption-text">Guides</span></p>
              <ul>
                  <li class="toctree-l1"><a class="" href="../../guides/mutation-patterns/">Mutation Patterns</a>
                  </li>
                  <li class="toctree-l1"><a class="" href="../../guides/test-generation/">Test Generation</a>
                  </li>
                  <li class="toctree-l1"><a class="" href="../../guides/cli/">CLI</a>
                  </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="" href="../../reference/">Reference</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="" href="../../examples/">Examples</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="" href="../../tutorials/">Tutorials</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="" href="../../best-practices/">Best Practices</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="" href="../../troubleshooting/">Troubleshooting</a>
                </li>
              </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">
      <nav class="wy-nav-top" role="navigation" aria-label="Mobile navigation menu">
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../..">SpecQL Documentation</a>
        
      </nav>
      <div class="wy-nav-content">
        <div class="rst-content"><div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../.." class="icon icon-home" aria-label="Docs"></a></li>
      <li class="breadcrumb-item active">Implementation Plan: SpecQL-Based Schema Generator</li>
    <li class="wy-breadcrumbs-aside">
    </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
            <div class="section" itemprop="articleBody">
              
                <h1 id="implementation-plan-specql-based-schema-generator">Implementation Plan: SpecQL-Based Schema Generator</h1>
<p><strong>Project</strong>: PrintOptim Backend - SpecQL Integration
<strong>Date</strong>: November 8, 2025
<strong>Status</strong>: Implementation Plan - APPROVED (SpecQL-Aligned)
<strong>Methodology</strong>: Phased TDD Approach</p>
<hr />
<h2 id="executive-summary">Executive Summary</h2>
<p>This plan implements a <strong>SpecQL-compatible schema generator</strong> that:</p>
<ol>
<li><strong>Parses business-focused YAML</strong> (40-60 lines vs 200+ lines)</li>
<li><strong>Generates PostgreSQL schema</strong> (tables, views, functions)</li>
<li><strong>Generates SpecQL action steps</strong> (business logic DSL)</li>
<li><strong>Auto-generates GraphQL API</strong> (via FraiseQL introspection)</li>
<li><strong>Integrates AI agents</strong> (optional automation layer)</li>
</ol>
<p><strong>Key Insight</strong>: Framework handles 80% (infrastructure), YAML specifies 20% (business rules)</p>
<p><strong>Timeline</strong>: 10 weeks (5 phases)
<strong>Complexity</strong>: Complex - Phased TDD Approach
<strong>Total Effort</strong>: ~280 hours
<strong>ROI</strong>: 90% reduction in backend development time</p>
<hr />
<h2 id="architecture-overview">ğŸ¯ Architecture Overview</h2>
<pre><code>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ YAML Entity (Business-Focused - 40-60 lines)                â”‚
â”‚   entity: Manufacturer                                      â”‚
â”‚     fields: {identifier, name, abbreviation}                â”‚
â”‚     actions:                                                â”‚
â”‚       - name: create_manufacturer                           â”‚
â”‚         steps: [validate, insert, notify]                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                     â”‚
         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
         â–¼                       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ SpecQL Compiler     â”‚  â”‚ Numbering System    â”‚
â”‚ (Business â†’ SQL)    â”‚  â”‚ (Hierarchy)         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
           â”‚                        â”‚
           â–¼                        â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Generated PostgreSQL Schema                                 â”‚
â”‚   01_write_side/013_catalog/.../013211_tb_manufacturer.sql  â”‚
â”‚   - Trinity Pattern table                                   â”‚
â”‚   - Group leader triggers                                   â”‚
â”‚   - Business logic functions                                â”‚
â”‚   - COMMENT annotations for FraiseQL                        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                     â”‚
                     â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ FraiseQL Auto-Discovery                                     â”‚
â”‚   - GraphQL types (Contact, Manufacturer, etc.)             â”‚
â”‚   - Queries (contact, contacts, manufacturers)              â”‚
â”‚   - Mutations (createContact, qualifyLead)                  â”‚
â”‚   - Filters (where, orderBy, pagination)                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                     â”‚
                     â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Full-Stack Backend API                                      â”‚
â”‚   - TypeScript types                                        â”‚
â”‚   - React hooks                                             â”‚
â”‚   - Auto-generated tests                                    â”‚
â”‚   - API documentation                                       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
</code></pre>
<hr />
<h2 id="critical-success-factors">Critical Success Factors</h2>
<h3 id="pre-flight-checklist">Pre-Flight Checklist</h3>
<ul>
<li>[ ] SpecQL DSL syntax finalized (action step grammar)</li>
<li>[ ] FraiseQL integration tested (COMMENT â†’ GraphQL)</li>
<li>[ ] PostgreSQL 14+ with Trinity Pattern support</li>
<li>[ ] Test database instance available</li>
<li>[ ] Python 3.8+, Jinja2, YAML parser ready</li>
</ul>
<h3 id="core-principles">Core Principles</h3>
<ol>
<li><strong>Business-Focused YAML</strong>: Only domain logic, no infrastructure</li>
<li><strong>Framework Generates Boilerplate</strong>: CRUD, permissions, audit, events</li>
<li><strong>SpecQL DSL</strong>: Declarative business workflows</li>
<li><strong>Incremental</strong>: Each phase delivers working system</li>
<li><strong>Test-Driven</strong>: Every feature has failing â†’ passing â†’ refactored tests</li>
</ol>
<hr />
<h2 id="phase-1-specql-yaml-parser-validator-week-1-2">PHASE 1: SpecQL YAML Parser + Validator (Week 1-2)</h2>
<p><strong>Objective</strong>: Parse SpecQL-style YAML and validate business logic
<strong>Duration</strong>: 50 hours
<strong>Complexity</strong>: Complex - Phased TDD</p>
<h3 id="phase-1-overview">Phase 1 Overview</h3>
<pre><code>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ INPUT: SpecQL YAML                                          â”‚
â”‚   entity: Contact                                           â”‚
â”‚     fields:                                                 â”‚
â”‚       email: text                                           â”‚
â”‚       status: enum(lead, qualified, customer)               â”‚
â”‚     actions:                                                â”‚
â”‚       - name: create_contact                                â”‚
â”‚         steps:                                              â”‚
â”‚           - validate: email MATCHES email_pattern           â”‚
â”‚           - insert: Contact(...)                            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                     â”‚
                     â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ OUTPUT: Parsed AST + Validation                             â”‚
â”‚   - Entity metadata                                         â”‚
â”‚   - Field definitions (types, refs, enums)                  â”‚
â”‚   - Action workflows (validated steps)                      â”‚
â”‚   - Business rules (validated expressions)                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
</code></pre>
<hr />
<h3 id="iteration-11-specql-yaml-schema-validator-tdd-cycle">Iteration 1.1: SpecQL YAML Schema Validator (TDD Cycle)</h3>
<h4 id="red-phase-write-failing-test">ğŸ”´ RED Phase - Write Failing Test</h4>
<p><strong>Time</strong>: 2 hours</p>
<pre><code class="language-python"># tests/test_specql_parser.py
import pytest
from src.specql_parser import SpecQLParser, ParseError

def test_parse_simple_entity():
    &quot;&quot;&quot;Test parsing basic SpecQL entity definition&quot;&quot;&quot;
    yaml_content = &quot;&quot;&quot;
entity: Contact
  schema: crm
  description: &quot;Customer contact&quot;

  fields:
    first_name: text
    last_name: text
    email: text
    status: enum(lead, qualified, customer)
    company: ref(Company)

  actions:
    - name: create_contact
      steps:
        - validate: email MATCHES email_pattern
          error: &quot;invalid_email&quot;
        - insert: Contact
&quot;&quot;&quot;

    parser = SpecQLParser()
    entity = parser.parse(yaml_content)

    # Verify entity metadata
    assert entity.name == 'Contact'
    assert entity.schema == 'crm'
    assert entity.description == 'Customer contact'

    # Verify fields
    assert 'email' in entity.fields
    assert entity.fields['email'].type == 'text'

    # Verify enum field
    assert entity.fields['status'].type == 'enum'
    assert entity.fields['status'].values == ['lead', 'qualified', 'customer']

    # Verify ref field
    assert entity.fields['company'].type == 'ref'
    assert entity.fields['company'].target_entity == 'Company'

    # Verify actions
    assert len(entity.actions) == 1
    assert entity.actions[0].name == 'create_contact'
    assert len(entity.actions[0].steps) == 2

def test_parse_action_steps():
    &quot;&quot;&quot;Test parsing action step DSL&quot;&quot;&quot;
    yaml_content = &quot;&quot;&quot;
entity: Reservation
  actions:
    - name: create_reservation
      steps:
        - validate: reserved_from &lt;= reserved_until
          error: &quot;invalid_date_range&quot;

        - if: reserved_from &lt; CURRENT_DATE
          then:
            - reject: &quot;past_date_not_allowed&quot;

        - find: current_allocation WHERE fk_machine = input.machine_id

        - update: current_allocation SET end_date = reserved_from - 1

        - insert: Allocation(machine, start_date, end_date)

        - call: update_machine_flags(machine_id = input.machine_id)
&quot;&quot;&quot;

    parser = SpecQLParser()
    entity = parser.parse(yaml_content)

    action = entity.actions[0]

    # Verify step types
    assert action.steps[0].type == 'validate'
    assert action.steps[0].expression == 'reserved_from &lt;= reserved_until'
    assert action.steps[0].error == 'invalid_date_range'

    assert action.steps[1].type == 'if'
    assert action.steps[1].condition == 'reserved_from &lt; CURRENT_DATE'
    assert len(action.steps[1].then_steps) == 1

    assert action.steps[2].type == 'find'
    assert action.steps[2].entity == 'current_allocation'

    assert action.steps[3].type == 'update'
    assert action.steps[4].type == 'insert'
    assert action.steps[5].type == 'call'

def test_validate_action_steps():
    &quot;&quot;&quot;Test validation of business logic steps&quot;&quot;&quot;
    yaml_content = &quot;&quot;&quot;
entity: Contact
  actions:
    - name: create_contact
      steps:
        - validate: invalid_field_name &gt; 10
&quot;&quot;&quot;

    parser = SpecQLParser()

    with pytest.raises(ParseError, match=&quot;Field 'invalid_field_name' not found&quot;):
        parser.parse(yaml_content)

def test_parse_ai_agents():
    &quot;&quot;&quot;Test parsing AI agent configuration&quot;&quot;&quot;
    yaml_content = &quot;&quot;&quot;
entity: Contact
  agents:
    - name: lead_scoring_agent
      type: ai_llm
      observes: ['contact.created', 'activity.logged']
      can_execute: ['update_lead_score', 'qualify_lead']
      strategy: |
        Analyze contact data and score 0-100 based on:
        1. Company size
        2. Industry fit
        3. Engagement level
      audit: required
&quot;&quot;&quot;

    parser = SpecQLParser()
    entity = parser.parse(yaml_content)

    assert len(entity.agents) == 1
    agent = entity.agents[0]

    assert agent.name == 'lead_scoring_agent'
    assert agent.type == 'ai_llm'
    assert 'contact.created' in agent.observes
    assert 'update_lead_score' in agent.can_execute
    assert agent.audit == 'required'
    assert 'Company size' in agent.strategy

def test_parse_with_numbering_system():
    &quot;&quot;&quot;Test integration with numbering system&quot;&quot;&quot;
    yaml_content = &quot;&quot;&quot;
entity: Manufacturer
  schema: catalog
  organization:
    table_code: &quot;013211&quot;
    domain_name: &quot;catalog&quot;

  fields:
    identifier: text
&quot;&quot;&quot;

    parser = SpecQLParser()
    entity = parser.parse(yaml_content)

    assert entity.organization.table_code == '013211'
    assert entity.organization.domain_name == 'catalog'
</code></pre>
<p><strong>Run test</strong> (expect failures):</p>
<pre><code class="language-bash">uv run pytest tests/test_specql_parser.py -v
# Expected: FAILED - SpecQLParser not found
</code></pre>
<hr />
<h4 id="green-phase-minimal-implementation">ğŸŸ¢ GREEN Phase - Minimal Implementation</h4>
<p><strong>Time</strong>: 8 hours</p>
<pre><code class="language-python"># src/specql_parser.py
&quot;&quot;&quot;
SpecQL YAML Parser
Parses business-focused entity definitions into AST
&quot;&quot;&quot;
from typing import Dict, List, Any, Optional
from dataclasses import dataclass, field
import yaml
import re

class ParseError(Exception):
    &quot;&quot;&quot;Raised when YAML parsing fails&quot;&quot;&quot;
    pass

@dataclass
class FieldDefinition:
    &quot;&quot;&quot;Parsed field definition&quot;&quot;&quot;
    name: str
    type: str  # text, integer, enum, ref, list
    nullable: bool = True
    default: Optional[Any] = None

    # For enum fields
    values: Optional[List[str]] = None

    # For ref fields
    target_entity: Optional[str] = None

    # For list fields
    item_type: Optional[str] = None

@dataclass
class ActionStep:
    &quot;&quot;&quot;Parsed action step&quot;&quot;&quot;
    type: str  # validate, if, insert, update, delete, call, find, etc.

    # For validate steps
    expression: Optional[str] = None
    error: Optional[str] = None

    # For conditional steps
    condition: Optional[str] = None
    then_steps: List['ActionStep'] = field(default_factory=list)
    else_steps: List['ActionStep'] = field(default_factory=list)

    # For database operations
    entity: Optional[str] = None
    fields: Optional[Dict[str, Any]] = None
    where_clause: Optional[str] = None

    # For function calls
    function_name: Optional[str] = None
    arguments: Optional[Dict[str, Any]] = None
    store_result: Optional[str] = None

@dataclass
class Action:
    &quot;&quot;&quot;Parsed action definition&quot;&quot;&quot;
    name: str
    requires: Optional[str] = None  # Permission expression
    steps: List[ActionStep] = field(default_factory=list)

@dataclass
class Agent:
    &quot;&quot;&quot;Parsed AI agent definition&quot;&quot;&quot;
    name: str
    type: str  # ai_llm, rule_based
    observes: List[str] = field(default_factory=list)
    can_execute: List[str] = field(default_factory=list)
    strategy: str = &quot;&quot;
    audit: str = &quot;required&quot;

@dataclass
class Organization:
    &quot;&quot;&quot;Entity organization metadata (numbering system)&quot;&quot;&quot;
    table_code: str
    domain_name: Optional[str] = None

@dataclass
class Entity:
    &quot;&quot;&quot;Parsed SpecQL entity&quot;&quot;&quot;
    name: str
    schema: str = &quot;public&quot;
    table: Optional[str] = None  # If different from entity name
    description: str = &quot;&quot;

    fields: Dict[str, FieldDefinition] = field(default_factory=dict)
    actions: List[Action] = field(default_factory=list)
    agents: List[Agent] = field(default_factory=list)

    # Numbering system integration
    organization: Optional[Organization] = None

class SpecQLParser:
    &quot;&quot;&quot;Parse SpecQL YAML into AST&quot;&quot;&quot;

    def parse(self, yaml_content: str) -&gt; Entity:
        &quot;&quot;&quot;
        Parse YAML content into Entity AST

        Args:
            yaml_content: YAML string to parse

        Returns:
            Entity AST

        Raises:
            ParseError: If YAML is invalid
        &quot;&quot;&quot;
        try:
            data = yaml.safe_load(yaml_content)
        except yaml.YAMLError as e:
            raise ParseError(f&quot;Invalid YAML: {e}&quot;)

        if 'entity' not in data:
            raise ParseError(&quot;Missing 'entity' key in YAML&quot;)

        entity_data = data['entity']

        # Parse entity metadata
        if isinstance(entity_data, str):
            # Simple form: entity: EntityName
            entity_name = entity_data
            entity_config = data
        else:
            # Complex form: entity contains all config
            entity_name = entity_data.get('name')
            if not entity_name:
                raise ParseError(&quot;Entity name is required&quot;)
            entity_config = entity_data

        entity = Entity(
            name=entity_name,
            schema=entity_config.get('schema', 'public'),
            table=entity_config.get('table'),
            description=entity_config.get('description', '')
        )

        # Parse organization (numbering system)
        if 'organization' in entity_config:
            org_data = entity_config['organization']
            entity.organization = Organization(
                table_code=org_data['table_code'],
                domain_name=org_data.get('domain_name')
            )

        # Parse fields
        if 'fields' in entity_config:
            entity.fields = self._parse_fields(entity_config['fields'])

        # Parse actions
        if 'actions' in entity_config:
            entity.actions = self._parse_actions(
                entity_config['actions'],
                entity.fields
            )

        # Parse agents
        if 'agents' in entity_config:
            entity.agents = self._parse_agents(entity_config['agents'])

        return entity

    def _parse_fields(self, fields_data: Dict) -&gt; Dict[str, FieldDefinition]:
        &quot;&quot;&quot;Parse field definitions&quot;&quot;&quot;
        fields = {}

        for field_name, field_spec in fields_data.items():
            field_def = self._parse_field_spec(field_name, field_spec)
            fields[field_name] = field_def

        return fields

    def _parse_field_spec(self, name: str, spec: Any) -&gt; FieldDefinition:
        &quot;&quot;&quot;
        Parse individual field specification

        Formats:
        - field_name: text
        - field_name: ref(Entity)
        - field_name: enum(val1, val2, val3)
        - field_name: list(ref(Entity))
        - field_name: text = default_value
        &quot;&quot;&quot;
        # Handle default values (text = &quot;default&quot;)
        if isinstance(spec, str) and ' = ' in spec:
            type_part, default_part = spec.split(' = ', 1)
            spec = type_part.strip()
            default = default_part.strip().strip('&quot;\'')
        else:
            default = None

        # Simple type
        if isinstance(spec, str):
            # Check for ref(Entity)
            ref_match = re.match(r'ref\((\w+)\)', spec)
            if ref_match:
                return FieldDefinition(
                    name=name,
                    type='ref',
                    target_entity=ref_match.group(1),
                    default=default
                )

            # Check for enum(val1, val2, ...)
            enum_match = re.match(r'enum\((.*)\)', spec)
            if enum_match:
                values = [v.strip() for v in enum_match.group(1).split(',')]
                return FieldDefinition(
                    name=name,
                    type='enum',
                    values=values,
                    default=default
                )

            # Check for list(type)
            list_match = re.match(r'list\((.*)\)', spec)
            if list_match:
                item_spec = list_match.group(1)
                return FieldDefinition(
                    name=name,
                    type='list',
                    item_type=item_spec,
                    default=default
                )

            # Simple type (text, integer, etc.)
            return FieldDefinition(
                name=name,
                type=spec,
                default=default
            )

        # Complex specification (dict)
        elif isinstance(spec, dict):
            return FieldDefinition(
                name=name,
                type=spec.get('type', 'text'),
                nullable=spec.get('nullable', True),
                default=spec.get('default'),
                values=spec.get('values'),
                target_entity=spec.get('ref')
            )

        raise ParseError(f&quot;Invalid field specification for '{name}': {spec}&quot;)

    def _parse_actions(
        self,
        actions_data: List[Dict],
        entity_fields: Dict[str, FieldDefinition]
    ) -&gt; List[Action]:
        &quot;&quot;&quot;Parse action definitions&quot;&quot;&quot;
        actions = []

        for action_data in actions_data:
            action = Action(
                name=action_data['name'],
                requires=action_data.get('requires')
            )

            # Parse action steps
            if 'steps' in action_data:
                action.steps = self._parse_steps(
                    action_data['steps'],
                    entity_fields
                )

            actions.append(action)

        return actions

    def _parse_steps(
        self,
        steps_data: List,
        entity_fields: Dict[str, FieldDefinition]
    ) -&gt; List[ActionStep]:
        &quot;&quot;&quot;Parse action step DSL&quot;&quot;&quot;
        steps = []

        for step_data in steps_data:
            step = self._parse_single_step(step_data, entity_fields)
            steps.append(step)

        return steps

    def _parse_single_step(
        self,
        step_data: Dict,
        entity_fields: Dict[str, FieldDefinition]
    ) -&gt; ActionStep:
        &quot;&quot;&quot;Parse single action step&quot;&quot;&quot;

        # Validate step
        if 'validate' in step_data:
            expression = step_data['validate']

            # Validate field references in expression
            self._validate_expression_fields(expression, entity_fields)

            return ActionStep(
                type='validate',
                expression=expression,
                error=step_data.get('error', 'validation_failed')
            )

        # If-then-else step
        elif 'if' in step_data:
            condition = step_data['if']
            then_steps = self._parse_steps(
                step_data.get('then', []),
                entity_fields
            )
            else_steps = self._parse_steps(
                step_data.get('else', []),
                entity_fields
            )

            return ActionStep(
                type='if',
                condition=condition,
                then_steps=then_steps,
                else_steps=else_steps
            )

        # Insert step
        elif 'insert' in step_data:
            entity_spec = step_data['insert']

            # Parse entity name and fields
            if isinstance(entity_spec, str):
                # Simple form: insert: Entity
                entity_name = entity_spec
                fields = None
            else:
                # Complex form: insert: Entity(field1, field2)
                match = re.match(r'(\w+)\((.*)\)', entity_spec)
                if match:
                    entity_name = match.group(1)
                    field_list = [f.strip() for f in match.group(2).split(',')]
                    fields = {f: f&quot;input.{f}&quot; for f in field_list}
                else:
                    raise ParseError(f&quot;Invalid insert syntax: {entity_spec}&quot;)

            return ActionStep(
                type='insert',
                entity=entity_name,
                fields=fields
            )

        # Update step
        elif 'update' in step_data:
            update_spec = step_data['update']

            # Parse: update: entity SET field = value WHERE condition
            parts = re.split(r'\s+SET\s+|\s+WHERE\s+', update_spec, flags=re.IGNORECASE)

            entity_name = parts[0].strip()
            set_clause = parts[1].strip() if len(parts) &gt; 1 else None
            where_clause = parts[2].strip() if len(parts) &gt; 2 else None

            return ActionStep(
                type='update',
                entity=entity_name,
                fields={'raw_set': set_clause},
                where_clause=where_clause
            )

        # Delete step
        elif 'delete' in step_data:
            return ActionStep(
                type='delete',
                entity=step_data['delete']
            )

        # Find step
        elif 'find' in step_data:
            find_spec = step_data['find']

            # Parse: find: entity WHERE condition
            parts = re.split(r'\s+WHERE\s+', find_spec, maxsplit=1, flags=re.IGNORECASE)
            entity_name = parts[0].strip()
            where_clause = parts[1].strip() if len(parts) &gt; 1 else None

            return ActionStep(
                type='find',
                entity=entity_name,
                where_clause=where_clause
            )

        # Call step
        elif 'call' in step_data:
            call_spec = step_data['call']

            # Parse: call: function_name(arg1 = val1, arg2 = val2)
            match = re.match(r'(\w+)\((.*)\)', call_spec)
            if match:
                function_name = match.group(1)
                args_str = match.group(2)

                # Parse arguments
                arguments = {}
                if args_str:
                    for arg in args_str.split(','):
                        arg = arg.strip()
                        if '=' in arg:
                            key, value = arg.split('=', 1)
                            arguments[key.strip()] = value.strip()

                return ActionStep(
                    type='call',
                    function_name=function_name,
                    arguments=arguments,
                    store_result=step_data.get('store')
                )
            else:
                raise ParseError(f&quot;Invalid call syntax: {call_spec}&quot;)

        # Reject step
        elif 'reject' in step_data:
            return ActionStep(
                type='reject',
                error=step_data['reject']
            )

        else:
            raise ParseError(f&quot;Unknown step type: {step_data}&quot;)

    def _validate_expression_fields(
        self,
        expression: str,
        entity_fields: Dict[str, FieldDefinition]
    ) -&gt; None:
        &quot;&quot;&quot;Validate that fields referenced in expression exist&quot;&quot;&quot;
        # Extract field names (simple heuristic: words before operators)
        potential_fields = re.findall(r'\b([a-z_][a-z0-9_]*)\b', expression.lower())

        # Filter out common keywords
        keywords = {'and', 'or', 'not', 'null', 'true', 'false', 'current_date',
                   'exists', 'is', 'in', 'like', 'between', 'input', 'matches'}

        for field_name in potential_fields:
            if field_name not in keywords and field_name not in entity_fields:
                # Allow input.field_name
                if not expression.startswith(f'input.{field_name}'):
                    raise ParseError(
                        f&quot;Field '{field_name}' referenced in expression not found in entity. &quot;
                        f&quot;Available fields: {', '.join(entity_fields.keys())}&quot;
                    )

    def _parse_agents(self, agents_data: List[Dict]) -&gt; List[Agent]:
        &quot;&quot;&quot;Parse AI agent definitions&quot;&quot;&quot;
        agents = []

        for agent_data in agents_data:
            agent = Agent(
                name=agent_data['name'],
                type=agent_data.get('type', 'rule_based'),
                observes=agent_data.get('observes', []),
                can_execute=agent_data.get('can_execute', []),
                strategy=agent_data.get('strategy', ''),
                audit=agent_data.get('audit', 'required')
            )
            agents.append(agent)

        return agents
</code></pre>
<p><strong>Run test</strong>:</p>
<pre><code class="language-bash">uv run pytest tests/test_specql_parser.py -v
# Expected: PASSED (most tests green)
</code></pre>
<hr />
<h4 id="refactor-phase-clean-up">ğŸ”§ REFACTOR Phase - Clean Up</h4>
<p><strong>Time</strong>: 3 hours</p>
<p><strong>Improvements:</strong>
1. Extract regex patterns to constants
2. Add comprehensive docstrings
3. Better error messages with line numbers
4. Support for switch/case statements
5. Support for computed fields</p>
<pre><code class="language-python"># src/specql_parser.py (refactored)

class SpecQLParser:
    &quot;&quot;&quot;Parse SpecQL YAML into AST with comprehensive validation&quot;&quot;&quot;

    # Regex patterns (extracted)
    REF_PATTERN = re.compile(r'ref\((\w+)\)')
    ENUM_PATTERN = re.compile(r'enum\((.*)\)')
    LIST_PATTERN = re.compile(r'list\((.*)\)')
    INSERT_PATTERN = re.compile(r'(\w+)\((.*)\)')
    UPDATE_PATTERN = re.compile(r'(\w+)\s+SET\s+(.*?)(?:\s+WHERE\s+(.*))?$', re.IGNORECASE)
    CALL_PATTERN = re.compile(r'(\w+)\((.*)\)')

    # Reserved keywords
    KEYWORDS = {
        'and', 'or', 'not', 'null', 'true', 'false', 'current_date',
        'exists', 'is', 'in', 'like', 'between', 'input', 'matches',
        'current_timestamp', 'now', 'select', 'from', 'where'
    }

    def parse_with_context(self, yaml_content: str, filename: str = '&lt;string&gt;') -&gt; Entity:
        &quot;&quot;&quot;
        Parse YAML with context for better error messages

        Args:
            yaml_content: YAML string
            filename: Source filename for error reporting

        Returns:
            Parsed Entity
        &quot;&quot;&quot;
        try:
            return self.parse(yaml_content)
        except ParseError as e:
            raise ParseError(f&quot;{filename}: {e}&quot;)

    # ... rest of refactored implementation
</code></pre>
<hr />
<h4 id="qa-phase-verify-quality">âœ… QA Phase - Verify Quality</h4>
<p><strong>Time</strong>: 2 hours</p>
<pre><code class="language-bash"># Run full test suite
uv run pytest tests/test_specql_parser.py -v --cov=src/specql_parser

# Run linting
uv run ruff check src/specql_parser.py

# Run type checking
uv run mypy src/specql_parser.py

# Check test coverage (should be &gt;90%)
uv run pytest --cov=src --cov-report=html
</code></pre>
<p><strong>Quality Gates:</strong>
- [ ] All tests pass
- [ ] Code coverage &gt; 90%
- [ ] No linting errors
- [ ] Type checking passes
- [ ] Handles all SpecQL step types
- [ ] Clear error messages</p>
<hr />
<h3 id="iteration-12-sql-generator-for-specql-actions-tdd-cycle">Iteration 1.2: SQL Generator for SpecQL Actions (TDD Cycle)</h3>
<h4 id="red-phase">ğŸ”´ RED Phase</h4>
<p><strong>Time</strong>: 2 hours</p>
<pre><code class="language-python"># tests/test_specql_sql_generator.py
def test_generate_action_function():
    &quot;&quot;&quot;Test generating SQL function from SpecQL action&quot;&quot;&quot;
    generator = SpecQLSQLGenerator()

    entity = Entity(
        name='Contact',
        schema='crm',
        fields={
            'email': FieldDefinition(name='email', type='text'),
            'status': FieldDefinition(name='status', type='enum',
                                     values=['lead', 'qualified'])
        },
        actions=[
            Action(
                name='create_contact',
                steps=[
                    ActionStep(
                        type='validate',
                        expression='email MATCHES email_pattern',
                        error='invalid_email'
                    ),
                    ActionStep(
                        type='insert',
                        entity='Contact'
                    )
                ]
            )
        ]
    )

    sql = generator.generate_action_function(entity, entity.actions[0])

    # Verify SQL structure
    assert 'CREATE OR REPLACE FUNCTION crm.fn_create_contact' in sql
    assert 'IF NOT (email ~ email_pattern) THEN' in sql
    assert &quot;RETURN error('invalid_email')&quot; in sql
    assert 'INSERT INTO crm.tb_contact' in sql
    assert 'RETURN success(result)' in sql

def test_generate_conditional_logic():
    &quot;&quot;&quot;Test generating if-then-else SQL&quot;&quot;&quot;
    step = ActionStep(
        type='if',
        condition='status = \'lead\'',
        then_steps=[
            ActionStep(type='call', function_name='score_lead')
        ],
        else_steps=[
            ActionStep(type='call', function_name='skip_scoring')
        ]
    )

    generator = SpecQLSQLGenerator()
    sql = generator.generate_step_sql(step)

    assert 'IF (status = \'lead\') THEN' in sql
    assert 'score_lead()' in sql
    assert 'ELSE' in sql
    assert 'skip_scoring()' in sql
</code></pre>
<hr />
<h4 id="green-phase">ğŸŸ¢ GREEN Phase</h4>
<p><strong>Time</strong>: 12 hours</p>
<p>Create comprehensive SQL generator:</p>
<pre><code class="language-python"># src/specql_sql_generator.py
&quot;&quot;&quot;
SpecQL SQL Generator
Compiles SpecQL action steps to PostgreSQL functions
&quot;&quot;&quot;
from typing import List
from src.specql_parser import Entity, Action, ActionStep
from jinja2 import Environment, FileSystemLoader

class SpecQLSQLGenerator:
    &quot;&quot;&quot;Generate PostgreSQL functions from SpecQL actions&quot;&quot;&quot;

    def __init__(self, templates_dir='templates'):
        self.env = Environment(
            loader=FileSystemLoader(templates_dir),
            trim_blocks=True,
            lstrip_blocks=True
        )

    def generate_action_function(self, entity: Entity, action: Action) -&gt; str:
        &quot;&quot;&quot;
        Generate complete SQL function for action

        Returns:
            PostgreSQL function SQL
        &quot;&quot;&quot;
        template = self.env.get_template('specql_action_function.sql.j2')

        # Generate SQL for each step
        steps_sql = []
        for step in action.steps:
            step_sql = self.generate_step_sql(step, entity)
            steps_sql.append(step_sql)

        return template.render(
            entity=entity,
            action=action,
            steps_sql=steps_sql
        )

    def generate_step_sql(self, step: ActionStep, entity: Entity) -&gt; str:
        &quot;&quot;&quot;
        Generate SQL for single action step

        Converts SpecQL DSL to PL/pgSQL
        &quot;&quot;&quot;
        if step.type == 'validate':
            return self._generate_validate_sql(step)

        elif step.type == 'if':
            return self._generate_if_sql(step, entity)

        elif step.type == 'insert':
            return self._generate_insert_sql(step, entity)

        elif step.type == 'update':
            return self._generate_update_sql(step, entity)

        elif step.type == 'find':
            return self._generate_find_sql(step)

        elif step.type == 'call':
            return self._generate_call_sql(step)

        elif step.type == 'reject':
            return f&quot;RETURN error('{step.error}');&quot;

        else:
            raise ValueError(f&quot;Unknown step type: {step.type}&quot;)

    def _generate_validate_sql(self, step: ActionStep) -&gt; str:
        &quot;&quot;&quot;Generate validation SQL&quot;&quot;&quot;
        # Convert SpecQL expression to SQL
        sql_expression = self._convert_expression_to_sql(step.expression)

        return f&quot;&quot;&quot;
-- Validation: {step.expression}
IF NOT ({sql_expression}) THEN
    RETURN error('{step.error}',
        message =&gt; 'Validation failed: {step.expression}',
        field =&gt; '{self._extract_field_name(step.expression)}'
    );
END IF;
&quot;&quot;&quot;

    def _generate_if_sql(self, step: ActionStep, entity: Entity) -&gt; str:
        &quot;&quot;&quot;Generate if-then-else SQL&quot;&quot;&quot;
        condition_sql = self._convert_expression_to_sql(step.condition)

        then_sql = '\n'.join([
            self.generate_step_sql(s, entity) for s in step.then_steps
        ])

        if step.else_steps:
            else_sql = '\n'.join([
                self.generate_step_sql(s, entity) for s in step.else_steps
            ])
            return f&quot;&quot;&quot;
IF ({condition_sql}) THEN
    {self._indent(then_sql)}
ELSE
    {self._indent(else_sql)}
END IF;
&quot;&quot;&quot;
        else:
            return f&quot;&quot;&quot;
IF ({condition_sql}) THEN
    {self._indent(then_sql)}
END IF;
&quot;&quot;&quot;

    def _generate_insert_sql(self, step: ActionStep, entity: Entity) -&gt; str:
        &quot;&quot;&quot;Generate INSERT SQL&quot;&quot;&quot;
        table_name = f&quot;{entity.schema}.tb_{step.entity.lower()}&quot;

        if step.fields:
            # Explicit fields
            field_names = ', '.join(step.fields.keys())
            field_values = ', '.join(step.fields.values())

            return f&quot;&quot;&quot;
-- Insert into {step.entity}
INSERT INTO {table_name} ({field_names})
VALUES ({field_values})
RETURNING * INTO v_result;
&quot;&quot;&quot;
        else:
            # All fields from input
            return f&quot;&quot;&quot;
-- Insert into {step.entity}
INSERT INTO {table_name}
SELECT * FROM jsonb_populate_record(NULL::{table_name}, p_input)
RETURNING * INTO v_result;
&quot;&quot;&quot;

    def _generate_update_sql(self, step: ActionStep, entity: Entity) -&gt; str:
        &quot;&quot;&quot;Generate UPDATE SQL&quot;&quot;&quot;
        table_name = f&quot;{entity.schema}.tb_{step.entity.lower()}&quot;
        set_clause = step.fields.get('raw_set', '')
        where_clause = step.where_clause or 'TRUE'

        return f&quot;&quot;&quot;
-- Update {step.entity}
UPDATE {table_name}
SET {set_clause}
WHERE {where_clause};
&quot;&quot;&quot;

    def _generate_find_sql(self, step: ActionStep) -&gt; str:
        &quot;&quot;&quot;Generate SELECT/FIND SQL&quot;&quot;&quot;
        return f&quot;&quot;&quot;
-- Find {step.entity}
SELECT * INTO v_{step.entity}
FROM {step.entity}
WHERE {step.where_clause or 'TRUE'};
&quot;&quot;&quot;

    def _generate_call_sql(self, step: ActionStep) -&gt; str:
        &quot;&quot;&quot;Generate function call SQL&quot;&quot;&quot;
        args = ', '.join([
            f&quot;{k} =&gt; {v}&quot; for k, v in (step.arguments or {}).items()
        ])

        if step.store_result:
            return f&quot;&quot;&quot;
-- Call {step.function_name}
SELECT {step.function_name}({args}) INTO v_{step.store_result};
&quot;&quot;&quot;
        else:
            return f&quot;&quot;&quot;
-- Call {step.function_name}
PERFORM {step.function_name}({args});
&quot;&quot;&quot;

    def _convert_expression_to_sql(self, expression: str) -&gt; str:
        &quot;&quot;&quot;
        Convert SpecQL expression to SQL

        Examples:
        - email MATCHES email_pattern â†’ email ~ email_pattern
        - status IN allowed_statuses â†’ status = ANY(allowed_statuses)
        - reserved_from &lt;= reserved_until â†’ (same)
        &quot;&quot;&quot;
        # Replace MATCHES with SQL regex operator
        expression = expression.replace(' MATCHES ', ' ~ ')

        # Replace input.field with p_input-&gt;'field'
        expression = re.sub(
            r'\binput\.(\w+)',
            r&quot;p_input-&gt;'\1'&quot;,
            expression
        )

        return expression

    def _extract_field_name(self, expression: str) -&gt; str:
        &quot;&quot;&quot;Extract primary field name from expression&quot;&quot;&quot;
        # Simple heuristic: first word
        match = re.match(r'(\w+)', expression)
        return match.group(1) if match else 'unknown'

    def _indent(self, text: str, spaces: int = 4) -&gt; str:
        &quot;&quot;&quot;Indent text block&quot;&quot;&quot;
        indent = ' ' * spaces
        return '\n'.join([indent + line for line in text.split('\n')])
</code></pre>
<p>Create Jinja2 template:</p>
<pre><code class="language-jinja2">{# templates/specql_action_function.sql.j2 #}
-- ============================================================================
-- SpecQL Action Function: {{ entity.schema }}.{{ action.name }}
-- ============================================================================
-- Auto-generated from SpecQL YAML definition
-- Entity: {{ entity.name }}
-- Action: {{ action.name }}
-- ============================================================================

CREATE OR REPLACE FUNCTION {{ entity.schema }}.fn_{{ action.name }}(
    p_input JSONB,
    p_caller JSONB DEFAULT '{}'::jsonb
)
RETURNS TABLE(
    success BOOLEAN,
    result JSONB,
    error TEXT,
    message TEXT
)
LANGUAGE plpgsql
AS $$
DECLARE
    v_result RECORD;
    {%- for field in entity.fields.values() %}
    v_{{ field.name }} {{ field.type | upper }};
    {%- endfor %}
BEGIN
    -- ========================================================================
    -- Permission Check
    -- ========================================================================
    {%- if action.requires %}
    IF NOT ({{ action.requires }}) THEN
        RETURN QUERY SELECT
            FALSE AS success,
            NULL::jsonb AS result,
            'permission_denied' AS error,
            'You do not have permission to perform this action' AS message;
        RETURN;
    END IF;
    {%- endif %}

    -- ========================================================================
    -- Extract Input Fields
    -- ========================================================================
    {%- for field in entity.fields.values() %}
    v_{{ field.name }} := (p_input-&gt;&gt;'{{ field.name }}')::{{ field.type | upper }};
    {%- endfor %}

    -- ========================================================================
    -- Business Logic Steps
    -- ========================================================================
    {%- for step_sql in steps_sql %}
    {{ step_sql }}
    {%- endfor %}

    -- ========================================================================
    -- Success Response
    -- ========================================================================
    RETURN QUERY SELECT
        TRUE AS success,
        to_jsonb(v_result) AS result,
        NULL::text AS error,
        'Action completed successfully' AS message;

    -- ========================================================================
    -- Audit Log (Framework)
    -- ========================================================================
    INSERT INTO audit.tb_audit_log (
        entity_name,
        action_name,
        caller_id,
        input_data,
        result_data,
        timestamp
    ) VALUES (
        '{{ entity.name }}',
        '{{ action.name }}',
        (p_caller-&gt;&gt;'user_id')::uuid,
        p_input,
        to_jsonb(v_result),
        now()
    );

    -- ========================================================================
    -- Event Emission (Framework)
    -- ========================================================================
    PERFORM emit_event(
        event_type =&gt; '{{ entity.name.lower() }}.{{ action.name }}',
        event_data =&gt; to_jsonb(v_result)
    );

EXCEPTION
    WHEN OTHERS THEN
        -- Framework-level exception handling
        RETURN QUERY SELECT
            FALSE AS success,
            NULL::jsonb AS result,
            SQLSTATE AS error,
            SQLERRM AS message;
END;
$$;

COMMENT ON FUNCTION {{ entity.schema }}.fn_{{ action.name }}(JSONB, JSONB) IS
'{{ action.name }} - Auto-generated from SpecQL';

-- ============================================================================
-- FraiseQL Metadata Annotation
-- ============================================================================
COMMENT ON FUNCTION {{ entity.schema }}.fn_{{ action.name }}(JSONB, JSONB) IS
'@fraiseql:mutation
name: {{ action.name }}
input_type: {{ entity.name }}Input
output_type: {{ entity.name }}Result
';
</code></pre>
<hr />
<h4 id="refactor-phase">ğŸ”§ REFACTOR Phase</h4>
<p><strong>Time</strong>: 4 hours</p>
<ul>
<li>Extract SQL generation helpers to utility module</li>
<li>Add expression parser for complex SpecQL syntax</li>
<li>Support for switch/case statements</li>
<li>Better error messages with line numbers</li>
</ul>
<hr />
<h4 id="qa-phase">âœ… QA Phase</h4>
<p><strong>Time</strong>: 3 hours</p>
<pre><code class="language-bash"># Integration test: Parse YAML â†’ Generate SQL â†’ Apply to DB
uv run pytest tests/integration/test_specql_end_to_end.py -v

# Check generated SQL is valid
uv run python -m src.validate_sql generated/
</code></pre>
<hr />
<h3 id="phase-1-deliverables">Phase 1 Deliverables</h3>
<p><strong>Completion Checklist:</strong>
- [ ] SpecQLParser with full action step DSL support
- [ ] SpecQLSQLGenerator generates valid PL/pgSQL
- [ ] Support for: validate, if/then/else, insert, update, delete, find, call
- [ ] Framework annotations (permissions, audit, events)
- [ ] FraiseQL COMMENT annotations
- [ ] Tests coverage &gt; 90%
- [ ] Example entity (Contact) parses and generates</p>
<p><strong>Acceptance Test:</strong></p>
<pre><code class="language-bash"># Parse SpecQL YAML
python -c &quot;
from src.specql_parser import SpecQLParser
entity = SpecQLParser().parse(open('entities/contact.yaml').read())
print(f'Parsed entity: {entity.name}')
print(f'Actions: {len(entity.actions)}')
print(f'Fields: {len(entity.fields)}')
&quot;

# Generate SQL
python generate_specql_sql.py --entity contact

# Verify SQL syntax
psql -d test_db --dry-run &lt; generated/03_functions/.../fn_create_contact.sql
</code></pre>
<hr />
<h2 id="phase-2-table-view-generation-with-trinity-pattern-week-3-4">PHASE 2: Table + View Generation with Trinity Pattern (Week 3-4)</h2>
<p><strong>Objective</strong>: Generate PostgreSQL tables and views from SpecQL entities
<strong>Duration</strong>: 50 hours</p>
<h3 id="iteration-21-trinity-pattern-table-generator">Iteration 2.1: Trinity Pattern Table Generator</h3>
<h3 id="iteration-22-group-leader-trigger-integration">Iteration 2.2: Group Leader Trigger Integration</h3>
<h3 id="iteration-23-fraiseql-view-generation">Iteration 2.3: FraiseQL View Generation</h3>
<h3 id="iteration-24-type-resolution-system">Iteration 2.4: Type Resolution System</h3>
<p>(Detailed implementation similar to Phase 1 structure)</p>
<hr />
<h2 id="phase-3-numbering-system-manifest-week-5-6">PHASE 3: Numbering System + Manifest (Week 5-6)</h2>
<p><strong>Objective</strong>: Integrate materialized numbering and execution order
<strong>Duration</strong>: 40 hours</p>
<p>(Implementation details as per original plan, adapted for SpecQL)</p>
<hr />
<h2 id="phase-4-ai-agent-runtime-week-7-8">PHASE 4: AI Agent Runtime (Week 7-8)</h2>
<p><strong>Objective</strong>: Implement AI agent sandbox and execution
<strong>Duration</strong>: 60 hours</p>
<h3 id="agent-capabilities">Agent Capabilities</h3>
<ul>
<li>[ ] Event observation and triggering</li>
<li>[ ] Controlled action execution</li>
<li>[ ] LLM integration (OpenAI, Anthropic)</li>
<li>[ ] Audit trail for all agent actions</li>
<li>[ ] Safety constraints and quotas</li>
</ul>
<hr />
<h2 id="phase-5-production-polish-week-9-10">PHASE 5: Production Polish (Week 9-10)</h2>
<p><strong>Objective</strong>: Migration tools, documentation, testing
<strong>Duration</strong>: 80 hours</p>
<h3 id="deliverables">Deliverables</h3>
<ul>
<li>[ ] Migration tool (existing SQL â†’ SpecQL YAML)</li>
<li>[ ] Health check system</li>
<li>[ ] Auto-generated test suites</li>
<li>[ ] API documentation</li>
<li>[ ] Team training materials</li>
</ul>
<hr />
<h2 id="success-metrics">Success Metrics</h2>
<h3 id="overall-success-criteria">Overall Success Criteria</h3>
<ul>
<li>[ ] Parse SpecQL YAML (40-60 lines) â†’ Generate 2000+ lines SQL</li>
<li>[ ] 75-80% reduction in YAML verbosity vs previous approach</li>
<li>[ ] FraiseQL auto-discovers types and mutations</li>
<li>[ ] AI agents can observe and execute actions</li>
<li>[ ] Full backend generated in &lt; 10 minutes from YAML</li>
</ul>
<hr />
<h2 id="estimated-timeline">Estimated Timeline</h2>
<table>
<thead>
<tr>
<th>Phase</th>
<th>Duration</th>
<th>Hours</th>
<th>Deliverable</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Phase 1</strong></td>
<td>Week 1-2</td>
<td>50h</td>
<td>SpecQL Parser + SQL Generator</td>
</tr>
<tr>
<td><strong>Phase 2</strong></td>
<td>Week 3-4</td>
<td>50h</td>
<td>Trinity Tables + Views</td>
</tr>
<tr>
<td><strong>Phase 3</strong></td>
<td>Week 5-6</td>
<td>40h</td>
<td>Numbering + Manifest</td>
</tr>
<tr>
<td><strong>Phase 4</strong></td>
<td>Week 7-8</td>
<td>60h</td>
<td>AI Agent Runtime</td>
</tr>
<tr>
<td><strong>Phase 5</strong></td>
<td>Week 9-10</td>
<td>80h</td>
<td>Production Polish</td>
</tr>
<tr>
<td><strong>Total</strong></td>
<td>10 weeks</td>
<td>280h</td>
<td>Full SpecQL Platform</td>
</tr>
</tbody>
</table>
<hr />
<p><strong>Ready to begin Phase 1?</strong> ğŸš€</p>
<p>This plan implements the <strong>SpecQL vision</strong> of business-focused YAML with framework-generated infrastructure.</p>
              
            </div>
          </div><footer>

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
          
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="Versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    
    
    
  </span>
</div>
    <script src="../../js/jquery-3.6.0.min.js"></script>
    <script>var base_url = "../..";</script>
    <script src="../../js/theme_extra.js"></script>
    <script src="../../js/theme.js"></script>
      <script src="../../search/main.js"></script>
    <script>
        jQuery(function () {
            SphinxRtdTheme.Navigation.enable(true);
        });
    </script>

</body>
</html>
