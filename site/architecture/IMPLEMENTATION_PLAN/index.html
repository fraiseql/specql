<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
      <link rel="shortcut icon" href="../../img/favicon.ico" />
    <title>Implementation Plan: Numbering, Group Leader, and FraiseQL Integration - SpecQL Documentation</title>
    <link rel="stylesheet" href="../../css/theme.css" />
    <link rel="stylesheet" href="../../css/theme_extra.css" />
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github.min.css" />
    
      <script>
        // Current page data
        var mkdocs_page_name = "Implementation Plan: Numbering, Group Leader, and FraiseQL Integration";
        var mkdocs_page_input_path = "architecture/IMPLEMENTATION_PLAN.md";
        var mkdocs_page_url = null;
      </script>
    
    <!--[if lt IE 9]>
      <script src="../../js/html5shiv.min.js"></script>
    <![endif]-->
      <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
      <script>hljs.highlightAll();</script> 
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
          <a href="../.." class="icon icon-home"> SpecQL Documentation
        </a><div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../../search.html" method="get">
      <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../..">Home</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="" href="../../getting-started/">Getting Started</a>
                </li>
              </ul>
              <p class="caption"><span class="caption-text">Guides</span></p>
              <ul>
                  <li class="toctree-l1"><a class="" href="../../guides/mutation-patterns/">Mutation Patterns</a>
                  </li>
                  <li class="toctree-l1"><a class="" href="../../guides/test-generation/">Test Generation</a>
                  </li>
                  <li class="toctree-l1"><a class="" href="../../guides/cli/">CLI</a>
                  </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="" href="../../reference/">Reference</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="" href="../../examples/">Examples</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="" href="../../tutorials/">Tutorials</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="" href="../../best-practices/">Best Practices</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="" href="../../troubleshooting/">Troubleshooting</a>
                </li>
              </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">
      <nav class="wy-nav-top" role="navigation" aria-label="Mobile navigation menu">
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../..">SpecQL Documentation</a>
        
      </nav>
      <div class="wy-nav-content">
        <div class="rst-content"><div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../.." class="icon icon-home" aria-label="Docs"></a></li>
      <li class="breadcrumb-item active">Implementation Plan: Numbering, Group Leader, and FraiseQL Integration</li>
    <li class="wy-breadcrumbs-aside">
    </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
            <div class="section" itemprop="articleBody">
              
                <h1 id="implementation-plan-numbering-group-leader-and-fraiseql-integration">Implementation Plan: Numbering, Group Leader, and FraiseQL Integration</h1>
<h2 id="overview">Overview</h2>
<p>This plan integrates three systems:
1. Materialized numbering system for hierarchical codes
2. Group leader pattern for data coherence
3. FraiseQL integration for GraphQL API generation</p>
<h2 id="timeline">Timeline</h2>
<ul>
<li>4 weeks total</li>
<li>4 development phases</li>
<li>~120 hours effort</li>
</ul>
<hr />
<h2 id="critical-success-factors">Critical Success Factors</h2>
<h3 id="pre-flight-checklist">Pre-Flight Checklist</h3>
<ul>
<li>[ ] Team approval obtained</li>
<li>[ ] Git repository backed up</li>
<li>[ ] Development environment ready (Python 3.8+, PostgreSQL 14+)</li>
<li>[ ] Test database instance available</li>
<li>[ ] CI/CD pipeline access confirmed</li>
</ul>
<h3 id="core-principles">Core Principles</h3>
<ol>
<li><strong>Test-Driven</strong>: Write failing tests â†’ Minimal implementation â†’ Refactor â†’ QA</li>
<li><strong>Incremental</strong>: Each phase delivers working features</li>
<li><strong>Reversible</strong>: Can rollback to previous phase at any time</li>
<li><strong>Validated</strong>: Every phase ends with working system</li>
</ol>
<hr />
<h2 id="phase-1-numbering-system-foundation-week-1">PHASE 1: Numbering System Foundation (Week 1)</h2>
<p><strong>Objective</strong>: Implement hierarchical numbering system with manifest generation
<strong>Duration</strong>: 30 hours
<strong>Complexity</strong>: Complex - Phased TDD</p>
<h3 id="phase-1-overview">Phase 1 Overview</h3>
<pre><code>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ INPUT: YAML with table_code                                 â”‚
â”‚   organization:                                             â”‚
â”‚     table_code: &quot;013211&quot;                                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                     â”‚
                     â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ OUTPUT: Numbered directory structure + manifest.yaml       â”‚
â”‚   01_write_side/013_catalog/0132_manufacturer/...          â”‚
â”‚   manifest.yaml (with execution order)                     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
</code></pre>
<hr />
<h3 id="iteration-11-numberingparser-tdd-cycle">Iteration 1.1: NumberingParser (TDD Cycle)</h3>
<h4 id="red-phase-write-failing-test">ğŸ”´ RED Phase - Write Failing Test</h4>
<p><strong>Time</strong>: 1 hour</p>
<pre><code class="language-python"># tests/test_numbering_parser.py
import pytest
from src.numbering_parser import NumberingParser

def test_parse_table_code_6_digit():
    &quot;&quot;&quot;Test parsing 6-digit table code into components&quot;&quot;&quot;
    parser = NumberingParser()
    result = parser.parse_table_code(&quot;013211&quot;)

    assert result == {
        'schema_layer': '01',      # write_side
        'domain_code': '3',        # catalog
        'entity_group': '2',       # manufacturer group
        'entity_code': '1',        # manufacturer entity
        'file_sequence': '1',      # first file
        'full_domain': '013',      # schema_layer + domain
        'full_group': '0132',      # + entity_group
        'full_entity': '01321'     # + entity_code
    }

def test_parse_invalid_code():
    &quot;&quot;&quot;Test error handling for invalid codes&quot;&quot;&quot;
    parser = NumberingParser()

    with pytest.raises(ValueError, match=&quot;Invalid table_code&quot;):
        parser.parse_table_code(&quot;12345&quot;)  # 5 digits

    with pytest.raises(ValueError, match=&quot;Invalid table_code&quot;):
        parser.parse_table_code(&quot;ABC123&quot;)  # Non-numeric

def test_generate_directory_path():
    &quot;&quot;&quot;Test directory path generation from table code&quot;&quot;&quot;
    parser = NumberingParser()
    path = parser.generate_directory_path(&quot;013211&quot;, &quot;manufacturer&quot;)

    expected = &quot;01_write_side/013_catalog/0132_manufacturer/01321_manufacturer&quot;
    assert path == expected

def test_generate_file_path():
    &quot;&quot;&quot;Test file path generation&quot;&quot;&quot;
    parser = NumberingParser()
    path = parser.generate_file_path(
        table_code=&quot;013211&quot;,
        entity_name=&quot;manufacturer&quot;,
        file_type=&quot;table&quot;
    )

    expected = &quot;01_write_side/013_catalog/0132_manufacturer/01321_manufacturer/013211_tb_manufacturer.sql&quot;
    assert path == expected
</code></pre>
<p><strong>Run test</strong> (expect failures):</p>
<pre><code class="language-bash">uv run pytest tests/test_numbering_parser.py -v
# Expected: FAILED - NumberingParser module not found
</code></pre>
<h4 id="green-phase-minimal-implementation">ğŸŸ¢ GREEN Phase - Minimal Implementation</h4>
<p><strong>Time</strong>: 2 hours</p>
<pre><code class="language-python"># src/numbering_parser.py
&quot;&quot;&quot;
Numbering System Parser
Parses 6-digit table codes into hierarchical components
&quot;&quot;&quot;
from typing import Dict
import re

class NumberingParser:
    &quot;&quot;&quot;Parse and validate materialized numbering codes&quot;&quot;&quot;

    LAYER_NAMES = {
        '01': 'write_side',
        '02': 'query_side',
        '03': 'functions',
        '09': 'testfoundry'
    }

    def parse_table_code(self, table_code: str) -&gt; Dict[str, str]:
        &quot;&quot;&quot;
        Parse 6-digit table code into components

        Format: LLDDGEF
        L = Schema Layer (01, 02, 03, 09)
        D = Domain Code (0-9)
        G = Entity Group (0-9)
        E = Entity Code (0-9)
        F = File Sequence (0-9)

        Example: 013211
        - 01 = write_side
        - 3 = catalog domain
        - 2 = manufacturer group
        - 1 = manufacturer entity
        - 1 = first file
        &quot;&quot;&quot;
        if not table_code:
            raise ValueError(&quot;table_code is required&quot;)

        if not re.match(r'^\d{6}$', table_code):
            raise ValueError(f&quot;Invalid table_code: {table_code}. Must be 6 digits.&quot;)

        schema_layer = table_code[0:2]
        domain_code = table_code[2]
        entity_group = table_code[3]
        entity_code = table_code[4]
        file_sequence = table_code[5]

        if schema_layer not in self.LAYER_NAMES:
            raise ValueError(f&quot;Invalid schema layer: {schema_layer}. Must be 01, 02, 03, or 09&quot;)

        return {
            'schema_layer': schema_layer,
            'domain_code': domain_code,
            'entity_group': entity_group,
            'entity_code': entity_code,
            'file_sequence': file_sequence,
            'full_domain': table_code[0:3],      # 013
            'full_group': table_code[0:4],        # 0132
            'full_entity': table_code[0:5]        # 01321
        }

    def generate_directory_path(self, table_code: str, entity_name: str) -&gt; str:
        &quot;&quot;&quot;Generate directory path from table code&quot;&quot;&quot;
        parsed = self.parse_table_code(table_code)

        layer_name = self.LAYER_NAMES[parsed['schema_layer']]

        path_parts = [
            f&quot;{parsed['schema_layer']}_{layer_name}&quot;,
            f&quot;{parsed['full_domain']}_catalog&quot;,  # TODO: Domain name mapping
            f&quot;{parsed['full_group']}_{entity_name}&quot;,
            f&quot;{parsed['full_entity']}_{entity_name}&quot;
        ]

        return '/'.join(path_parts)

    def generate_file_path(self, table_code: str, entity_name: str, file_type: str) -&gt; str:
        &quot;&quot;&quot;Generate full file path for entity file&quot;&quot;&quot;
        dir_path = self.generate_directory_path(table_code, entity_name)

        file_prefix_map = {
            'table': f'tb_{entity_name}.sql',
            'view': f'v_{entity_name}.sql',
            'function': f'fn_{entity_name}.sql'
        }

        filename = file_prefix_map.get(file_type, f'{entity_name}.sql')

        return f&quot;{dir_path}/{table_code}_{filename}&quot;
</code></pre>
<p><strong>Run test</strong>:</p>
<pre><code class="language-bash">uv run pytest tests/test_numbering_parser.py -v
# Expected: PASSED (all tests green)
</code></pre>
<h4 id="refactor-phase-clean-up">ğŸ”§ REFACTOR Phase - Clean Up</h4>
<p><strong>Time</strong>: 1 hour</p>
<p><strong>Improvements:</strong>
1. Add domain name mapping (not hardcoded "catalog")
2. Extract configuration to constants
3. Add comprehensive docstrings
4. Type hints for all methods</p>
<pre><code class="language-python"># src/numbering_parser.py (refactored)
from typing import Dict, Optional
from dataclasses import dataclass
import re

@dataclass
class TableCodeComponents:
    &quot;&quot;&quot;Parsed components of a table code&quot;&quot;&quot;
    schema_layer: str
    domain_code: str
    entity_group: str
    entity_code: str
    file_sequence: str
    full_domain: str
    full_group: str
    full_entity: str
    layer_name: str

    def to_dict(self) -&gt; Dict[str, str]:
        return {
            'schema_layer': self.schema_layer,
            'domain_code': self.domain_code,
            'entity_group': self.entity_group,
            'entity_code': self.entity_code,
            'file_sequence': self.file_sequence,
            'full_domain': self.full_domain,
            'full_group': self.full_group,
            'full_entity': self.full_entity
        }

class NumberingParser:
    &quot;&quot;&quot;Parse and validate materialized numbering codes&quot;&quot;&quot;

    LAYER_NAMES = {
        '01': 'write_side',
        '02': 'query_side',
        '03': 'functions',
        '09': 'testfoundry'
    }

    # Domain code to name mapping (extend as needed)
    DOMAIN_NAMES = {
        '0': 'common',
        '1': 'i18n',
        '2': 'management',
        '3': 'catalog',
        '4': 'dimension',
        '5': 'operations'
    }

    def __init__(self, domain_mapping: Optional[Dict[str, str]] = None):
        &quot;&quot;&quot;
        Initialize parser with optional domain mapping

        Args:
            domain_mapping: Custom domain code to name mapping
        &quot;&quot;&quot;
        self.domain_mapping = domain_mapping or self.DOMAIN_NAMES

    def parse_table_code(self, table_code: str) -&gt; Dict[str, str]:
        &quot;&quot;&quot;Parse 6-digit table code into components (backward compatible)&quot;&quot;&quot;
        components = self.parse_table_code_detailed(table_code)
        return components.to_dict()

    def parse_table_code_detailed(self, table_code: str) -&gt; TableCodeComponents:
        &quot;&quot;&quot;
        Parse 6-digit table code into structured components

        Format: LLDDGEF
        - LL = Schema Layer (01=write_side, 02=query_side, 03=functions, 09=testfoundry)
        - D = Domain Code (0-9)
        - G = Entity Group (0-9)
        - E = Entity Code (0-9)
        - F = File Sequence (0-9)

        Example: 013211
        - 01 = write_side layer
        - 3 = catalog domain
        - 2 = manufacturer group
        - 1 = manufacturer entity
        - 1 = first file in sequence

        Returns:
            TableCodeComponents with parsed values

        Raises:
            ValueError: If table_code is invalid
        &quot;&quot;&quot;
        if not table_code:
            raise ValueError(&quot;table_code is required&quot;)

        if not re.match(r'^\d{6}$', table_code):
            raise ValueError(
                f&quot;Invalid table_code: {table_code}. Must be exactly 6 digits.&quot;
            )

        schema_layer = table_code[0:2]

        if schema_layer not in self.LAYER_NAMES:
            raise ValueError(
                f&quot;Invalid schema layer: {schema_layer}. &quot;
                f&quot;Must be one of: {', '.join(self.LAYER_NAMES.keys())}&quot;
            )

        return TableCodeComponents(
            schema_layer=schema_layer,
            domain_code=table_code[2],
            entity_group=table_code[3],
            entity_code=table_code[4],
            file_sequence=table_code[5],
            full_domain=table_code[0:3],
            full_group=table_code[0:4],
            full_entity=table_code[0:5],
            layer_name=self.LAYER_NAMES[schema_layer]
        )

    def get_domain_name(self, domain_code: str) -&gt; str:
        &quot;&quot;&quot;
        Get domain name from domain code

        Args:
            domain_code: Single digit domain code

        Returns:
            Domain name (e.g., 'catalog', 'management')
        &quot;&quot;&quot;
        return self.domain_mapping.get(domain_code, f'domain_{domain_code}')

    def generate_directory_path(
        self,
        table_code: str,
        entity_name: str,
        domain_name: Optional[str] = None
    ) -&gt; str:
        &quot;&quot;&quot;
        Generate directory path from table code

        Args:
            table_code: 6-digit table code
            entity_name: Entity name (e.g., 'manufacturer')
            domain_name: Optional override for domain name

        Returns:
            Directory path (e.g., '01_write_side/013_catalog/0132_manufacturer/01321_manufacturer')
        &quot;&quot;&quot;
        components = self.parse_table_code_detailed(table_code)

        if domain_name is None:
            domain_name = self.get_domain_name(components.domain_code)

        return '/'.join([
            f&quot;{components.schema_layer}_{components.layer_name}&quot;,
            f&quot;{components.full_domain}_{domain_name}&quot;,
            f&quot;{components.full_group}_{entity_name}&quot;,
            f&quot;{components.full_entity}_{entity_name}&quot;
        ])

    def generate_file_path(
        self,
        table_code: str,
        entity_name: str,
        file_type: str,
        domain_name: Optional[str] = None
    ) -&gt; str:
        &quot;&quot;&quot;
        Generate full file path for entity file

        Args:
            table_code: 6-digit table code
            entity_name: Entity name
            file_type: Type of file ('table', 'view', 'function', etc.)
            domain_name: Optional domain name override

        Returns:
            Full file path including directory and filename
        &quot;&quot;&quot;
        dir_path = self.generate_directory_path(table_code, entity_name, domain_name)

        file_prefix_map = {
            'table': f'tb_{entity_name}.sql',
            'view': f'v_{entity_name}.sql',
            'function': f'fn_{entity_name}.sql',
            'mutation': f'fn_{entity_name}_mutation.sql',
            'test': f'test_{entity_name}.sql'
        }

        filename = file_prefix_map.get(file_type, f'{entity_name}.sql')

        return f&quot;{dir_path}/{table_code}_{filename}&quot;
</code></pre>
<p><strong>Run tests again</strong>:</p>
<pre><code class="language-bash">uv run pytest tests/test_numbering_parser.py -v --cov=src/numbering_parser
# Expected: PASSED with high coverage
</code></pre>
<h4 id="qa-phase-verify-quality">âœ… QA Phase - Verify Quality</h4>
<p><strong>Time</strong>: 30 minutes</p>
<pre><code class="language-bash"># Run full test suite
uv run pytest --tb=short

# Run linting
uv run ruff check src/

# Run type checking
uv run mypy src/

# Check test coverage
uv run pytest --cov=src --cov-report=html
</code></pre>
<p><strong>Quality Gates:</strong>
- [ ] All tests pass
- [ ] Code coverage &gt; 90%
- [ ] No linting errors
- [ ] Type checking passes
- [ ] Code reviewed (self or peer)</p>
<hr />
<h3 id="iteration-12-manifest-generator-tdd-cycle">Iteration 1.2: Manifest Generator (TDD Cycle)</h3>
<h4 id="red-phase-write-failing-test_1">ğŸ”´ RED Phase - Write Failing Test</h4>
<p><strong>Time</strong>: 1 hour</p>
<pre><code class="language-python"># tests/test_manifest_generator.py
import pytest
from pathlib import Path
from src.manifest_generator import ManifestGenerator

def test_create_empty_manifest():
    &quot;&quot;&quot;Test creating empty manifest structure&quot;&quot;&quot;
    generator = ManifestGenerator()
    manifest = generator.create_manifest()

    assert 'metadata' in manifest
    assert 'execution_order' in manifest
    assert 'entities' in manifest
    assert manifest['metadata']['total_entities'] == 0

def test_add_entity_to_manifest():
    &quot;&quot;&quot;Test adding entity files to manifest&quot;&quot;&quot;
    generator = ManifestGenerator()

    entity_def = {
        'name': 'manufacturer',
        'schema': 'catalog',
        'organization': {
            'table_code': '013211',
            'domain_code': '013'
        }
    }

    files = [
        {
            'code': '013211',
            'path': '01_write_side/.../013211_tb_manufacturer.sql',
            'type': 'table',
            'dependencies': []
        },
        {
            'code': '013212',
            'path': '01_write_side/.../013212_fn_manufacturer_pk.sql',
            'type': 'function',
            'dependencies': ['013211']
        }
    ]

    generator.add_entity(entity_def, files)
    manifest = generator.create_manifest()

    assert manifest['metadata']['total_entities'] == 1
    assert manifest['metadata']['total_files'] == 2
    assert len(manifest['execution_order']) == 2
    assert manifest['execution_order'][0]['code'] == '013211'
    assert manifest['execution_order'][1]['code'] == '013212'

def test_execution_order_sorting():
    &quot;&quot;&quot;Test that execution order respects dependencies&quot;&quot;&quot;
    generator = ManifestGenerator()

    # Add files in random order
    generator.add_file({
        'code': '013213',
        'dependencies': ['013211', '013212']
    })
    generator.add_file({
        'code': '013211',
        'dependencies': []
    })
    generator.add_file({
        'code': '013212',
        'dependencies': ['013211']
    })

    manifest = generator.create_manifest()
    order = [f['code'] for f in manifest['execution_order']]

    # Should be sorted by dependencies, then by code
    assert order == ['013211', '013212', '013213']

def test_circular_dependency_detection():
    &quot;&quot;&quot;Test detection of circular dependencies&quot;&quot;&quot;
    generator = ManifestGenerator()

    generator.add_file({'code': '013211', 'dependencies': ['013212']})
    generator.add_file({'code': '013212', 'dependencies': ['013211']})

    with pytest.raises(ValueError, match=&quot;Circular dependency&quot;):
        generator.create_manifest()

def test_export_to_yaml(tmp_path):
    &quot;&quot;&quot;Test exporting manifest to YAML file&quot;&quot;&quot;
    generator = ManifestGenerator()
    generator.add_file({'code': '013211', 'dependencies': []})

    output_file = tmp_path / &quot;manifest.yaml&quot;
    generator.export_yaml(output_file)

    assert output_file.exists()

    # Verify content
    import yaml
    with open(output_file) as f:
        data = yaml.safe_load(f)

    assert 'metadata' in data
    assert 'execution_order' in data
</code></pre>
<p><strong>Run test</strong>:</p>
<pre><code class="language-bash">uv run pytest tests/test_manifest_generator.py -v
# Expected: FAILED - ManifestGenerator not found
</code></pre>
<h4 id="green-phase-minimal-implementation_1">ğŸŸ¢ GREEN Phase - Minimal Implementation</h4>
<p><strong>Time</strong>: 3 hours</p>
<pre><code class="language-python"># src/manifest_generator.py
&quot;&quot;&quot;
Manifest Generator
Creates manifest.yaml with execution order and entity metadata
&quot;&quot;&quot;
from typing import List, Dict, Any, Optional, Set
from pathlib import Path
from datetime import datetime
import yaml

class ManifestGenerator:
    &quot;&quot;&quot;Generate manifest.yaml with execution order&quot;&quot;&quot;

    def __init__(self):
        self.entities: Dict[str, Dict] = {}
        self.files: List[Dict] = []
        self.version = &quot;2.0.0&quot;

    def add_entity(self, entity_def: Dict, files: List[Dict]):
        &quot;&quot;&quot;
        Add entity to manifest

        Args:
            entity_def: Entity definition from YAML
            files: List of file metadata dictionaries
        &quot;&quot;&quot;
        entity_name = entity_def['name']

        self.entities[entity_name] = {
            'table_code': entity_def['organization']['table_code'],
            'schema': entity_def['schema'],
            'description': entity_def.get('description', ''),
            'files': [f['path'] for f in files]
        }

        self.files.extend(files)

    def add_file(self, file_metadata: Dict):
        &quot;&quot;&quot;Add single file to manifest&quot;&quot;&quot;
        self.files.append(file_metadata)

    def _topological_sort(self, files: List[Dict]) -&gt; List[Dict]:
        &quot;&quot;&quot;
        Sort files by dependencies using topological sort

        Raises:
            ValueError: If circular dependency detected
        &quot;&quot;&quot;
        # Build dependency graph
        graph = {f['code']: f.get('dependencies', []) for f in files}
        file_map = {f['code']: f for f in files}

        # Detect cycles
        visited = set()
        rec_stack = set()

        def has_cycle(node: str) -&gt; bool:
            visited.add(node)
            rec_stack.add(node)

            for neighbor in graph.get(node, []):
                if neighbor not in visited:
                    if has_cycle(neighbor):
                        return True
                elif neighbor in rec_stack:
                    return True

            rec_stack.remove(node)
            return False

        for node in graph:
            if node not in visited:
                if has_cycle(node):
                    raise ValueError(f&quot;Circular dependency detected involving: {node}&quot;)

        # Topological sort (Kahn's algorithm)
        in_degree = {code: 0 for code in graph}
        for code, deps in graph.items():
            for dep in deps:
                if dep in in_degree:
                    in_degree[dep] += 1

        queue = [code for code, degree in in_degree.items() if degree == 0]
        sorted_codes = []

        while queue:
            # Sort queue to ensure deterministic ordering
            queue.sort()
            code = queue.pop(0)
            sorted_codes.append(code)

            for other_code, deps in graph.items():
                if code in deps:
                    in_degree[other_code] -= 1
                    if in_degree[other_code] == 0:
                        queue.append(other_code)

        # Convert codes back to file objects
        return [file_map[code] for code in sorted_codes]

    def create_manifest(self) -&gt; Dict[str, Any]:
        &quot;&quot;&quot;
        Create manifest dictionary

        Returns:
            Manifest dictionary ready for YAML export
        &quot;&quot;&quot;
        # Sort files by dependencies
        if self.files:
            sorted_files = self._topological_sort(self.files)
        else:
            sorted_files = []

        return {
            'metadata': {
                'generated_at': datetime.utcnow().isoformat() + 'Z',
                'generator_version': self.version,
                'total_entities': len(self.entities),
                'total_files': len(sorted_files)
            },
            'execution_order': sorted_files,
            'entities': self.entities
        }

    def export_yaml(self, output_path: Path):
        &quot;&quot;&quot;
        Export manifest to YAML file

        Args:
            output_path: Path to output manifest.yaml
        &quot;&quot;&quot;
        manifest = self.create_manifest()

        output_path.parent.mkdir(parents=True, exist_ok=True)

        with open(output_path, 'w') as f:
            yaml.dump(
                manifest,
                f,
                default_flow_style=False,
                sort_keys=False,
                allow_unicode=True
            )
</code></pre>
<p><strong>Run test</strong>:</p>
<pre><code class="language-bash">uv run pytest tests/test_manifest_generator.py -v
# Expected: PASSED
</code></pre>
<h4 id="refactor-phase">ğŸ”§ REFACTOR Phase</h4>
<p><strong>Time</strong>: 1 hour</p>
<p>Add better error messages, extract constants, improve algorithm efficiency.</p>
<h4 id="qa-phase">âœ… QA Phase</h4>
<p><strong>Time</strong>: 30 minutes</p>
<pre><code class="language-bash">uv run pytest tests/test_manifest_generator.py -v --cov=src/manifest_generator
uv run ruff check src/
uv run mypy src/
</code></pre>
<hr />
<h3 id="iteration-13-directory-structure-generator-tdd-cycle">Iteration 1.3: Directory Structure Generator (TDD Cycle)</h3>
<h4 id="red-phase">ğŸ”´ RED Phase</h4>
<p><strong>Time</strong>: 1 hour</p>
<pre><code class="language-python"># tests/test_directory_generator.py
import pytest
from pathlib import Path
from src.directory_generator import DirectoryGenerator

def test_create_entity_directories(tmp_path):
    &quot;&quot;&quot;Test creating full directory structure for entity&quot;&quot;&quot;
    generator = DirectoryGenerator(output_dir=tmp_path)

    entity_def = {
        'name': 'manufacturer',
        'organization': {'table_code': '013211'}
    }

    paths = generator.create_entity_directories(entity_def)

    # Check all directories created
    expected_base = tmp_path / &quot;01_write_side/013_catalog/0132_manufacturer/01321_manufacturer&quot;
    assert expected_base.exists()
    assert expected_base.is_dir()

    # Check README.md created
    readme = expected_base / &quot;README.md&quot;
    assert readme.exists()

def test_generate_entity_readme(tmp_path):
    &quot;&quot;&quot;Test README.md generation for entity&quot;&quot;&quot;
    generator = DirectoryGenerator(output_dir=tmp_path)

    entity_def = {
        'name': 'manufacturer',
        'schema': 'catalog',
        'description': 'Printer manufacturers',
        'organization': {'table_code': '013211'}
    }

    readme_content = generator.generate_entity_readme(entity_def)

    assert '# 01321 - Manufacturer' in readme_content
    assert 'Table Code: 013211' in readme_content
    assert 'Schema: catalog' in readme_content
    assert 'Printer manufacturers' in readme_content

def test_create_all_layers(tmp_path):
    &quot;&quot;&quot;Test creating directories for all schema layers&quot;&quot;&quot;
    generator = DirectoryGenerator(output_dir=tmp_path)

    entity_def = {
        'name': 'manufacturer',
        'organization': {'table_code': '013211'}
    }

    # Generate for multiple layers
    generator.create_layer_directories(entity_def, layers=['01', '02', '03', '09'])

    # Check all layers exist
    assert (tmp_path / &quot;01_write_side&quot;).exists()
    assert (tmp_path / &quot;02_query_side&quot;).exists()
    assert (tmp_path / &quot;03_functions&quot;).exists()
    assert (tmp_path / &quot;09_testfoundry&quot;).exists()
</code></pre>
<h4 id="green-phase">ğŸŸ¢ GREEN Phase</h4>
<p><strong>Time</strong>: 2 hours</p>
<pre><code class="language-python"># src/directory_generator.py
from pathlib import Path
from typing import Dict, List
from src.numbering_parser import NumberingParser

class DirectoryGenerator:
    &quot;&quot;&quot;Generate directory structure with README files&quot;&quot;&quot;

    def __init__(self, output_dir: Path = Path('generated')):
        self.output_dir = Path(output_dir)
        self.parser = NumberingParser()

    def create_entity_directories(self, entity_def: Dict) -&gt; Dict[str, Path]:
        &quot;&quot;&quot;Create all directories for an entity&quot;&quot;&quot;
        table_code = entity_def['organization']['table_code']
        entity_name = entity_def['name']

        # Get domain name if specified
        domain_name = entity_def.get('organization', {}).get('domain_name')

        dir_path = self.parser.generate_directory_path(
            table_code, entity_name, domain_name
        )

        full_path = self.output_dir / dir_path
        full_path.mkdir(parents=True, exist_ok=True)

        # Generate README
        readme_content = self.generate_entity_readme(entity_def)
        readme_path = full_path / &quot;README.md&quot;
        readme_path.write_text(readme_content)

        return {
            'base': full_path,
            'readme': readme_path
        }

    def generate_entity_readme(self, entity_def: Dict) -&gt; str:
        &quot;&quot;&quot;Generate README.md content for entity&quot;&quot;&quot;
        table_code = entity_def['organization']['table_code']
        components = self.parser.parse_table_code(table_code)
        entity_name = entity_def['name']

        return f&quot;&quot;&quot;# {components['full_entity']} - {entity_name.title()}

**Table Code**: {table_code}
**Schema**: {entity_def.get('schema', 'N/A')}
**Layer**: {components['schema_layer']} ({self.parser.LAYER_NAMES[components['schema_layer']]})
**Domain**: {components['full_domain']}

## Description

{entity_def.get('description', 'No description provided.')}

## Files

Generated files for this entity will appear here.

## Generated

This documentation was auto-generated on {datetime.utcnow().strftime('%Y-%m-%d')}.
&quot;&quot;&quot;

    def create_layer_directories(self, entity_def: Dict, layers: List[str]):
        &quot;&quot;&quot;Create directories across multiple schema layers&quot;&quot;&quot;
        for layer in layers:
            # Modify table_code to use this layer
            original_code = entity_def['organization']['table_code']
            layer_code = layer + original_code[2:]

            temp_def = entity_def.copy()
            temp_def['organization'] = entity_def['organization'].copy()
            temp_def['organization']['table_code'] = layer_code

            self.create_entity_directories(temp_def)
</code></pre>
<h4 id="refactor-phase_1">ğŸ”§ REFACTOR Phase</h4>
<p><strong>Time</strong>: 1 hour</p>
<h4 id="qa-phase_1">âœ… QA Phase</h4>
<p><strong>Time</strong>: 30 minutes</p>
<hr />
<h3 id="iteration-14-integration-with-sqlgenerator-tdd-cycle">Iteration 1.4: Integration with SQLGenerator (TDD Cycle)</h3>
<h4 id="red-phase_1">ğŸ”´ RED Phase</h4>
<p><strong>Time</strong>: 1 hour</p>
<p>Update existing tests to expect numbered output:</p>
<pre><code class="language-python"># tests/test_sql_generator_integration.py
def test_generate_with_numbering_system(tmp_path):
    &quot;&quot;&quot;Test SQL generation with numbering system&quot;&quot;&quot;
    generator = SQLGenerator(output_dir=tmp_path)

    entity_file = create_test_entity_yaml({
        'name': 'manufacturer',
        'organization': {'table_code': '013211'},
        'schema': 'catalog'
    })

    result = generator.generate_entity(entity_file)

    # Check files in numbered directories
    expected_table = (
        tmp_path / &quot;01_write_side/013_catalog/0132_manufacturer/&quot;
        &quot;01321_manufacturer/013211_tb_manufacturer.sql&quot;
    )
    assert expected_table.exists()

    # Check manifest generated
    manifest = tmp_path / &quot;manifest.yaml&quot;
    assert manifest.exists()
</code></pre>
<h4 id="green-phase_1">ğŸŸ¢ GREEN Phase</h4>
<p><strong>Time</strong>: 3 hours</p>
<p>Update <code>scripts/dev/generate_sql.py</code> to use new numbering system:</p>
<pre><code class="language-python"># src/sql_generator.py (updated)
class SQLGenerator:
    def __init__(self, templates_dir='templates', entities_dir='entities', output_dir='generated'):
        self.templates_dir = Path(templates_dir)
        self.entities_dir = Path(entities_dir)
        self.output_dir = Path(output_dir)

        # NEW: Add numbering and directory generators
        self.numbering_parser = NumberingParser()
        self.directory_generator = DirectoryGenerator(output_dir)
        self.manifest_generator = ManifestGenerator()

        self.env = Environment(
            loader=FileSystemLoader(str(self.templates_dir)),
            trim_blocks=True,
            lstrip_blocks=True
        )

    def generate_entity(self, entity_file):
        &quot;&quot;&quot;Generate all SQL for a single entity with numbering&quot;&quot;&quot;
        entity = self.load_entity(entity_file)

        # Create numbered directory structure
        directories = self.directory_generator.create_entity_directories(entity)

        # Generate table SQL
        table_sql = self.generate_table(entity)

        # Write to numbered path
        table_code = entity['organization']['table_code']
        file_path = self.numbering_parser.generate_file_path(
            table_code,
            entity['name'],
            'table'
        )

        full_path = self.output_dir / file_path
        full_path.parent.mkdir(parents=True, exist_ok=True)
        full_path.write_text(table_sql)

        # Add to manifest
        self.manifest_generator.add_file({
            'code': table_code,
            'path': str(file_path),
            'entity': entity['name'],
            'type': 'table',
            'schema': entity['schema'],
            'dependencies': []
        })

        return {'table_path': full_path}

    def generate_all(self):
        &quot;&quot;&quot;Generate SQL for all entities and create manifest&quot;&quot;&quot;
        entity_files = sorted(self.entities_dir.glob('*.yaml'))

        for entity_file in entity_files:
            self.generate_entity(entity_file)

        # Export manifest
        manifest_path = self.output_dir / 'manifest.yaml'
        self.manifest_generator.export_yaml(manifest_path)

        print(f&quot;âœ… Generated manifest: {manifest_path}&quot;)
</code></pre>
<h4 id="refactor-phase_2">ğŸ”§ REFACTOR Phase</h4>
<p><strong>Time</strong>: 2 hours</p>
<h4 id="qa-phase_2">âœ… QA Phase</h4>
<p><strong>Time</strong>: 1 hour</p>
<p><strong>Quality Gates:</strong>
- [ ] All tests pass
- [ ] Numbered directories created correctly
- [ ] Manifest.yaml generated with correct execution order
- [ ] Existing POC still works
- [ ] README.md files auto-generated</p>
<hr />
<h3 id="phase-1-deliverables">Phase 1 Deliverables</h3>
<p><strong>Completion Checklist:</strong>
- [ ] NumberingParser class with tests (&gt;90% coverage)
- [ ] ManifestGenerator class with tests
- [ ] DirectoryGenerator class with tests
- [ ] SQLGenerator updated to use numbering system
- [ ] Generated output follows numbered hierarchy
- [ ] manifest.yaml auto-generated
- [ ] Entity README.md files auto-generated
- [ ] All existing POC tests still pass
- [ ] Documentation updated</p>
<p><strong>Acceptance Test:</strong></p>
<pre><code class="language-bash"># Run full generation
python scripts/dev/generate_sql.py

# Verify output structure
ls -R generated/
# Should show:
#   01_write_side/013_catalog/0132_manufacturer/01321_manufacturer/013211_tb_manufacturer.sql
#   manifest.yaml
#   01_write_side/013_catalog/0132_manufacturer/01321_manufacturer/README.md

# Verify manifest
cat generated/manifest.yaml
# Should show execution_order with dependencies
</code></pre>
<p><strong>Exit Criteria:</strong>
- [ ] Can generate numbered SQL from YAML
- [ ] Manifest validates and executes in order
- [ ] Team review and approval</p>
<hr />
<h2 id="phase-2-group-leader-pattern-week-2">PHASE 2: Group Leader Pattern (Week 2)</h2>
<p><strong>Objective</strong>: Implement group leader pattern with trigger generation
<strong>Duration</strong>: 30 hours
<strong>Complexity</strong>: Complex - Phased TDD</p>
<h3 id="phase-2-overview">Phase 2 Overview</h3>
<pre><code>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ INPUT: YAML with field_groups                               â”‚
â”‚   field_groups:                                             â”‚
â”‚     - group_leader: fk_company                              â”‚
â”‚       dependent_fields: [company_country]                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                     â”‚
                     â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ OUTPUT: SQL table with triggers                             â”‚
â”‚   - Dependent fields added to table                         â”‚
â”‚   - Trigger function to populate fields                     â”‚
â”‚   - Trigger on INSERT/UPDATE                                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
</code></pre>
<hr />
<h3 id="iteration-21-group-leader-validator-tdd-cycle">Iteration 2.1: Group Leader Validator (TDD Cycle)</h3>
<h4 id="red-phase_2">ğŸ”´ RED Phase</h4>
<p><strong>Time</strong>: 1 hour</p>
<pre><code class="language-python"># tests/test_group_leader_validator.py
def test_validate_group_leader_exists():
    &quot;&quot;&quot;Test validation that group leader field exists&quot;&quot;&quot;
    validator = GroupLeaderValidator()

    entity_def = {
        'foreign_keys': {'fk_company': {...}},
        'field_groups': [
            {'group_leader': 'fk_company', 'dependent_fields': ['country']}
        ]
    }

    # Should not raise
    validator.validate(entity_def)

def test_validate_group_leader_missing():
    &quot;&quot;&quot;Test error when group leader doesn't exist&quot;&quot;&quot;
    validator = GroupLeaderValidator()

    entity_def = {
        'foreign_keys': {},
        'field_groups': [
            {'group_leader': 'fk_missing', 'dependent_fields': ['country']}
        ]
    }

    with pytest.raises(ValueError, match=&quot;Group leader.*not found&quot;):
        validator.validate(entity_def)

def test_validate_dependent_field_not_in_base_fields():
    &quot;&quot;&quot;Test that dependent fields aren't already defined&quot;&quot;&quot;
    validator = GroupLeaderValidator()

    entity_def = {
        'fields': {'country': {'type': 'TEXT'}},
        'foreign_keys': {'fk_company': {...}},
        'field_groups': [
            {'group_leader': 'fk_company', 'dependent_fields': ['country']}
        ]
    }

    with pytest.raises(ValueError, match=&quot;Dependent field.*already defined&quot;):
        validator.validate(entity_def)
</code></pre>
<h4 id="green-phase_2">ğŸŸ¢ GREEN Phase</h4>
<p><strong>Time</strong>: 2 hours</p>
<pre><code class="language-python"># src/group_leader_validator.py
class GroupLeaderValidator:
    &quot;&quot;&quot;Validate group leader configuration in entity definitions&quot;&quot;&quot;

    def validate(self, entity_def: Dict) -&gt; None:
        &quot;&quot;&quot;
        Validate group leader configuration

        Raises:
            ValueError: If configuration is invalid
        &quot;&quot;&quot;
        field_groups = entity_def.get('field_groups', [])

        for group in field_groups:
            self._validate_group(group, entity_def)

    def _validate_group(self, group: Dict, entity_def: Dict) -&gt; None:
        &quot;&quot;&quot;Validate a single field group&quot;&quot;&quot;
        leader = group.get('group_leader')
        dependents = group.get('dependent_fields', [])

        if not leader:
            raise ValueError(&quot;group_leader is required in field_groups&quot;)

        # Check leader exists in foreign_keys
        fks = entity_def.get('foreign_keys', {})
        if leader not in fks:
            raise ValueError(
                f&quot;Group leader '{leader}' not found in foreign_keys. &quot;
                f&quot;Available: {list(fks.keys())}&quot;
            )

        # Check dependent fields not in base fields
        base_fields = entity_def.get('fields', {})
        for dep in dependents:
            if dep in base_fields:
                raise ValueError(
                    f&quot;Dependent field '{dep}' already defined in fields. &quot;
                    &quot;Dependent fields should only be in field_groups.&quot;
                )
</code></pre>
<h4 id="refactor-phase_3">ğŸ”§ REFACTOR Phase</h4>
<p><strong>Time</strong>: 30 minutes</p>
<h4 id="qa-phase_3">âœ… QA Phase</h4>
<p><strong>Time</strong>: 30 minutes</p>
<hr />
<h3 id="iteration-22-group-leader-trigger-template-tdd-cycle">Iteration 2.2: Group Leader Trigger Template (TDD Cycle)</h3>
<h4 id="red-phase_3">ğŸ”´ RED Phase</h4>
<p><strong>Time</strong>: 1 hour</p>
<pre><code class="language-python"># tests/test_trigger_generation.py
def test_generate_trigger_function():
    &quot;&quot;&quot;Test trigger function generation&quot;&quot;&quot;
    generator = TriggerGenerator()

    entity_def = {
        'name': 'manufacturer',
        'schema': 'catalog',
        'foreign_keys': {
            'fk_company': {
                'references': 'management.tb_organization',
                'on': 'pk_organization'
            }
        },
        'field_groups': [
            {
                'group_name': 'company_data',
                'group_leader': 'fk_company',
                'dependent_fields': ['company_country', 'company_address']
            }
        ]
    }

    sql = generator.generate_trigger_sql(entity_def)

    # Verify SQL contains key elements
    assert 'CREATE OR REPLACE FUNCTION' in sql
    assert 'fn_populate_company_data' in sql
    assert 'NEW.fk_company IS NOT NULL' in sql
    assert 'NEW.company_country :=' in sql
    assert 'CREATE TRIGGER' in sql
    assert 'BEFORE INSERT OR UPDATE' in sql
</code></pre>
<h4 id="green-phase_3">ğŸŸ¢ GREEN Phase</h4>
<p><strong>Time</strong>: 3 hours</p>
<p>Create Jinja2 template:</p>
<pre><code class="language-jinja2">{# templates/group_leader_triggers.sql.j2 #}
{%- if entity.field_groups %}
-- ============================================================================
-- Group Leader Triggers for {{ entity.schema }}.tb_{{ entity.name }}
-- ============================================================================
-- Auto-populate dependent fields when group leader is set
-- This ensures data coherence across related fields
-- ============================================================================

{%- for group in entity.field_groups %}

-- Group: {{ group.group_name }}
-- Leader: {{ group.group_leader }} â†’ Dependents: {{ group.dependent_fields | join(', ') }}
-- Purpose: {{ group.description | default('Ensure data coherence') }}

CREATE OR REPLACE FUNCTION {{ entity.schema }}.fn_populate_{{ group.group_name }}()
RETURNS TRIGGER
LANGUAGE plpgsql
AS $$
DECLARE
    v_source_record RECORD;
BEGIN
    -- Only populate when group leader {{ group.group_leader }} is set
    IF NEW.{{ group.group_leader }} IS NOT NULL THEN

        -- Fetch dependent fields from source table
        SELECT
            {%- for dep_field in group.dependent_fields %}
            {{ dep_field }}{% if not loop.last %},{% endif %}
            {%- endfor %}
        INTO v_source_record
        FROM {{ entity.foreign_keys[group.group_leader].references }}
        WHERE {{ entity.foreign_keys[group.group_leader].on }} = NEW.{{ group.group_leader }};

        -- Populate dependent fields in NEW record
        {%- for dep_field in group.dependent_fields %}
        NEW.{{ dep_field }} := v_source_record.{{ dep_field }};
        {%- endfor %}

    ELSE
        -- If group leader is NULL, clear dependent fields
        {%- for dep_field in group.dependent_fields %}
        NEW.{{ dep_field }} := NULL;
        {%- endfor %}
    END IF;

    RETURN NEW;
END;
$$;

COMMENT ON FUNCTION {{ entity.schema }}.fn_populate_{{ group.group_name }}() IS
'Auto-populate dependent fields {{ group.dependent_fields | join(&quot;, &quot;) }} when {{ group.group_leader }} is set. '
'Ensures {{ group.group_name }} data coherence.';

-- Create trigger to execute function
CREATE TRIGGER trg_populate_{{ group.group_name }}
    BEFORE INSERT OR UPDATE ON {{ entity.schema }}.tb_{{ entity.name }}
    FOR EACH ROW
    EXECUTE FUNCTION {{ entity.schema }}.fn_populate_{{ group.group_name }}();

COMMENT ON TRIGGER trg_populate_{{ group.group_name }} ON {{ entity.schema }}.tb_{{ entity.name }} IS
'Maintains coherence for {{ group.group_name }} by auto-populating dependent fields.';

{%- endfor %}
{%- endif %}
</code></pre>
<p>Python generator:</p>
<pre><code class="language-python"># src/trigger_generator.py
class TriggerGenerator:
    &quot;&quot;&quot;Generate group leader trigger SQL&quot;&quot;&quot;

    def __init__(self, templates_dir='templates'):
        self.env = Environment(
            loader=FileSystemLoader(templates_dir),
            trim_blocks=True,
            lstrip_blocks=True
        )

    def generate_trigger_sql(self, entity_def: Dict) -&gt; str:
        &quot;&quot;&quot;Generate trigger SQL for all field groups&quot;&quot;&quot;
        template = self.env.get_template('group_leader_triggers.sql.j2')
        return template.render(entity=entity_def)
</code></pre>
<h4 id="refactor-phase_4">ğŸ”§ REFACTOR Phase</h4>
<p><strong>Time</strong>: 1 hour</p>
<h4 id="qa-phase_4">âœ… QA Phase</h4>
<p><strong>Time</strong>: 1 hour</p>
<hr />
<h3 id="iteration-23-update-table-template-tdd-cycle">Iteration 2.3: Update Table Template (TDD Cycle)</h3>
<h4 id="red-phase_4">ğŸ”´ RED Phase</h4>
<p><strong>Time</strong>: 1 hour</p>
<pre><code class="language-python">def test_table_includes_dependent_fields():
    &quot;&quot;&quot;Test that table SQL includes dependent fields from groups&quot;&quot;&quot;
    generator = SQLGenerator()

    entity_def = {
        'name': 'manufacturer',
        'fields': {'identifier': {'type': 'TEXT'}},
        'field_groups': [
            {
                'group_leader': 'fk_company',
                'dependent_fields': ['company_country', 'company_address']
            }
        ]
    }

    sql = generator.generate_table(entity_def)

    # Should include dependent fields
    assert 'company_country TEXT' in sql
    assert 'company_address TEXT' in sql
    assert '-- Auto-populated by group leader' in sql
</code></pre>
<h4 id="green-phase_4">ğŸŸ¢ GREEN Phase</h4>
<p><strong>Time</strong>: 2 hours</p>
<p>Update table template:</p>
<pre><code class="language-jinja2">{# templates/table.sql.j2 - add section for dependent fields #}

-- Foreign Keys
{%- for fk_name, fk_def in entity.foreign_keys.items() %}
{{ fk_name }} INTEGER{% if not fk_def.nullable %} NOT NULL{% endif %},
{%- endfor %}

-- Group Leader Dependent Fields (auto-populated by triggers)
{%- if entity.field_groups %}
{%- for group in entity.field_groups %}
{%- for dep_field in group.dependent_fields %}
{{ dep_field }} TEXT,  -- Auto-populated by {{ group.group_leader }} ({{ group.group_name }})
{%- endfor %}
{%- endfor %}
{%- endif %}

-- Audit Fields
created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
...
</code></pre>
<h4 id="refactor-phase_5">ğŸ”§ REFACTOR Phase</h4>
<p><strong>Time</strong>: 1 hour</p>
<h4 id="qa-phase_5">âœ… QA Phase</h4>
<p><strong>Time</strong>: 1 hour</p>
<hr />
<h3 id="iteration-24-integration-testing-tdd-cycle">Iteration 2.4: Integration Testing (TDD Cycle)</h3>
<h4 id="red-phase_5">ğŸ”´ RED Phase</h4>
<p><strong>Time</strong>: 2 hours</p>
<p>Write integration test that:
1. Generates full table with group leaders
2. Applies SQL to test database
3. Tests trigger behavior</p>
<pre><code class="language-python"># tests/integration/test_group_leader_integration.py
@pytest.mark.integration
def test_group_leader_trigger_behavior(test_db):
    &quot;&quot;&quot;Test that group leader triggers work correctly&quot;&quot;&quot;
    # Generate SQL
    generator = SQLGenerator()
    entity_file = create_test_entity_with_groups()
    generator.generate_entity(entity_file)

    # Apply to database
    apply_sql_to_db(test_db, generated_files)

    # Test trigger
    test_db.execute(&quot;&quot;&quot;
        INSERT INTO catalog.tb_manufacturer (identifier, fk_company)
        VALUES ('canon', 1)
    &quot;&quot;&quot;)

    # Verify dependent fields populated
    result = test_db.query(&quot;&quot;&quot;
        SELECT company_country, company_address
        FROM catalog.tb_manufacturer
        WHERE identifier = 'canon'
    &quot;&quot;&quot;)

    assert result['company_country'] is not None
    assert result['company_address'] is not None
</code></pre>
<h4 id="green-phase_5">ğŸŸ¢ GREEN Phase</h4>
<p><strong>Time</strong>: 4 hours</p>
<p>Implement full integration, fix any issues.</p>
<h4 id="refactor-phase_6">ğŸ”§ REFACTOR Phase</h4>
<p><strong>Time</strong>: 2 hours</p>
<h4 id="qa-phase_6">âœ… QA Phase</h4>
<p><strong>Time</strong>: 2 hours</p>
<p><strong>Quality Gates:</strong>
- [ ] Integration tests pass
- [ ] Triggers work in real database
- [ ] Performance acceptable (&lt; 10ms overhead per INSERT)
- [ ] Dependent fields populate correctly
- [ ] NULL handling works</p>
<hr />
<h3 id="phase-2-deliverables">Phase 2 Deliverables</h3>
<p><strong>Completion Checklist:</strong>
- [ ] GroupLeaderValidator with tests
- [ ] TriggerGenerator with tests
- [ ] group_leader_triggers.sql.j2 template
- [ ] Updated table.sql.j2 template
- [ ] Integration tests pass
- [ ] Documentation updated
- [ ] Example entity with group leaders</p>
<p><strong>Acceptance Test:</strong></p>
<pre><code class="language-bash"># Generate entity with group leaders
python scripts/dev/generate_sql.py

# Apply to test database
psql test_db &lt; generated/01_write_side/.../013211_tb_manufacturer.sql

# Test trigger
psql test_db -c &quot;INSERT INTO catalog.tb_manufacturer (identifier, fk_company) VALUES ('test', 1); SELECT company_country FROM catalog.tb_manufacturer WHERE identifier='test';&quot;
# Should show auto-populated country
</code></pre>
<p><strong>Exit Criteria:</strong>
- [ ] Group leader triggers generate correctly
- [ ] Triggers work in database
- [ ] Tests validate behavior
- [ ] Performance benchmarked
- [ ] Team review and approval</p>
<hr />
<h2 id="phase-3-fraiseql-testfoundry-integration-week-3">PHASE 3: FraiseQL + TestFoundry Integration (Week 3)</h2>
<p><strong>Objective</strong>: Generate FraiseQL metadata and TestFoundry test suite
<strong>Duration</strong>: 35 hours
<strong>Complexity</strong>: Complex - Phased TDD</p>
<h3 id="iteration-31-fraiseql-metadata-generation">Iteration 3.1: FraiseQL Metadata Generation</h3>
<p><strong>Time</strong>: 10 hours (RED 2h, GREEN 5h, REFACTOR 2h, QA 1h)</p>
<h3 id="iteration-32-mutation-function-templates">Iteration 3.2: Mutation Function Templates</h3>
<p><strong>Time</strong>: 12 hours (RED 2h, GREEN 7h, REFACTOR 2h, QA 1h)</p>
<h3 id="iteration-33-testfoundry-metadata-template">Iteration 3.3: TestFoundry Metadata Template</h3>
<p><strong>Time</strong>: 8 hours</p>
<h3 id="iteration-34-test-generation-templates">Iteration 3.4: Test Generation Templates</h3>
<p><strong>Time</strong>: 5 hours</p>
<hr />
<h2 id="phase-4-polish-documentation-migration-week-4">PHASE 4: Polish + Documentation + Migration (Week 4)</h2>
<p><strong>Objective</strong>: Production-ready system with migration tooling
<strong>Duration</strong>: 25 hours</p>
<h3 id="iteration-41-health-check-system">Iteration 4.1: Health Check System</h3>
<p><strong>Time</strong>: 8 hours</p>
<h3 id="iteration-42-migration-tooling">Iteration 4.2: Migration Tooling</h3>
<p><strong>Time</strong>: 10 hours</p>
<h3 id="iteration-43-documentation-training">Iteration 4.3: Documentation + Training</h3>
<p><strong>Time</strong>: 7 hours</p>
<hr />
<h2 id="success-metrics">Success Metrics</h2>
<h3 id="phase-1-success">Phase 1 Success</h3>
<ul>
<li>[ ] Generated SQL uses numbered directories</li>
<li>[ ] Manifest.yaml validates execution order</li>
<li>[ ] Can generate manufacturer entity in &lt; 30 seconds</li>
</ul>
<h3 id="phase-2-success">Phase 2 Success</h3>
<ul>
<li>[ ] Group leader triggers generate correctly</li>
<li>[ ] Integration tests pass</li>
<li>[ ] Trigger overhead &lt; 10ms per operation</li>
</ul>
<h3 id="phase-3-success">Phase 3 Success</h3>
<ul>
<li>[ ] FraiseQL discovers types automatically</li>
<li>[ ] GraphQL API works without Python code</li>
<li>[ ] TestFoundry tests auto-generated</li>
</ul>
<h3 id="phase-4-success">Phase 4 Success</h3>
<ul>
<li>[ ] Can migrate existing entity to YAML in &lt; 30 minutes</li>
<li>[ ] Health checks prevent broken commits</li>
<li>[ ] Team trained and productive</li>
</ul>
<hr />
<h2 id="risk-mitigation">Risk Mitigation</h2>
<h3 id="technical-risks">Technical Risks</h3>
<ol>
<li><strong>Trigger Performance</strong> â†’ Benchmark early in Phase 2</li>
<li><strong>Manifest Drift</strong> â†’ Health checks in Phase 4</li>
<li><strong>Complex Dependencies</strong> â†’ Topological sort validation</li>
</ol>
<h3 id="process-risks">Process Risks</h3>
<ol>
<li><strong>Team Adoption</strong> â†’ Training and examples</li>
<li><strong>Migration Effort</strong> â†’ Tooling automation</li>
<li><strong>Breaking Changes</strong> â†’ Phased rollout</li>
</ol>
<hr />
<h2 id="rollback-strategy">Rollback Strategy</h2>
<p>Each phase is independently reversible:
- <strong>Phase 1</strong>: Remove numbered directories, keep flat structure
- <strong>Phase 2</strong>: Drop triggers, remove field_groups from YAML
- <strong>Phase 3</strong>: Remove FraiseQL annotations, keep SQL
- <strong>Phase 4</strong>: Manual migrations continue working</p>
<p><strong>Critical</strong>: Maintain parallel systems during Phase 1-2 transition.</p>
<hr />
<p><strong>Ready to begin Phase 1?</strong> ğŸš€</p>
              
            </div>
          </div><footer>

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
          
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="Versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    
    
    
  </span>
</div>
    <script src="../../js/jquery-3.6.0.min.js"></script>
    <script>var base_url = "../..";</script>
    <script src="../../js/theme_extra.js"></script>
    <script src="../../js/theme.js"></script>
      <script src="../../search/main.js"></script>
    <script>
        jQuery(function () {
            SphinxRtdTheme.Navigation.enable(true);
        });
    </script>

</body>
</html>
