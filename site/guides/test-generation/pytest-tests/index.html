<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
      <link rel="shortcut icon" href="../../../img/favicon.ico" />
    <title>pytest Tests - Python Integration Testing - SpecQL Documentation</title>
    <link rel="stylesheet" href="../../../css/theme.css" />
    <link rel="stylesheet" href="../../../css/theme_extra.css" />
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github.min.css" />
    
      <script>
        // Current page data
        var mkdocs_page_name = "pytest Tests - Python Integration Testing";
        var mkdocs_page_input_path = "guides/test-generation/pytest-tests.md";
        var mkdocs_page_url = null;
      </script>
    
    <!--[if lt IE 9]>
      <script src="../../../js/html5shiv.min.js"></script>
    <![endif]-->
      <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
      <script>hljs.highlightAll();</script> 
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
          <a href="../../.." class="icon icon-home"> SpecQL Documentation
        </a><div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
      <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../../..">Home</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="" href="../../../getting-started/">Getting Started</a>
                </li>
              </ul>
              <p class="caption"><span class="caption-text">Guides</span></p>
              <ul>
                  <li class="toctree-l1"><a class="" href="../../mutation-patterns/">Mutation Patterns</a>
                  </li>
                  <li class="toctree-l1"><a class="" href="../">Test Generation</a>
                  </li>
                  <li class="toctree-l1"><a class="" href="../../cli/">CLI</a>
                  </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="" href="../../../reference/">Reference</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="" href="../../../examples/">Examples</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="" href="../../../tutorials/">Tutorials</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="" href="../../../best-practices/">Best Practices</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="" href="../../../troubleshooting/">Troubleshooting</a>
                </li>
              </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">
      <nav class="wy-nav-top" role="navigation" aria-label="Mobile navigation menu">
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../..">SpecQL Documentation</a>
        
      </nav>
      <div class="wy-nav-content">
        <div class="rst-content"><div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../../.." class="icon icon-home" aria-label="Docs"></a></li>
      <li class="breadcrumb-item active">pytest Tests - Python Integration Testing</li>
    <li class="wy-breadcrumbs-aside">
    </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
            <div class="section" itemprop="articleBody">
              
                <h1 id="pytest-tests-python-integration-testing">pytest Tests - Python Integration Testing</h1>
<p>pytest is SpecQL's Python integration testing framework. Test your SpecQL-generated functions from application code, validate API responses, and ensure end-to-end functionality with the full power of Python testing.</p>
<h2 id="what-youll-learn">üéØ What You'll Learn</h2>
<ul>
<li>pytest testing fundamentals with SpecQL</li>
<li>Generate and run Python integration tests</li>
<li>Test application-level functionality</li>
<li>API testing and data validation</li>
<li>CI/CD integration with pytest</li>
</ul>
<h2 id="prerequisites">üìã Prerequisites</h2>
<ul>
<li><a href="../getting-started/installation.md">SpecQL installed</a></li>
<li><a href="../getting-started/first-entity.md">Entity with patterns created</a></li>
<li>Python 3.8+ with pytest</li>
<li>Basic Python knowledge</li>
</ul>
<h2 id="pytest-fundamentals">üí° pytest Fundamentals</h2>
<h3 id="what-is-pytest">What is pytest?</h3>
<p><strong>pytest</strong> is a mature, feature-rich testing framework for Python that provides:
- ‚úÖ <strong>Simple test writing</strong> - Write tests as functions
- ‚úÖ <strong>Powerful assertions</strong> - Rich assertion introspection
- ‚úÖ <strong>Fixtures</strong> - Reusable test setup/teardown
- ‚úÖ <strong>Plugins</strong> - Extensive ecosystem
- ‚úÖ <strong>Parallel execution</strong> - Speed up test suites
- ‚úÖ <strong>CI/CD integration</strong> - Works with all CI systems</p>
<h3 id="why-pytest-for-specql">Why pytest for SpecQL?</h3>
<p>| Feature | pytest | pgTAP | Manual Tests |
|---------|--------|--------------|
| <strong>Language</strong> | üêç Python | üêò SQL | Any |
| <strong>Scope</strong> | Application | Database | Custom |
| <strong>Setup</strong> | üõ†Ô∏è Python deps | ‚úÖ None | Custom |
| <strong>Assertions</strong> | Rich Python | SQL TAP | Basic |
| <strong>Fixtures</strong> | ‚úÖ Advanced | ‚ö†Ô∏è Limited | Custom |
| <strong>Parallel</strong> | ‚úÖ Native | ‚ö†Ô∏è Limited | Custom |</p>
<h2 id="step-1-install-pytest">üöÄ Step 1: Install pytest</h2>
<h3 id="basic-installation">Basic Installation</h3>
<pre><code class="language-bash"># Install pytest and database connector
pip install pytest psycopg2-binary

# Verify installation
pytest --version
</code></pre>
<h3 id="recommended-plugins">Recommended Plugins</h3>
<pre><code class="language-bash"># Install useful pytest plugins
pip install \
    pytest-cov        # Coverage reporting
    pytest-xdist      # Parallel execution
    pytest-html       # HTML reports
    pytest-mock       # Mocking support
    pytest-asyncio    # Async testing
    pytest-django     # Django integration
    pytest-flask      # Flask integration
</code></pre>
<h3 id="configuration">Configuration</h3>
<pre><code class="language-ini"># pytest.ini
[tool:pytest]
testpaths = tests
python_files = test_*.py *_test.py
python_classes = Test*
python_functions = test_*
addopts =
    --strict-markers
    --strict-config
    --cov=src
    --cov-report=html
    --cov-report=term-missing
</code></pre>
<h2 id="step-2-generate-pytest-tests">üß™ Step 2: Generate pytest Tests</h2>
<h3 id="create-test-entity">Create Test Entity</h3>
<pre><code class="language-yaml"># entities/product.yaml
name: product
fields:
  id: uuid
  name: string
  price: decimal
  category_id: uuid
  inventory_count: integer
  status: string

patterns:
  - name: state_machine
    description: &quot;Product lifecycle&quot;
    initial_state: draft
    states: [draft, active, discontinued]
    transitions:
      - from: draft
        to: active
        trigger: publish
        guard: &quot;name IS NOT NULL AND price &gt; 0&quot;
      - from: active
        to: discontinued
        trigger: discontinue

  - name: validation
    description: &quot;Product data rules&quot;
    rules:
      - name: positive_price
        field: price
        rule: &quot;price &gt; 0&quot;
        message: &quot;Price must be positive&quot;
      - name: valid_inventory
        field: inventory_count
        rule: &quot;inventory_count &gt;= 0&quot;
        message: &quot;Inventory cannot be negative&quot;
</code></pre>
<h3 id="generate-tests">Generate Tests</h3>
<pre><code class="language-bash"># Generate pytest tests
specql generate tests --type pytest entities/product.yaml

# Check generated files
ls -la tests/pytest/
# test_product_state_machine.py
# test_product_validation.py
</code></pre>
<h3 id="generated-test-structure">Generated Test Structure</h3>
<pre><code class="language-python"># tests/pytest/test_product_state_machine.py
import pytest
import psycopg2
from specql.testing.fixtures import database_connection

class TestProductStateMachine:
    @pytest.fixture
    def db_conn(self, database_connection):
        return database_connection

    @pytest.fixture
    def test_product(self, db_conn):
        &quot;&quot;&quot;Create test product and return ID&quot;&quot;&quot;
        with db_conn.cursor() as cursor:
            cursor.execute(&quot;&quot;&quot;
                INSERT INTO product (name, price, status)
                VALUES (%s, %s, %s)
                RETURNING id
            &quot;&quot;&quot;, ('Test Product', 29.99, 'draft'))
            product_id = cursor.fetchone()[0]
            db_conn.commit()
            yield product_id

            # Cleanup
            cursor.execute(&quot;DELETE FROM product WHERE id = %s&quot;, (product_id,))
            db_conn.commit()

    def test_initial_state_is_draft(self, db_conn, test_product):
        &quot;&quot;&quot;Test product starts in draft state&quot;&quot;&quot;
        with db_conn.cursor() as cursor:
            cursor.execute(
                &quot;SELECT status FROM product WHERE id = %s&quot;,
                (test_product,)
            )
            status = cursor.fetchone()[0]
            assert status == 'draft'

    def test_successful_publish_transition(self, db_conn, test_product):
        &quot;&quot;&quot;Test successful product publish&quot;&quot;&quot;
        with db_conn.cursor() as cursor:
            cursor.execute(
                &quot;SELECT product_publish(%s)&quot;,
                (test_product,)
            )
            result = cursor.fetchone()[0]
            assert result is not None

            # Verify state change
            cursor.execute(
                &quot;SELECT status FROM product WHERE id = %s&quot;,
                (test_product,)
            )
            status = cursor.fetchone()[0]
            assert status == 'active'

    def test_publish_fails_without_price(self, db_conn):
        &quot;&quot;&quot;Test publish fails for product without price&quot;&quot;&quot;
        with db_conn.cursor() as cursor:
            cursor.execute(&quot;&quot;&quot;
                INSERT INTO product (name, price, status)
                VALUES (%s, %s, %s)
                RETURNING id
            &quot;&quot;&quot;, ('No Price Product', None, 'draft'))
            product_id = cursor.fetchone()[0]
            db_conn.commit()

            try:
                cursor.execute(
                    &quot;SELECT product_publish(%s)&quot;,
                    (product_id,)
                )
                result = cursor.fetchone()[0]
                assert result is None  # Should fail due to guard
            finally:
                cursor.execute(&quot;DELETE FROM product WHERE id = %s&quot;, (product_id,))
                db_conn.commit()

    def test_discontinue_transition(self, db_conn, test_product):
        &quot;&quot;&quot;Test product discontinuation&quot;&quot;&quot;
        with db_conn.cursor() as cursor:
            # First publish the product
            cursor.execute(&quot;SELECT product_publish(%s)&quot;, (test_product,))

            # Then discontinue it
            cursor.execute(
                &quot;SELECT product_discontinue(%s)&quot;,
                (test_product,)
            )
            result = cursor.fetchone()[0]
            assert result is not None

            # Verify final state
            cursor.execute(
                &quot;SELECT status FROM product WHERE id = %s&quot;,
                (test_product,)
            )
            status = cursor.fetchone()[0]
            assert status == 'discontinued'
</code></pre>
<h2 id="step-3-run-pytest-tests">üèÉ Step 3: Run pytest Tests</h2>
<h3 id="basic-test-execution">Basic Test Execution</h3>
<pre><code class="language-bash"># Run all pytest tests for entity
specql test run --type pytest entities/product.yaml

# Expected output:
# tests/pytest/test_product_state_machine.py::TestProductStateMachine::test_initial_state_is_draft
# PASSED
# tests/pytest/test_product_state_machine.py::TestProductStateMachine::test_successful_publish_transition
# PASSED
# tests/pytest/test_product_state_machine.py::TestProductStateMachine::test_publish_fails_without_price
# PASSED
# tests/pytest/test_product_state_machine.py::TestProductStateMachine::test_discontinue_transition
# PASSED
</code></pre>
<h3 id="advanced-pytest-options">Advanced pytest Options</h3>
<pre><code class="language-bash"># Run with coverage
specql test run --type pytest entities/product.yaml --cov --cov-report html

# Run in parallel
specql test run --type pytest entities/product.yaml --parallel 4

# Generate HTML report
specql test run --type pytest entities/product.yaml --html-report results.html

# Run specific test class
specql test run --type pytest entities/product.yaml --filter &quot;TestProductStateMachine&quot;

# Run specific test method
specql test run --type pytest entities/product.yaml --filter &quot;test_successful_publish&quot;

# Verbose output
specql test run --type pytest entities/product.yaml --verbose
</code></pre>
<h3 id="manual-pytest-execution">Manual pytest Execution</h3>
<pre><code class="language-bash"># Run tests directly with pytest
pytest tests/pytest/test_product_state_machine.py -v

# Run with coverage
pytest tests/pytest/ --cov=src --cov-report=html

# Run in parallel
pytest tests/pytest/ -n 4

# Generate HTML report
pytest tests/pytest/ --html=report.html
</code></pre>
<h2 id="step-4-test-fixtures-and-setup">üîß Step 4: Test Fixtures and Setup</h2>
<h3 id="database-connection-fixture">Database Connection Fixture</h3>
<pre><code class="language-python"># tests/conftest.py
import pytest
import psycopg2
import os

@pytest.fixture(scope=&quot;session&quot;)
def database_connection():
    &quot;&quot;&quot;Provide database connection for tests&quot;&quot;&quot;
    conn = psycopg2.connect(os.environ.get(&quot;DATABASE_URL&quot;))
    conn.autocommit = False  # Use transactions

    yield conn

    conn.close()

@pytest.fixture
def db_cursor(database_connection):
    &quot;&quot;&quot;Provide database cursor with automatic rollback&quot;&quot;&quot;
    cursor = database_connection.cursor()

    yield cursor

    database_connection.rollback()  # Rollback after each test
</code></pre>
<h3 id="test-data-factories">Test Data Factories</h3>
<pre><code class="language-python"># tests/fixtures/product_factory.py
import uuid

def create_test_product(db_cursor, **overrides):
    &quot;&quot;&quot;Factory for creating test products&quot;&quot;&quot;
    defaults = {
        'id': str(uuid.uuid4()),
        'name': 'Test Product',
        'price': 29.99,
        'status': 'draft',
        'inventory_count': 100
    }
    data = {**defaults, **overrides}

    db_cursor.execute(&quot;&quot;&quot;
        INSERT INTO product (id, name, price, status, inventory_count)
        VALUES (%s, %s, %s, %s, %s)
    &quot;&quot;&quot;, (data['id'], data['name'], data['price'],
          data['status'], data['inventory_count']))

    return data['id']

def create_test_category(db_cursor, **overrides):
    &quot;&quot;&quot;Factory for creating test categories&quot;&quot;&quot;
    defaults = {
        'id': str(uuid.uuid4()),
        'name': 'Test Category',
        'description': 'Test category description'
    }
    data = {**defaults, **overrides}

    db_cursor.execute(&quot;&quot;&quot;
        INSERT INTO category (id, name, description)
        VALUES (%s, %s, %s)
    &quot;&quot;&quot;, (data['id'], data['name'], data['description']))

    return data['id']
</code></pre>
<h3 id="using-factories-in-tests">Using Factories in Tests</h3>
<pre><code class="language-python"># tests/pytest/test_product_api.py
import pytest
from fixtures.product_factory import create_test_product, create_test_category

class TestProductAPI:
    def test_create_product_api(self, db_cursor, client):
        &quot;&quot;&quot;Test product creation via API&quot;&quot;&quot;
        category_id = create_test_category(db_cursor)

        product_data = {
            'name': 'New Product',
            'price': 49.99,
            'category_id': category_id
        }

        # Assuming you have a test client
        response = client.post('/api/products', json=product_data)
        assert response.status_code == 201

        # Verify in database
        db_cursor.execute(
            &quot;SELECT name, price FROM product WHERE id = %s&quot;,
            (response.json()['id'],)
        )
        name, price = db_cursor.fetchone()
        assert name == 'New Product'
        assert price == 49.99

    def test_product_state_machine_via_api(self, db_cursor, client):
        &quot;&quot;&quot;Test state machine transitions via API&quot;&quot;&quot;
        product_id = create_test_product(db_cursor, status='draft')

        # Publish via API
        response = client.post(f'/api/products/{product_id}/publish')
        assert response.status_code == 200

        # Verify state change in database
        db_cursor.execute(
            &quot;SELECT status FROM product WHERE id = %s&quot;,
            (product_id,)
        )
        status = db_cursor.fetchone()[0]
        assert status == 'active'
</code></pre>
<h2 id="step-5-api-testing">üìä Step 5: API Testing</h2>
<h3 id="rest-api-testing">REST API Testing</h3>
<pre><code class="language-python"># tests/pytest/test_product_api.py
import pytest
import requests

class TestProductAPI:
    def test_get_product(self, api_client, test_product):
        &quot;&quot;&quot;Test retrieving a product via API&quot;&quot;&quot;
        response = api_client.get(f'/api/products/{test_product}')

        assert response.status_code == 200
        data = response.json()
        assert data['id'] == test_product
        assert data['status'] == 'draft'

    def test_create_product_validation(self, api_client):
        &quot;&quot;&quot;Test product creation with validation&quot;&quot;&quot;
        # Test missing required field
        response = api_client.post('/api/products', json={
            'price': 29.99
            # Missing 'name'
        })

        assert response.status_code == 400
        assert 'name' in response.json()['errors']

    def test_product_state_transition_api(self, api_client, test_product):
        &quot;&quot;&quot;Test state machine via REST API&quot;&quot;&quot;
        # Publish product
        response = api_client.post(f'/api/products/{test_product}/publish')
        assert response.status_code == 200

        # Verify state change
        response = api_client.get(f'/api/products/{test_product}')
        assert response.status_code == 200
        assert response.json()['status'] == 'active'

    def test_bulk_product_operations(self, api_client, db_cursor):
        &quot;&quot;&quot;Test bulk operations via API&quot;&quot;&quot;
        # Create multiple products
        product_ids = []
        for i in range(5):
            product_ids.append(create_test_product(db_cursor, name=f'Product {i}'))

        # Bulk update via API
        response = api_client.post('/api/products/bulk-update', json={
            'product_ids': product_ids,
            'updates': {'status': 'active'}
        })

        assert response.status_code == 200
        assert response.json()['updated_count'] == 5

        # Verify all products updated
        db_cursor.execute(&quot;&quot;&quot;
            SELECT count(*) FROM product
            WHERE id = ANY(%s) AND status = 'active'
        &quot;&quot;&quot;, (product_ids,))
        active_count = db_cursor.fetchone()[0]
        assert active_count == 5
</code></pre>
<h3 id="graphql-api-testing">GraphQL API Testing</h3>
<pre><code class="language-python"># tests/pytest/test_product_graphql.py
import pytest

class TestProductGraphQL:
    def test_product_query(self, graphql_client, test_product):
        &quot;&quot;&quot;Test GraphQL product query&quot;&quot;&quot;
        query = &quot;&quot;&quot;
        query GetProduct($id: ID!) {
            product(id: $id) {
                id
                name
                price
                status
            }
        }
        &quot;&quot;&quot;

        response = graphql_client.execute(query, variables={'id': test_product})

        assert response.status_code == 200
        data = response.json()['data']['product']
        assert data['id'] == test_product
        assert data['status'] == 'draft'

    def test_product_mutation(self, graphql_client, test_product):
        &quot;&quot;&quot;Test GraphQL product mutation&quot;&quot;&quot;
        mutation = &quot;&quot;&quot;
        mutation PublishProduct($id: ID!) {
            publishProduct(id: $id) {
                id
                status
                publishedAt
            }
        }
        &quot;&quot;&quot;

        response = graphql_client.execute(mutation, variables={'id': test_product})

        assert response.status_code == 200
        data = response.json()['data']['publishProduct']
        assert data['status'] == 'active'
        assert data['publishedAt'] is not None
</code></pre>
<h2 id="step-6-integration-testing">üîç Step 6: Integration Testing</h2>
<h3 id="end-to-end-workflows">End-to-End Workflows</h3>
<pre><code class="language-python"># tests/pytest/test_ecommerce_workflow.py
import pytest
from fixtures.user_factory import create_test_user
from fixtures.product_factory import create_test_product, create_test_category
from fixtures.order_factory import create_test_order

class TestEcommerceWorkflow:
    def test_complete_purchase_flow(self, db_cursor, api_client):
        &quot;&quot;&quot;Test complete purchase workflow&quot;&quot;&quot;
        # Setup test data
        user_id = create_test_user(db_cursor)
        category_id = create_test_category(db_cursor)
        product_id = create_test_product(db_cursor, category_id=category_id)

        # Step 1: Add to cart
        cart_response = api_client.post('/api/cart/add', json={
            'user_id': user_id,
            'product_id': product_id,
            'quantity': 2
        })
        assert cart_response.status_code == 200
        cart_id = cart_response.json()['cart_id']

        # Step 2: Checkout
        checkout_response = api_client.post('/api/checkout', json={
            'cart_id': cart_id,
            'shipping_address': '123 Main St'
        })
        assert checkout_response.status_code == 200
        order_id = checkout_response.json()['order_id']

        # Step 3: Verify order created
        db_cursor.execute(&quot;&quot;&quot;
            SELECT status, total_amount FROM order WHERE id = %s
        &quot;&quot;&quot;, (order_id,))
        status, total = db_cursor.fetchone()
        assert status == 'pending'
        assert total == 59.98  # 2 * 29.99

        # Step 4: Process payment
        payment_response = api_client.post('/api/payments', json={
            'order_id': order_id,
            'amount': 59.98,
            'payment_method': 'credit_card'
        })
        assert payment_response.status_code == 200

        # Step 5: Confirm order (should trigger state machine)
        confirm_response = api_client.post(f'/api/orders/{order_id}/confirm')
        assert confirm_response.status_code == 200

        # Step 6: Verify final state
        db_cursor.execute(&quot;&quot;&quot;
            SELECT status FROM order WHERE id = %s
        &quot;&quot;&quot;, (order_id,))
        final_status = db_cursor.fetchone()[0]
        assert final_status == 'confirmed'

        # Step 7: Check inventory updated
        db_cursor.execute(&quot;&quot;&quot;
            SELECT inventory_count FROM product WHERE id = %s
        &quot;&quot;&quot;, (product_id,))
        inventory = db_cursor.fetchone()[0]
        assert inventory == 98  # 100 - 2
</code></pre>
<h3 id="cross-service-testing">Cross-Service Testing</h3>
<pre><code class="language-python"># tests/pytest/test_cross_service.py
import pytest
from unittest.mock import patch

class TestCrossServiceIntegration:
    def test_inventory_service_integration(self, db_cursor, test_product):
        &quot;&quot;&quot;Test integration with inventory service&quot;&quot;&quot;
        with patch('services.inventory.InventoryService.check_stock') as mock_check:
            mock_check.return_value = True

            # Attempt to place order
            response = place_order_via_api({
                'product_id': test_product,
                'quantity': 5
            })

            assert response.status_code == 200
            mock_check.assert_called_once_with(test_product, 5)

    def test_payment_gateway_integration(self, db_cursor):
        &quot;&quot;&quot;Test payment gateway integration&quot;&quot;&quot;
        with patch('services.payment.PaymentGateway.charge') as mock_charge:
            mock_charge.return_value = {'status': 'success', 'transaction_id': 'txn_123'}

            # Process payment
            result = process_payment_via_api({
                'amount': 100.00,
                'card_token': 'tok_456'
            })

            assert result['status'] == 'success'
            mock_charge.assert_called_once()

    def test_notification_service_integration(self, db_cursor, test_product):
        &quot;&quot;&quot;Test notification service integration&quot;&quot;&quot;
        with patch('services.notification.NotificationService.send_email') as mock_send:
            mock_send.return_value = True

            # Publish product (should trigger notification)
            publish_product_via_api(test_product)

            # Verify notification sent
            mock_send.assert_called_once()
            call_args = mock_send.call_args[0]
            assert 'product_published' in call_args[0]  # Email template
</code></pre>
<h2 id="step-7-performance-and-load-testing">üìà Step 7: Performance and Load Testing</h2>
<h3 id="performance-benchmarks">Performance Benchmarks</h3>
<pre><code class="language-python"># tests/pytest/test_performance.py
import pytest
import time
from fixtures.product_factory import create_test_product

class TestProductPerformance:
    def test_product_creation_performance(self, db_cursor, benchmark):
        &quot;&quot;&quot;Benchmark product creation performance&quot;&quot;&quot;
        def create_products():
            for i in range(100):
                create_test_product(db_cursor, name=f'Product {i}')

        # Benchmark the operation
        result = benchmark(create_products)

        # Assert performance requirements
        assert result.stats.mean &lt; 1.0  # Average &lt; 1 second for 100 products

    def test_state_machine_transition_performance(self, db_cursor, benchmark):
        &quot;&quot;&quot;Benchmark state machine transitions&quot;&quot;&quot;
        # Create test products
        product_ids = []
        for i in range(100):
            product_ids.append(create_test_product(db_cursor))

        def bulk_publish():
            db_cursor.executemany(&quot;&quot;&quot;
                SELECT product_publish(%s)
            &quot;&quot;&quot;, [(pid,) for pid in product_ids])

        result = benchmark(bulk_publish)
        assert result.stats.mean &lt; 2.0  # &lt; 2 seconds for 100 transitions

    def test_concurrent_access(self, db_cursor):
        &quot;&quot;&quot;Test concurrent access to products&quot;&quot;&quot;
        import threading

        product_id = create_test_product(db_cursor)
        errors = []

        def worker(worker_id):
            try:
                for i in range(10):
                    # Simulate concurrent operations
                    db_cursor.execute(&quot;&quot;&quot;
                        UPDATE product
                        SET inventory_count = inventory_count - 1
                        WHERE id = %s AND inventory_count &gt; 0
                    &quot;&quot;&quot;, (product_id,))
                    db_cursor.connection.commit()
                    time.sleep(0.01)  # Small delay
            except Exception as e:
                errors.append(f&quot;Worker {worker_id}: {e}&quot;)

        # Start multiple threads
        threads = []
        for i in range(5):
            t = threading.Thread(target=worker, args=(i,))
            threads.append(t)
            t.start()

        # Wait for completion
        for t in threads:
            t.join()

        # Verify no errors occurred
        assert len(errors) == 0

        # Verify final inventory
        db_cursor.execute(&quot;SELECT inventory_count FROM product WHERE id = %s&quot;, (product_id,))
        final_inventory = db_cursor.fetchone()[0]
        assert final_inventory == 50  # 100 - (5 workers * 10 operations)
</code></pre>
<h3 id="load-testing">Load Testing</h3>
<pre><code class="language-python"># tests/pytest/test_load.py
import pytest
import asyncio
import aiohttp
from fixtures.product_factory import create_test_product

class TestProductLoad:
    @pytest.mark.asyncio
    async def test_api_load(self, api_client):
        &quot;&quot;&quot;Test API under load&quot;&quot;&quot;
        async with aiohttp.ClientSession() as session:
            # Create test data
            product_ids = []
            for i in range(100):
                product_ids.append(create_test_product(db_cursor))

            # Test concurrent API calls
            tasks = []
            for product_id in product_ids[:50]:  # Test 50 concurrent requests
                tasks.append(session.get(f'{api_client.base_url}/api/products/{product_id}'))

            start_time = time.time()
            responses = await asyncio.gather(*tasks)
            end_time = time.time()

            # Verify all requests succeeded
            assert all(r.status == 200 for r in responses)

            # Verify performance
            total_time = end_time - start_time
            avg_response_time = total_time / len(tasks)
            assert avg_response_time &lt; 0.5  # &lt; 500ms average
</code></pre>
<h2 id="step-8-customize-pytest-tests">üîß Step 8: Customize pytest Tests</h2>
<h3 id="test-configuration">Test Configuration</h3>
<pre><code class="language-yaml"># In your entity YAML
name: product
# ... fields and patterns ...

test_config:
  pytest:
    # Test structure
    test_class_prefix: &quot;Test&quot;
    test_method_prefix: &quot;test_&quot;

    # Fixtures
    fixtures:
      - name: test_product
        factory: &quot;fixtures.product_factory.create_test_product&quot;
        cleanup: true

      - name: test_category
        factory: &quot;fixtures.category_factory.create_test_category&quot;

    # Test data
    test_data:
      - name: premium_product
        data:
          name: &quot;Premium Product&quot;
          price: 99.99
          category: &quot;premium&quot;

    # Performance requirements
    performance:
      max_execution_time: &quot;30 seconds&quot;
      max_memory_usage: &quot;100 MB&quot;

    # Coverage requirements
    coverage:
      minimum: 95
      exclude_patterns: [&quot;test_*&quot;, &quot;fixture_*&quot;]
</code></pre>
<h3 id="custom-test-templates">Custom Test Templates</h3>
<pre><code class="language-python"># tests/pytest/test_product_custom.py
import pytest
from specql.testing.base import SpecQLTestCase

class TestProductCustom(SpecQLTestCase):
    &quot;&quot;&quot;Custom tests for product entity&quot;&quot;&quot;

    def test_product_search_functionality(self, db_cursor, test_product):
        &quot;&quot;&quot;Test product search functionality&quot;&quot;&quot;
        # This would test custom search functions
        # that might not be auto-generated

        # Insert test data
        db_cursor.execute(&quot;&quot;&quot;
            UPDATE product
            SET name = 'Special Test Product',
                tags = ARRAY['electronics', 'gadgets']
            WHERE id = %s
        &quot;&quot;&quot;, (test_product,))

        # Test search function (assuming it exists)
        db_cursor.execute(&quot;&quot;&quot;
            SELECT * FROM search_products('electronics')
        &quot;&quot;&quot;)
        results = db_cursor.fetchall()

        assert len(results) &gt; 0
        assert any('Special Test Product' in str(row) for row in results)

    def test_product_recommendation_engine(self, db_cursor):
        &quot;&quot;&quot;Test product recommendation logic&quot;&quot;&quot;
        # Create test products with categories
        electronics_category = create_test_category(db_cursor, name='Electronics')
        books_category = create_test_category(db_cursor, name='Books')

        product1 = create_test_product(db_cursor,
            name='iPhone', category_id=electronics_category)
        product2 = create_test_product(db_cursor,
            name='Python Book', category_id=books_category)

        # Test recommendation (assuming recommendation function exists)
        db_cursor.execute(&quot;&quot;&quot;
            SELECT * FROM recommend_products(%s, 5)
        &quot;&quot;&quot;, (electronics_category,))
        recommendations = db_cursor.fetchall()

        # Should recommend electronics products
        assert len(recommendations) &gt; 0
        # Add more specific assertions based on your recommendation logic
</code></pre>
<h2 id="step-9-cicd-integration">üîÑ Step 9: CI/CD Integration</h2>
<h3 id="github-actions-example">GitHub Actions Example</h3>
<pre><code class="language-yaml"># .github/workflows/pytest-tests.yml
name: pytest Tests

on: [push, pull_request]

jobs:
  test:
    runs-on: ubuntu-latest

    services:
      postgres:
        image: postgres:15
        env:
          POSTGRES_PASSWORD: postgres
        options: &gt;-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5

    steps:
      - uses: actions/checkout@v3

      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'

      - name: Install Dependencies
        run: |
          pip install specql pytest pytest-cov pytest-xdist psycopg2-binary

      - name: Generate Schema
        run: specql generate schema entities/*.yaml

      - name: Apply Schema
        run: |
          psql postgresql://postgres:postgres@localhost:5432/postgres -f db/schema/00_foundation/*.sql
          psql postgresql://postgres:postgres@localhost:5432/postgres -f db/schema/10_tables/*.sql
          psql postgresql://postgres:postgres@localhost:5432/postgres -f db/schema/40_functions/*.sql

      - name: Generate pytest Tests
        run: specql generate tests --type pytest entities/*.yaml

      - name: Run pytest Tests
        run: specql test run --type pytest entities/*.yaml --cov --cov-report xml

      - name: Upload Coverage
        uses: codecov/codecov-action@v3
        with:
          file: ./coverage.xml
</code></pre>
<h3 id="parallel-testing">Parallel Testing</h3>
<pre><code class="language-yaml"># .github/workflows/parallel-tests.yml
name: Parallel pytest Tests

on: [push, pull_request]

jobs:
  test:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        test-group: [1, 2, 3, 4]

    steps:
      - uses: actions/checkout@v3

      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'

      - name: Install Dependencies
        run: pip install specql pytest pytest-xdist psycopg2-binary

      # ... schema setup steps ...

      - name: Generate Tests
        run: specql generate tests --type pytest entities/*.yaml

      - name: Run Parallel Tests
        run: |
          # Split tests into groups
          pytest tests/pytest/ \
            --numprocesses 4 \
            --group ${{ matrix.test-group }} \
            --cov=src \
            --cov-report xml \
            --cov-report term-missing
</code></pre>
<h2 id="best-practices">üéØ Best Practices</h2>
<h3 id="test-design">Test Design</h3>
<ul>
<li><strong>Use descriptive test names</strong> - Explain what each test validates</li>
<li><strong>Keep tests focused</strong> - Test one behavior per test method</li>
<li><strong>Use fixtures effectively</strong> - Share setup/teardown code</li>
<li><strong>Test realistic scenarios</strong> - Use production-like data</li>
</ul>
<h3 id="performance">Performance</h3>
<ul>
<li><strong>Use parallel execution</strong> - Speed up test suites with pytest-xdist</li>
<li><strong>Mock external services</strong> - Avoid slow network calls in tests</li>
<li><strong>Use appropriate fixtures</strong> - session &gt; module &gt; class &gt; function scope</li>
<li><strong>Profile slow tests</strong> - Identify and optimize bottlenecks</li>
</ul>
<h3 id="maintenance">Maintenance</h3>
<ul>
<li><strong>Regenerate tests regularly</strong> - Keep in sync with schema changes</li>
<li><strong>Review test failures</strong> - Understand root causes, not just symptoms</li>
<li><strong>Update test expectations</strong> - When business logic changes intentionally</li>
<li><strong>Document custom tests</strong> - Explain non-obvious test logic</li>
</ul>
<h3 id="integration-testing">Integration Testing</h3>
<ul>
<li><strong>Test complete workflows</strong> - End-to-end user journeys</li>
<li><strong>Use realistic test data</strong> - Match production data characteristics</li>
<li><strong>Test error scenarios</strong> - Invalid inputs, network failures, timeouts</li>
<li><strong>Verify data consistency</strong> - Check database state after operations</li>
</ul>
<h2 id="troubleshooting">üÜò Troubleshooting</h2>
<h3 id="pytest-command-not-found">"pytest command not found"</h3>
<pre><code class="language-bash"># Install pytest
pip install pytest

# Or use specql wrapper
specql test run --type pytest entities/user.yaml
</code></pre>
<h3 id="database-connection-failed">"Database connection failed"</h3>
<pre><code class="language-bash"># Check DATABASE_URL
echo $DATABASE_URL

# Test connection manually
python -c &quot;import psycopg2; psycopg2.connect('$DATABASE_URL')&quot;

# Use test database
export DATABASE_URL=&quot;postgresql://localhost/specql_test&quot;
</code></pre>
<h3 id="tests-pass-locally-but-fail-in-ci">"Tests pass locally but fail in CI"</h3>
<pre><code class="language-bash"># Check environment differences
# - Python version
# - PostgreSQL version
# - Database collation
# - Timezone settings

# Use same versions in CI as local
</code></pre>
<h3 id="fixture-errors">"Fixture errors"</h3>
<pre><code class="language-python"># Check fixture scope
@pytest.fixture(scope=&quot;function&quot;)  # Default - per test
@pytest.fixture(scope=&quot;class&quot;)     # Per test class
@pytest.fixture(scope=&quot;module&quot;)    # Per test module
@pytest.fixture(scope=&quot;session&quot;)   # Once per test session
</code></pre>
<h3 id="import-errors">"Import errors"</h3>
<pre><code class="language-python"># Check Python path
import sys
sys.path.append('tests')

# Or use absolute imports
from tests.fixtures.user_factory import create_test_user
</code></pre>
<h3 id="coverage-not-working">"Coverage not working"</h3>
<pre><code class="language-bash"># Install coverage
pip install pytest-cov

# Run with coverage
pytest --cov=src --cov-report html

# Check coverage configuration
pytest --cov-config=.coveragerc
</code></pre>
<h2 id="success-metrics">üìä Success Metrics</h2>
<h3 id="test-quality-metrics">Test Quality Metrics</h3>
<ul>
<li><strong>Test execution time</strong>: &lt;5 minutes for full suite</li>
<li><strong>Test coverage</strong>: &gt;95% of application code</li>
<li><strong>Test count</strong>: 10-20 tests per entity</li>
<li><strong>Failure rate</strong>: &lt;1% in stable branches</li>
</ul>
<h3 id="performance-benchmarks_1">Performance Benchmarks</h3>
<ul>
<li><strong>API response time</strong>: &lt;200ms average</li>
<li><strong>Database queries</strong>: &lt;50ms average</li>
<li><strong>Concurrent users</strong>: Support 100+ simultaneous users</li>
<li><strong>Memory usage</strong>: &lt;100MB per test process</li>
</ul>
<h3 id="reliability-goals">Reliability Goals</h3>
<ul>
<li><strong>Zero flaky tests</strong> - Tests should be deterministic</li>
<li><strong>Fast feedback</strong> - Results in &lt;10 minutes</li>
<li><strong>CI stability</strong> - &lt;2% false failures</li>
<li><strong>Maintenance cost</strong> - &lt;5% of development time</li>
</ul>
<h2 id="summary">üéâ Summary</h2>
<p>pytest testing provides:
- ‚úÖ <strong>Python integration testing</strong> - Test from application code
- ‚úÖ <strong>Rich assertions</strong> - Detailed failure information
- ‚úÖ <strong>Flexible fixtures</strong> - Reusable test setup
- ‚úÖ <strong>Parallel execution</strong> - Fast test suites
- ‚úÖ <strong>CI/CD integration</strong> - Comprehensive reporting</p>
<h2 id="whats-next">üöÄ What's Next?</h2>
<ul>
<li><strong><a href="../performance-tests/">Performance Tests</a></strong> - Benchmarking and optimization</li>
<li><strong><a href="ci-cd-integration.md">CI/CD Integration</a></strong> - Automated testing pipelines</li>
<li><strong><a href="../best-practices/testing.md">Custom Test Patterns</a></strong> - Advanced testing techniques</li>
<li><strong><a href="../best-practices/api-testing.md">API Testing</a></strong> - REST and GraphQL testing</li>
</ul>
<p><strong>Ready to test your complete application stack? Let's continue! üöÄ</strong></p>
              
            </div>
          </div><footer>

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
          
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="Versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    
    
    
  </span>
</div>
    <script src="../../../js/jquery-3.6.0.min.js"></script>
    <script>var base_url = "../../..";</script>
    <script src="../../../js/theme_extra.js"></script>
    <script src="../../../js/theme.js"></script>
      <script src="../../../search/main.js"></script>
    <script>
        jQuery(function () {
            SphinxRtdTheme.Navigation.enable(true);
        });
    </script>

</body>
</html>
