<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
      <link rel="shortcut icon" href="../../../img/favicon.ico" />
    <title>Team C: Database Decisions Implementation Plan - SpecQL Documentation</title>
    <link rel="stylesheet" href="../../../css/theme.css" />
    <link rel="stylesheet" href="../../../css/theme_extra.css" />
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github.min.css" />
    
      <script>
        // Current page data
        var mkdocs_page_name = "Team C: Database Decisions Implementation Plan";
        var mkdocs_page_input_path = "archive/teams/TEAM_C_DATABASE_DECISIONS_PLAN.md";
        var mkdocs_page_url = null;
      </script>
    
    <!--[if lt IE 9]>
      <script src="../../../js/html5shiv.min.js"></script>
    <![endif]-->
      <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
      <script>hljs.highlightAll();</script> 
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
          <a href="../../.." class="icon icon-home"> SpecQL Documentation
        </a><div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
      <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../../..">Home</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="" href="../../../getting-started/">Getting Started</a>
                </li>
              </ul>
              <p class="caption"><span class="caption-text">Guides</span></p>
              <ul>
                  <li class="toctree-l1"><a class="" href="../../../guides/mutation-patterns/">Mutation Patterns</a>
                  </li>
                  <li class="toctree-l1"><a class="" href="../../../guides/test-generation/">Test Generation</a>
                  </li>
                  <li class="toctree-l1"><a class="" href="../../../guides/cli/">CLI</a>
                  </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="" href="../../../reference/">Reference</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="" href="../../../examples/">Examples</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="" href="../../../tutorials/">Tutorials</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="" href="../../../best-practices/">Best Practices</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="" href="../../../troubleshooting/">Troubleshooting</a>
                </li>
              </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">
      <nav class="wy-nav-top" role="navigation" aria-label="Mobile navigation menu">
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../..">SpecQL Documentation</a>
        
      </nav>
      <div class="wy-nav-content">
        <div class="rst-content"><div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../../.." class="icon icon-home" aria-label="Docs"></a></li>
      <li class="breadcrumb-item active">Team C: Database Decisions Implementation Plan</li>
    <li class="wy-breadcrumbs-aside">
    </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
            <div class="section" itemprop="articleBody">
              
                <h1 id="team-c-database-decisions-implementation-plan">Team C: Database Decisions Implementation Plan</h1>
<p><strong>Team</strong>: Action Compiler (Business Logic â†’ PL/pgSQL)
<strong>Impact</strong>: MEDIUM (audit field usage, path recalculation logic)
<strong>Timeline</strong>: Week 3-4 (3-4 days)
<strong>Status</strong>: ðŸŸ¡ MEDIUM PRIORITY - Depends on Team B</p>
<hr />
<h2 id="overview">ðŸ“‹ Overview</h2>
<p>Team C must update action compilation to:</p>
<ol>
<li>âœ… Use correct audit fields (identifier_recalculated_at, NOT updated_at)</li>
<li>âœ… Idempotent recalculation (only update if changed)</li>
<li>âœ… Path recalculation only on parent change</li>
<li>âœ… Generate helper function usage in business logic</li>
</ol>
<p><strong>Total Effort</strong>: 3-4 days</p>
<hr />
<h2 id="phase-1-correct-audit-field-usage-day-1">ðŸŽ¯ Phase 1: Correct Audit Field Usage (Day 1)</h2>
<h3 id="objective-update-audit-field-logic-in-generated-functions"><strong>Objective</strong>: Update audit field logic in generated functions</h3>
<h3 id="11-business-data-updates-updated_at"><strong>1.1: Business Data Updates â†’ updated_at</strong></h3>
<p><strong>When</strong>: User-initiated business data changes</p>
<p><strong>File</strong>: <code>templates/actions/update_entity.sql.jinja2</code></p>
<pre><code class="language-sql">-- Business data update (user changes name, description, etc.)
CREATE OR REPLACE FUNCTION {{ schema }}.update_{{ entity_lower }}(
    p_id UUID,
    p_updates JSONB,
    p_caller_id UUID DEFAULT NULL
) RETURNS mutation_result AS $$
DECLARE
    v_pk_{{ entity_lower }} INTEGER;
    v_result mutation_result;
BEGIN
    -- Resolve UUID â†’ INTEGER
    v_pk_{{ entity_lower }} := {{ schema }}.{{ entity_lower }}_pk(p_id);

    -- Update business fields
    UPDATE {{ schema }}.tb_{{ entity_lower }}
    SET
        name = COALESCE((p_updates-&gt;&gt;'name')::TEXT, name),
        description = COALESCE((p_updates-&gt;&gt;'description')::TEXT, description),
        -- ... other business fields

        -- âœ… CORRECT: Update updated_at for business changes
        updated_at = now(),
        updated_by = p_caller_id
    WHERE pk_{{ entity_lower }} = v_pk_{{ entity_lower }};

    -- Build response
    v_result.status := 'success';
    v_result.message := '{{ entity }} updated successfully';
    v_result.updated_fields := array_agg(key)
        FROM jsonb_each(p_updates);

    RETURN v_result;
END;
$$ LANGUAGE plpgsql;
</code></pre>
<hr />
<h3 id="12-identifier-recalculation-identifier_recalculated_at"><strong>1.2: Identifier Recalculation â†’ identifier_recalculated_at</strong></h3>
<p><strong>When</strong>: System recalculates identifier (due to parent change, type change, etc.)</p>
<p><strong>File</strong>: <code>templates/actions/recalculate_identifier.sql.jinja2</code></p>
<pre><code class="language-sql">-- Identifier recalculation (system-initiated)
CREATE OR REPLACE FUNCTION {{ schema }}.recalculate_{{ entity_lower }}_identifier(
    p_pk_{{ entity_lower }} INTEGER,
    p_caller_id UUID DEFAULT NULL
) RETURNS TEXT AS $$
DECLARE
    v_new_identifier TEXT;
    v_old_identifier TEXT;
BEGIN
    -- Get current identifier
    SELECT identifier INTO v_old_identifier
    FROM {{ schema }}.tb_{{ entity_lower }}
    WHERE pk_{{ entity_lower }} = p_pk_{{ entity_lower }};

    -- Calculate new identifier (business logic)
    v_new_identifier := {{ schema }}.calculate_{{ entity_lower }}_identifier(p_pk_{{ entity_lower }});

    -- Only update if changed (idempotent)
    IF v_new_identifier IS DISTINCT FROM v_old_identifier THEN
        UPDATE {{ schema }}.tb_{{ entity_lower }}
        SET
            identifier = v_new_identifier,

            -- âœ… CORRECT: Update identifier_recalculated_at (NOT updated_at)
            identifier_recalculated_at = now(),
            identifier_recalculated_by = COALESCE(p_caller_id, '00000000-0000-0000-0000-000000000000'::UUID)
            -- Note: NOT updating updated_at (no business data changed)
        WHERE pk_{{ entity_lower }} = p_pk_{{ entity_lower }};
    END IF;

    RETURN v_new_identifier;
END;
$$ LANGUAGE plpgsql;
</code></pre>
<hr />
<h3 id="13-path-recalculation-path_updated_at-explicit"><strong>1.3: Path Recalculation â†’ path_updated_at (EXPLICIT!)</strong></h3>
<p><strong>When</strong>: Parent changes (mutation EXPLICITLY recalculates paths)</p>
<p><strong>File</strong>: <code>templates/actions/move_entity.sql.jinja2</code></p>
<pre><code class="language-sql">-- Move entity to new parent (EXPLICIT path recalculation - NO TRIGGER!)
CREATE OR REPLACE FUNCTION {{ schema }}.move_{{ entity_lower }}(
    p_id UUID,
    p_new_parent_id UUID,
    p_caller_id UUID DEFAULT NULL
) RETURNS mutation_result AS $$
DECLARE
    v_{{ entity_lower }}_pk INTEGER;
    v_new_parent_pk INTEGER;
    v_paths_updated INTEGER;
    v_result mutation_result;
BEGIN
    -- Resolve UUIDs to INTEGER pks
    v_{{ entity_lower }}_pk := {{ schema }}.{{ entity_lower }}_pk(p_id);
    v_new_parent_pk := {{ schema }}.{{ entity_lower }}_pk(p_new_parent_id);

    -- Validation: Prevent circular reference
    IF EXISTS (
        SELECT 1
        FROM {{ schema }}.get_{{ entity_lower }}_descendants(p_id)
        WHERE pk_{{ entity_lower }} = v_new_parent_pk
    ) THEN
        v_result.status := 'error';
        v_result.message := 'Cannot move {{ entity_lower }} under its own descendant';
        RETURN v_result;
    END IF;

    -- Update parent
    UPDATE {{ schema }}.tb_{{ entity_lower }}
    SET
        fk_parent_{{ entity_lower }} = v_new_parent_pk,
        updated_at = now(),        -- Business change
        updated_by = p_caller_id
    WHERE pk_{{ entity_lower }} = v_{{ entity_lower }}_pk;

    -- âœ… EXPLICIT path recalculation (NO TRIGGER!)
    -- Recalculate paths for this subtree
    v_paths_updated := core.recalculate_tree_path(
        '{{ entity_lower }}',
        ROW(
            v_{{ entity_lower }}_pk,  -- INTEGER pk (NOT UUID id!)
            NULL,                     -- No tenant scope
            p_caller_id               -- Audit who triggered it
        )::core.recalculation_context
    );

    -- Success response
    v_result.status := 'success';
    v_result.message := FORMAT('{{ entity }} moved successfully (%s paths updated)', v_paths_updated);
    v_result.extra_metadata := jsonb_build_object(
        'pathsUpdated', v_paths_updated
    );

    RETURN v_result;
END;
$$ LANGUAGE plpgsql;
</code></pre>
<p><strong>Key Points</strong>:
- âœ… <strong>Explicit call</strong> to <code>core.recalculate_tree_path()</code> - NO hidden triggers!
- âœ… Returns number of paths updated for transparency
- âœ… Both <code>updated_at</code> AND <code>path_updated_at</code> are updated (business + structural change)
- âœ… Validation prevents circular references BEFORE update</p>
<hr />
<h2 id="phase-2-idempotent-recalculation-day-2">ðŸŽ¯ Phase 2: Idempotent Recalculation (Day 2)</h2>
<h3 id="objective-only-update-database-if-values-actually-changed"><strong>Objective</strong>: Only update database if values actually changed</h3>
<h3 id="21-idempotent-identifier-recalculation"><strong>2.1: Idempotent Identifier Recalculation</strong></h3>
<pre><code class="language-sql">CREATE OR REPLACE FUNCTION {{ schema }}.recalculate_{{ entity_lower }}_identifiers_bulk(
    p_tenant_id UUID DEFAULT NULL
) RETURNS INTEGER AS $$
DECLARE
    v_updated_count INTEGER := 0;
BEGIN
    WITH calculated AS (
        SELECT
            pk_{{ entity_lower }},
            {{ schema }}.calculate_{{ entity_lower }}_identifier(pk_{{ entity_lower }}) AS new_identifier,
            identifier AS old_identifier
        FROM {{ schema }}.tb_{{ entity_lower }}
        WHERE (p_tenant_id IS NULL OR tenant_id = p_tenant_id)
          AND deleted_at IS NULL
    ),
    updated_rows AS (
        UPDATE {{ schema }}.tb_{{ entity_lower }} l
        SET
            identifier = c.new_identifier,
            identifier_recalculated_at = now(),
            identifier_recalculated_by = '00000000-0000-0000-0000-000000000000'::UUID
        FROM calculated c
        WHERE l.pk_{{ entity_lower }} = c.pk_{{ entity_lower }}
          -- âœ… IDEMPOTENT: Only update if changed
          AND l.identifier IS DISTINCT FROM c.new_identifier
        RETURNING l.pk_{{ entity_lower }}
    )
    SELECT COUNT(*) INTO v_updated_count FROM updated_rows;

    RETURN v_updated_count;
END;
$$ LANGUAGE plpgsql;
</code></pre>
<p><strong>Benefits</strong>:
- âœ… No unnecessary database writes
- âœ… Doesn't trigger downstream updates if nothing changed
- âœ… Faster bulk operations
- âœ… Cleaner audit logs</p>
<hr />
<h3 id="22-idempotent-path-recalculation"><strong>2.2: Idempotent Path Recalculation</strong></h3>
<p>Already implemented in Team B's <code>recalculate_descendant_paths</code>:</p>
<pre><code class="language-sql">UPDATE {{ schema }}.tb_{{ entity_lower }} l
SET
    path = s.new_path,
    path_updated_at = now()
FROM subtree s
WHERE l.pk_{{ entity_lower }} = s.pk_{{ entity_lower }}
  AND l.path IS DISTINCT FROM s.new_path  -- âœ… IDEMPOTENT
RETURNING l.pk_{{ entity_lower }}
</code></pre>
<hr />
<h2 id="phase-3-helper-function-integration-day-3">ðŸŽ¯ Phase 3: Helper Function Integration (Day 3)</h2>
<h3 id="objective-use-generated-helper-functions-in-business-logic"><strong>Objective</strong>: Use generated helper functions in business logic</h3>
<h3 id="31-get_ancestors-in-business-logic"><strong>3.1: get_ancestors() in Business Logic</strong></h3>
<p><strong>Use Case</strong>: Check permissions on parent entities</p>
<pre><code class="language-sql">-- Example: Check if user has access to any ancestor
CREATE OR REPLACE FUNCTION {{ schema }}.user_can_access_{{ entity_lower }}(
    p_user_id UUID,
    p_{{ entity_lower }}_id UUID
) RETURNS BOOLEAN AS $$
DECLARE
    v_has_access BOOLEAN := FALSE;
BEGIN
    -- Check if user has access to this location or any ancestor
    SELECT EXISTS (
        SELECT 1
        FROM {{ schema }}.get_{{ entity_lower }}_ancestors(p_{{ entity_lower }}_id) a
        INNER JOIN {{ schema }}.user_{{ entity_lower }}_permissions p
            ON p.fk_{{ entity_lower }} = a.pk_{{ entity_lower }}
        WHERE p.fk_user = {{ schema }}.user_pk(p_user_id)
          AND p.permission_type IN ('owner', 'admin', 'edit')
    ) INTO v_has_access;

    RETURN v_has_access;
END;
$$ LANGUAGE plpgsql;
</code></pre>
<hr />
<h3 id="32-get_descendants-in-business-logic"><strong>3.2: get_descendants() in Business Logic</strong></h3>
<p><strong>Use Case</strong>: Cascade operations to children</p>
<pre><code class="language-sql">-- Example: Archive location and all descendants
CREATE OR REPLACE FUNCTION {{ schema }}.archive_{{ entity_lower }}_tree(
    p_id UUID,
    p_caller_id UUID
) RETURNS mutation_result AS $$
DECLARE
    v_pk_{{ entity_lower }} INTEGER;
    v_archived_count INTEGER;
    v_result mutation_result;
BEGIN
    v_pk_{{ entity_lower }} := {{ schema }}.{{ entity_lower }}_pk(p_id);

    -- Soft-delete this location and all descendants
    WITH archived AS (
        UPDATE {{ schema }}.tb_{{ entity_lower }} l
        SET
            deleted_at = now(),
            deleted_by = p_caller_id
        FROM {{ schema }}.get_{{ entity_lower }}_descendants(p_id) d
        WHERE l.pk_{{ entity_lower }} = d.pk_{{ entity_lower }}
          AND l.deleted_at IS NULL  -- Idempotent
        RETURNING l.pk_{{ entity_lower }}
    )
    SELECT COUNT(*) INTO v_archived_count FROM archived;

    v_result.status := 'success';
    v_result.message := FORMAT('%s {{ entity_lower }}(s) archived', v_archived_count);
    v_result.extra_metadata := jsonb_build_object(
        'archivedCount', v_archived_count
    );

    RETURN v_result;
END;
$$ LANGUAGE plpgsql;
</code></pre>
<hr />
<h3 id="33-move_subtree-in-business-logic"><strong>3.3: move_subtree() in Business Logic</strong></h3>
<p><strong>Use Case</strong>: Move location and all descendants to new parent</p>
<pre><code class="language-sql">-- Example: Move subtree (uses helper function for safety)
CREATE OR REPLACE FUNCTION {{ schema }}.move_{{ entity_lower }}_subtree(
    p_id UUID,
    p_new_parent_id UUID,
    p_caller_id UUID
) RETURNS mutation_result AS $$
DECLARE
    v_pk INTEGER;
    v_new_parent_pk INTEGER;
    v_descendant_count INTEGER;
    v_result mutation_result;
BEGIN
    v_pk := {{ schema }}.{{ entity_lower }}_pk(p_id);
    v_new_parent_pk := {{ schema }}.{{ entity_lower }}_pk(p_new_parent_id);

    -- Count descendants (for user feedback)
    SELECT COUNT(*) INTO v_descendant_count
    FROM {{ schema }}.get_{{ entity_lower }}_descendants(p_id);

    -- Move (parent change triggers path recalculation for entire subtree)
    UPDATE {{ schema }}.tb_{{ entity_lower }}
    SET
        fk_parent_{{ entity_lower }} = v_new_parent_pk,
        updated_at = now(),
        updated_by = p_caller_id
    WHERE pk_{{ entity_lower }} = v_pk;

    -- Trigger automatically recalculates paths for all descendants

    v_result.status := 'success';
    v_result.message := FORMAT(
        '{{ entity }} moved (affected: %s {{ entity_lower }}s)',
        v_descendant_count + 1
    );
    v_result.extra_metadata := jsonb_build_object(
        'affectedCount', v_descendant_count + 1
    );

    RETURN v_result;
END;
$$ LANGUAGE plpgsql;
</code></pre>
<hr />
<h2 id="phase-4-explicit-path-recalculation-compilation-day-4">ðŸŽ¯ Phase 4: Explicit Path Recalculation Compilation (Day 4)</h2>
<h3 id="objective-generate-explicit-path-recalculation-calls-in-mutations-no-triggers"><strong>Objective</strong>: Generate explicit path recalculation calls in mutations (NO TRIGGERS!)</h3>
<h3 id="41-hierarchy-impact-detection"><strong>4.1: Hierarchy Impact Detection</strong></h3>
<p><strong>File</strong>: <code>src/generators/actions/step_compiler.py</code></p>
<pre><code class="language-python">from typing import Optional
from ..ast_models import ActionAST, UpdateStep, EntityAST

def needs_path_recalculation(action: ActionAST, entity: EntityAST) -&gt; Optional[str]:
    &quot;&quot;&quot;Determine if action needs path recalculation and the scope.

    Returns:
        - 'subtree': Recalculate from modified node down
        - 'tenant': Recalculate all tenant trees
        - 'global': Recalculate entire entity
        - None: No recalculation needed
    &quot;&quot;&quot;

    # Method 1: Explicit hierarchy_impact declaration
    if hasattr(action, 'hierarchy_impact'):
        impact = action.hierarchy_impact
        if impact == 'recalculate_subtree':
            return 'subtree'
        elif impact == 'recalculate_tenant':
            return 'tenant'
        elif impact == 'recalculate_global':
            return 'global'

    # Method 2: Auto-detect from steps
    for step in action.steps:
        if isinstance(step, UpdateStep):
            # Check if parent field is being updated
            parent_field = f'fk_parent_{entity.name.lower()}'
            if parent_field in step.fields:
                return 'subtree'  # Default to subtree for parent changes

    return None


def generate_path_recalculation_call(
    entity: EntityAST,
    scope: str,
    entity_pk_var: str = None,  # Will default to v_{entity}_pk
    tenant_id_var: str = 'p_tenant_id',
    caller_id_var: str = 'p_caller_id'
) -&gt; str:
    &quot;&quot;&quot;Generate explicit call to core.recalculate_tree_path().

    Args:
        entity: Entity AST
        scope: 'subtree', 'tenant', or 'global'
        entity_pk_var: Variable name containing entity INTEGER pk (e.g., 'v_location_pk')
        tenant_id_var: Variable name containing tenant UUID
        caller_id_var: Variable name containing caller UUID

    Returns:
        SQL code for explicit recalculation
    &quot;&quot;&quot;

    entity_name = entity.name.lower()

    # Default naming convention: v_{entity}_pk
    if entity_pk_var is None:
        entity_pk_var = f'v_{entity_name}_pk'

    if scope == 'subtree':
        return f&quot;&quot;&quot;
    -- EXPLICIT path recalculation (subtree mode)
    v_paths_updated := core.recalculate_tree_path(
        '{entity_name}',
        ROW(
            {entity_pk_var},        -- INTEGER pk (e.g., v_location_pk)
            NULL,                   -- No tenant scope
            {caller_id_var}         -- Audit tracking
        )::core.recalculation_context
    );
&quot;&quot;&quot;
    elif scope == 'tenant':
        return f&quot;&quot;&quot;
    -- EXPLICIT path recalculation (tenant mode)
    v_paths_updated := core.recalculate_tree_path(
        '{entity_name}',
        ROW(
            NULL,                   -- No specific node
            {tenant_id_var},        -- Tenant scope
            {caller_id_var}         -- Audit tracking
        )::core.recalculation_context
    );
&quot;&quot;&quot;
    elif scope == 'global':
        return f&quot;&quot;&quot;
    -- EXPLICIT path recalculation (global mode)
    v_paths_updated := core.recalculate_tree_path(
        '{entity_name}',
        ROW(NULL, NULL, {caller_id_var})::core.recalculation_context
    );
&quot;&quot;&quot;
    else:
        raise ValueError(f&quot;Invalid scope: {scope}&quot;)


def compile_action_with_path_recalc(action: ActionAST, entity: EntityAST) -&gt; str:
    &quot;&quot;&quot;Compile action with automatic path recalculation injection.&quot;&quot;&quot;

    recalc_scope = needs_path_recalculation(action, entity)

    # Generate function body
    function_body = []

    # ... compile steps ...
    for step in action.steps:
        function_body.append(compile_step(step, entity))

    # Inject path recalculation if needed
    if recalc_scope and entity.hierarchical:
        entity_name = entity.name.lower()
        recalc_call = generate_path_recalculation_call(
            entity,
            recalc_scope,
            entity_pk_var=f'v_{entity_name}_pk',  # Naming convention: v_{entity}_pk
            caller_id_var='p_caller_id'
        )
        function_body.append(recalc_call)

        # Add to response metadata
        function_body.append(&quot;&quot;&quot;
    -- Include path update info in response
    v_result.extra_metadata := jsonb_build_object(
        'pathsUpdated', v_paths_updated
    );
&quot;&quot;&quot;)

    return '\n'.join(function_body)
</code></pre>
<hr />
<h3 id="42-specql-syntax-for-hierarchy-impact"><strong>4.2: SpecQL Syntax for Hierarchy Impact</strong></h3>
<p><strong>Explicit Declaration</strong> (Recommended):</p>
<pre><code class="language-yaml"># entities/location.yaml
entity: Location
hierarchical: true

actions:
  - name: move_location

    # Explicit hierarchy impact declaration
    hierarchy_impact: recalculate_subtree

    steps:
      - validate: not_circular($new_parent_id)
      - update: Location SET fk_parent_location = $new_parent_id
      # Framework auto-injects recalculation call!
</code></pre>
<p><strong>Auto-Detection</strong> (Fallback):</p>
<pre><code class="language-yaml"># If hierarchy_impact not declared, framework detects parent field changes
actions:
  - name: move_location
    steps:
      - update: Location SET fk_parent_location = $new_parent_id
      # Framework detects parent change â†’ auto-injects subtree recalculation
</code></pre>
<hr />
<h3 id="43-mutation-responsibility-matrix"><strong>4.3: Mutation Responsibility Matrix</strong></h3>
<p><strong>NO TRIGGERS! All recalculation is explicit in mutations</strong>:</p>
<table>
<thead>
<tr>
<th>Change Type</th>
<th>Where It Happens</th>
<th>Audit Fields Updated</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Business data</strong> (name, description)</td>
<td>Mutation UPDATE</td>
<td><code>updated_at</code>, <code>updated_by</code></td>
</tr>
<tr>
<td><strong>Parent change</strong></td>
<td>Mutation UPDATE + explicit recalc call</td>
<td><code>updated_at</code>, <code>updated_by</code>, <code>path_updated_at</code></td>
</tr>
<tr>
<td><strong>Identifier calc</strong></td>
<td>Mutation calculation function</td>
<td><code>identifier_recalculated_at</code>, <code>identifier_recalculated_by</code></td>
</tr>
<tr>
<td><strong>Bulk recalc</strong></td>
<td>Admin function</td>
<td><code>path_updated_at</code> (NOT <code>updated_at</code>)</td>
</tr>
</tbody>
</table>
<p><strong>Key Difference from Triggers</strong>:
- âœ… Path recalculation is <strong>visible</strong> in generated function code
- âœ… Can be <strong>tested</strong> independently
- âœ… <strong>Transaction control</strong> is explicit
- âœ… <strong>Performance</strong> is predictable (no cascading triggers)</p>
<hr />
<h2 id="summary-team-c-deliverables">ðŸ“Š Summary: Team C Deliverables</h2>
<h3 id="files-to-modify"><strong>Files to Modify</strong></h3>
<table>
<thead>
<tr>
<th>File</th>
<th>Purpose</th>
<th>Changes</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>templates/actions/update_entity.sql.jinja2</code></td>
<td>Correct audit fields</td>
<td>Update audit logic</td>
</tr>
<tr>
<td><code>templates/actions/recalculate_identifier.sql.jinja2</code></td>
<td>Idempotent recalc</td>
<td>Add <code>IS DISTINCT FROM</code></td>
</tr>
<tr>
<td><code>templates/actions/move_entity.sql.jinja2</code></td>
<td>Helper function usage</td>
<td>Use <code>move_subtree()</code></td>
</tr>
<tr>
<td><code>src/generators/actions/step_compiler.py</code></td>
<td>Detect parent changes</td>
<td>Parent change detection</td>
</tr>
</tbody>
</table>
<h3 id="new-templates"><strong>New Templates</strong></h3>
<table>
<thead>
<tr>
<th>Template</th>
<th>Purpose</th>
<th>Lines</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>templates/actions/archive_tree.sql.jinja2</code></td>
<td>Cascade operations</td>
<td>50</td>
</tr>
<tr>
<td><code>templates/actions/user_permissions.sql.jinja2</code></td>
<td>Ancestor checks</td>
<td>40</td>
</tr>
</tbody>
</table>
<h3 id="timeline"><strong>Timeline</strong></h3>
<ul>
<li><strong>Day 1</strong>: Correct audit field usage</li>
<li><strong>Day 2</strong>: Idempotent recalculation</li>
<li><strong>Day 3</strong>: Helper function integration</li>
<li><strong>Day 4</strong>: Path recalculation logic</li>
</ul>
<p><strong>Total</strong>: 4 days</p>
<hr />
<h2 id="acceptance-criteria">âœ… Acceptance Criteria</h2>
<ul>
<li>[ ] Business updates use <code>updated_at</code></li>
<li>[ ] Identifier recalculation uses <code>identifier_recalculated_at</code> (NOT <code>updated_at</code>)</li>
<li>[ ] Path updates use <code>path_updated_at</code> (set by trigger)</li>
<li>[ ] Recalculation is idempotent (only updates if changed)</li>
<li>[ ] Helper functions used in business logic</li>
<li>[ ] Parent changes trigger path recalculation for descendants</li>
<li>[ ] All tests pass</li>
</ul>
<hr />
<h2 id="dependencies">ðŸ”— Dependencies</h2>
<p><strong>Depends On</strong>:
- Team B Phase 5 (audit fields schema)
- Team B Phase 3 (path calculation functions)
- Team B Phase 9 (helper functions)</p>
<p><strong>Blocks</strong>:
- None (Team D/E can work in parallel)</p>
<hr />
<p><strong>Status</strong>: ðŸŸ¡ WAITING ON TEAM B
<strong>Priority</strong>: MEDIUM
<strong>Effort</strong>: 4 days
<strong>Start</strong>: After Team B completes Phases 3, 5, 9</p>
              
            </div>
          </div><footer>

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
          
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="Versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    
    
    
  </span>
</div>
    <script src="../../../js/jquery-3.6.0.min.js"></script>
    <script>var base_url = "../../..";</script>
    <script src="../../../js/theme_extra.js"></script>
    <script src="../../../js/theme.js"></script>
      <script src="../../../search/main.js"></script>
    <script>
        jQuery(function () {
            SphinxRtdTheme.Navigation.enable(true);
        });
    </script>

</body>
</html>
