<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
      <link rel="shortcut icon" href="../../img/favicon.ico" />
    <title>AutoFraiseQL Requirements - SpecQL Documentation</title>
    <link rel="stylesheet" href="../../css/theme.css" />
    <link rel="stylesheet" href="../../css/theme_extra.css" />
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github.min.css" />
    
      <script>
        // Current page data
        var mkdocs_page_name = "AutoFraiseQL Requirements";
        var mkdocs_page_input_path = "implementation_plans/AUTOFRAISEQL_REQUIREMENTS.md";
        var mkdocs_page_url = null;
      </script>
    
    <!--[if lt IE 9]>
      <script src="../../js/html5shiv.min.js"></script>
    <![endif]-->
      <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
      <script>hljs.highlightAll();</script> 
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
          <a href="../.." class="icon icon-home"> SpecQL Documentation
        </a><div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../../search.html" method="get">
      <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../..">Home</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="" href="../../getting-started/">Getting Started</a>
                </li>
              </ul>
              <p class="caption"><span class="caption-text">Guides</span></p>
              <ul>
                  <li class="toctree-l1"><a class="" href="../../guides/mutation-patterns/">Mutation Patterns</a>
                  </li>
                  <li class="toctree-l1"><a class="" href="../../guides/test-generation/">Test Generation</a>
                  </li>
                  <li class="toctree-l1"><a class="" href="../../guides/cli/">CLI</a>
                  </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="" href="../../reference/">Reference</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="" href="../../examples/">Examples</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="" href="../../tutorials/">Tutorials</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="" href="../../best-practices/">Best Practices</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="" href="../../troubleshooting/">Troubleshooting</a>
                </li>
              </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">
      <nav class="wy-nav-top" role="navigation" aria-label="Mobile navigation menu">
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../..">SpecQL Documentation</a>
        
      </nav>
      <div class="wy-nav-content">
        <div class="rst-content"><div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../.." class="icon icon-home" aria-label="Docs"></a></li>
      <li class="breadcrumb-item active">AutoFraiseQL Requirements</li>
    <li class="wy-breadcrumbs-aside">
    </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
            <div class="section" itemprop="articleBody">
              
                <h1 id="autofraiseql-requirements">AutoFraiseQL Requirements</h1>
<p><strong>Date</strong>: November 8, 2025
<strong>Context</strong>: SpecQL ‚Üí Database ‚Üí AutoFraiseQL Pipeline
<strong>Goal</strong>: Auto-generate complete GraphQL API from PostgreSQL metadata</p>
<hr />
<h2 id="executive-summary">Executive Summary</h2>
<p><strong>The Pipeline:</strong></p>
<pre><code>‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   SpecQL     ‚îÇ ‚îÄ‚îÄ‚ñ∂‚îÇ  PostgreSQL  ‚îÇ ‚îÄ‚îÄ‚ñ∂‚îÇ  AutoFraiseQL    ‚îÇ
‚îÇ   (YAML)     ‚îÇ    ‚îÇ  (Metadata)  ‚îÇ    ‚îÇ  (GraphQL API)   ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
     ‚îÇ                     ‚îÇ                      ‚îÇ
     ‚îÇ                     ‚îÇ                      ‚îÇ
  Business              Database              GraphQL API
   Rules               Structure            (auto-generated)
</code></pre>
<p><strong>What AutoFraiseQL needs to do:</strong></p>
<ol>
<li><strong>Introspect PostgreSQL</strong> ‚Üí Discover views, functions, types</li>
<li><strong>Parse metadata comments</strong> ‚Üí Extract <code>@fraiseql:type</code>, <code>@fraiseql:mutation</code> annotations</li>
<li><strong>Generate GraphQL schema</strong> ‚Üí Types, queries, mutations</li>
<li><strong>No Python code required</strong> ‚Üí Pure introspection-driven</li>
</ol>
<hr />
<h2 id="required-features-for-autofraiseql">üéØ Required Features for AutoFraiseQL</h2>
<h3 id="feature-1-postgresql-introspection-engine"><strong>Feature 1: PostgreSQL Introspection Engine</strong></h3>
<p><strong>What it does:</strong>
- Connects to PostgreSQL database
- Discovers all views matching pattern (e.g., <code>v_*</code>, <code>tv_*</code>)
- Discovers all functions matching pattern (e.g., <code>fn_*</code>)
- Reads COMMENT metadata from views and functions
- Parses JSONB column structure from views</p>
<p><strong>Implementation:</strong></p>
<pre><code class="language-python"># src/fraiseql/introspection/postgres_introspector.py

class PostgresIntrospector:
    &quot;&quot;&quot;Introspect PostgreSQL database for FraiseQL metadata.&quot;&quot;&quot;

    async def discover_types(
        self,
        view_pattern: str = &quot;v_%&quot;,
        schemas: list[str] = [&quot;public&quot;]
    ) -&gt; list[TypeMetadata]:
        &quot;&quot;&quot;
        Discover all views that should become GraphQL types.

        Returns:
            List of TypeMetadata with fields, descriptions, etc.
        &quot;&quot;&quot;
        query = &quot;&quot;&quot;
        SELECT
            schemaname,
            viewname,
            obj_description(c.oid, 'pg_class') as view_comment,
            jsonb_object_agg(
                a.attname,
                jsonb_build_object(
                    'type', format_type(a.atttypid, a.atttypmod),
                    'nullable', NOT a.attnotnull,
                    'comment', col_description(c.oid, a.attnum)
                )
            ) as columns
        FROM pg_views v
        JOIN pg_class c ON c.relname = v.viewname
        JOIN pg_attribute a ON a.attrelid = c.oid
        WHERE schemaname = ANY($1)
          AND viewname LIKE $2
          AND a.attnum &gt; 0
          AND NOT a.attisdropped
        GROUP BY schemaname, viewname, c.oid
        &quot;&quot;&quot;
        # Execute and parse results

    async def discover_mutations(
        self,
        function_pattern: str = &quot;fn_%&quot;,
        schemas: list[str] = [&quot;public&quot;]
    ) -&gt; list[MutationMetadata]:
        &quot;&quot;&quot;
        Discover all functions that should become GraphQL mutations.

        Returns:
            List of MutationMetadata with parameters, return types, etc.
        &quot;&quot;&quot;
        query = &quot;&quot;&quot;
        SELECT
            n.nspname as schema_name,
            p.proname as function_name,
            pg_get_function_arguments(p.oid) as arguments,
            pg_get_function_result(p.oid) as return_type,
            obj_description(p.oid, 'pg_proc') as function_comment
        FROM pg_proc p
        JOIN pg_namespace n ON n.oid = p.pronamespace
        WHERE n.nspname = ANY($1)
          AND p.proname LIKE $2
        &quot;&quot;&quot;
        # Execute and parse results
</code></pre>
<hr />
<h3 id="feature-2-metadata-parser"><strong>Feature 2: Metadata Parser</strong></h3>
<p><strong>What it does:</strong>
- Parses <code>@fraiseql:type</code> annotations from view comments
- Parses <code>@fraiseql:mutation</code> annotations from function comments
- Extracts YAML-like metadata from comments
- Validates metadata structure</p>
<p><strong>Implementation:</strong></p>
<pre><code class="language-python"># src/fraiseql/introspection/metadata_parser.py

from dataclasses import dataclass
from typing import Optional
import yaml

@dataclass
class TypeAnnotation:
    &quot;&quot;&quot;Parsed @fraiseql:type annotation.&quot;&quot;&quot;
    trinity: bool = False
    use_projection: bool = False
    description: Optional[str] = None
    expose_fields: Optional[list[str]] = None

@dataclass
class MutationAnnotation:
    &quot;&quot;&quot;Parsed @fraiseql:mutation annotation.&quot;&quot;&quot;
    input_schema: dict[str, dict]
    success_type: str
    failure_type: str
    description: Optional[str] = None

class MetadataParser:
    &quot;&quot;&quot;Parse @fraiseql annotations from PostgreSQL comments.&quot;&quot;&quot;

    def parse_type_annotation(self, comment: str) -&gt; Optional[TypeAnnotation]:
        &quot;&quot;&quot;
        Parse @fraiseql:type annotation.

        Example input:
            @fraiseql:type
            trinity: true
            use_projection: false
            description: User account
            expose_fields:
              - id
              - identifier
              - email

        Returns:
            TypeAnnotation instance or None
        &quot;&quot;&quot;
        if not comment or '@fraiseql:type' not in comment:
            return None

        # Extract YAML after @fraiseql:type marker
        yaml_start = comment.index('@fraiseql:type') + len('@fraiseql:type')
        yaml_content = comment[yaml_start:].strip()

        # Parse YAML
        data = yaml.safe_load(yaml_content)

        return TypeAnnotation(
            trinity=data.get('trinity', False),
            use_projection=data.get('use_projection', False),
            description=data.get('description'),
            expose_fields=data.get('expose_fields')
        )

    def parse_mutation_annotation(self, comment: str) -&gt; Optional[MutationAnnotation]:
        &quot;&quot;&quot;
        Parse @fraiseql:mutation annotation.

        Example input:
            @fraiseql:mutation
            input:
              name:
                type: string
                description: User full name
              email:
                type: string
                description: Email address
            success: User
            failure: ValidationError
            description: Create a new user

        Returns:
            MutationAnnotation instance or None
        &quot;&quot;&quot;
        if not comment or '@fraiseql:mutation' not in comment:
            return None

        yaml_start = comment.index('@fraiseql:mutation') + len('@fraiseql:mutation')
        yaml_content = comment[yaml_start:].strip()

        data = yaml.safe_load(yaml_content)

        return MutationAnnotation(
            input_schema=data.get('input', {}),
            success_type=data['success'],
            failure_type=data['failure'],
            description=data.get('description')
        )
</code></pre>
<hr />
<h3 id="feature-3-type-generator-from-views"><strong>Feature 3: Type Generator (from Views)</strong></h3>
<p><strong>What it does:</strong>
- Takes TypeMetadata from introspection
- Generates Python <code>@type</code> classes dynamically
- Maps PostgreSQL types ‚Üí Python types
- Handles trinity pattern (id, identifier, data)</p>
<p><strong>Implementation:</strong></p>
<pre><code class="language-python"># src/fraiseql/introspection/type_generator.py

from typing import Type, Any
from fraiseql import type as fraiseql_type

class TypeGenerator:
    &quot;&quot;&quot;Generate FraiseQL @type classes from database metadata.&quot;&quot;&quot;

    # PostgreSQL type ‚Üí Python type mapping
    TYPE_MAPPING = {
        'uuid': 'UUID',
        'text': 'str',
        'character varying': 'str',
        'integer': 'int',
        'bigint': 'int',
        'boolean': 'bool',
        'timestamp with time zone': 'datetime',
        'timestamp without time zone': 'datetime',
        'date': 'date',
        'jsonb': 'dict',
        'json': 'dict',
        'numeric': 'Decimal',
        'double precision': 'float',
    }

    def generate_type_class(
        self,
        type_metadata: TypeMetadata,
        annotation: TypeAnnotation
    ) -&gt; Type:
        &quot;&quot;&quot;
        Generate a FraiseQL @type class dynamically.

        Args:
            type_metadata: Metadata from PostgreSQL introspection
            annotation: Parsed @fraiseql:type annotation

        Returns:
            Dynamically created Python class with @type decorator
        &quot;&quot;&quot;
        # Build class attributes
        attributes = {}
        annotations = {}

        # Parse JSONB data column to extract fields
        if 'data' in type_metadata.columns:
            # Introspect a sample row to get JSONB structure
            sample_data = self._get_sample_data(type_metadata.view_name)
            if sample_data:
                for field_name, field_value in sample_data.items():
                    python_type = self._infer_python_type(field_value)
                    annotations[field_name] = python_type

        # Create class dynamically
        cls_name = self._to_pascal_case(type_metadata.view_name.replace('v_', ''))

        cls = type(
            cls_name,
            (object,),
            {
                '__annotations__': annotations,
                '__doc__': annotation.description,
                **attributes
            }
        )

        # Apply @type decorator
        decorated_cls = fraiseql_type(
            sql_source=type_metadata.view_name,
            jsonb_column=&quot;data&quot;
        )(cls)

        return decorated_cls

    def _get_sample_data(self, view_name: str) -&gt; dict:
        &quot;&quot;&quot;Query one row from view to inspect JSONB structure.&quot;&quot;&quot;
        query = f&quot;SELECT data FROM {view_name} LIMIT 1&quot;
        # Execute and return first row's data column

    def _infer_python_type(self, value: Any) -&gt; str:
        &quot;&quot;&quot;Infer Python type annotation from JSON value.&quot;&quot;&quot;
        if isinstance(value, bool):
            return 'bool'
        elif isinstance(value, int):
            return 'int'
        elif isinstance(value, float):
            return 'float'
        elif isinstance(value, str):
            return 'str'
        elif isinstance(value, list):
            return 'list'
        elif isinstance(value, dict):
            return 'dict'
        else:
            return 'Any'

    def _to_pascal_case(self, snake_str: str) -&gt; str:
        &quot;&quot;&quot;Convert snake_case to PascalCase.&quot;&quot;&quot;
        return ''.join(word.capitalize() for word in snake_str.split('_'))
</code></pre>
<hr />
<h3 id="feature-4-query-generator-auto-generate-queries"><strong>Feature 4: Query Generator (Auto-Generate Queries)</strong></h3>
<p><strong>What it does:</strong>
- For each discovered type, generates standard queries:
  - <code>find_one(id)</code> ‚Üí Single item by ID
  - <code>find_all(where, order_by, limit, offset)</code> ‚Üí List with filters
  - <code>connection(first, after, where)</code> ‚Üí Relay-style pagination
- No Python code needed from user</p>
<p><strong>Implementation:</strong></p>
<pre><code class="language-python"># src/fraiseql/introspection/query_generator.py

from fraiseql import query

class QueryGenerator:
    &quot;&quot;&quot;Generate standard queries for each discovered type.&quot;&quot;&quot;

    def generate_queries_for_type(
        self,
        type_class: Type,
        view_name: str
    ) -&gt; list[callable]:
        &quot;&quot;&quot;
        Generate standard queries for a type.

        Returns:
            List of query functions decorated with @query
        &quot;&quot;&quot;
        queries = []

        # 1. Generate find_one query
        @query
        async def find_one(info, id: UUID) -&gt; Optional[type_class]:
            db = info.context[&quot;db&quot;]
            result = await db.find_one(view_name, where={&quot;id&quot;: id})
            return result

        # Rename function dynamically
        find_one.__name__ = f&quot;{type_class.__name__.lower()}&quot;
        queries.append(find_one)

        # 2. Generate find_all query
        @query
        async def find_all(
            info,
            where: Optional[dict] = None,
            order_by: Optional[dict] = None,
            limit: Optional[int] = None,
            offset: Optional[int] = None
        ) -&gt; list[type_class]:
            db = info.context[&quot;db&quot;]
            results = await db.find(
                view_name,
                where=where,
                order_by=order_by,
                limit=limit,
                offset=offset
            )
            return results

        find_all.__name__ = f&quot;{type_class.__name__.lower()}s&quot;
        queries.append(find_all)

        # 3. Generate connection query (Relay pagination)
        @query
        async def connection(
            info,
            first: Optional[int] = None,
            after: Optional[str] = None,
            where: Optional[dict] = None
        ) -&gt; Connection[type_class]:
            db = info.context[&quot;db&quot;]
            # Implement Relay connection pattern
            # ...

        connection.__name__ = f&quot;{type_class.__name__.lower()}Connection&quot;
        queries.append(connection)

        return queries
</code></pre>
<hr />
<h3 id="feature-5-mutation-generator-from-functions"><strong>Feature 5: Mutation Generator (from Functions)</strong></h3>
<p><strong>What it does:</strong>
- For each discovered function with <code>@fraiseql:mutation</code>, generates GraphQL mutation
- Parses function parameters ‚Üí GraphQL input type
- Parses function return type ‚Üí Union[SuccessType, FailureType]
- Handles JSONB return format</p>
<p><strong>Implementation:</strong></p>
<pre><code class="language-python"># src/fraiseql/introspection/mutation_generator.py

from fraiseql import mutation
from typing import Union

class MutationGenerator:
    &quot;&quot;&quot;Generate mutations from PostgreSQL functions.&quot;&quot;&quot;

    def generate_mutation_for_function(
        self,
        function_metadata: MutationMetadata,
        annotation: MutationAnnotation,
        type_registry: dict[str, Type]
    ) -&gt; callable:
        &quot;&quot;&quot;
        Generate a mutation from a PostgreSQL function.

        Args:
            function_metadata: Metadata from introspection
            annotation: Parsed @fraiseql:mutation annotation
            type_registry: Map of type names to Python classes

        Returns:
            Mutation function decorated with @mutation
        &quot;&quot;&quot;
        # Get success/failure types
        success_type = type_registry[annotation.success_type]
        failure_type = type_registry[annotation.failure_type]

        # Build input class dynamically
        input_class = self._build_input_class(
            annotation.input_schema,
            function_metadata.function_name
        )

        # Generate mutation function
        @mutation
        async def mutation_fn(
            info,
            input: input_class
        ) -&gt; Union[success_type, failure_type]:
            db = info.context[&quot;db&quot;]

            # Call PostgreSQL function
            result = await db.execute_function(
                function_metadata.function_name,
                **input.__dict__
            )

            # Parse JSONB result
            if result.get('success'):
                # Return success type
                return success_type(**result[annotation.success_type.lower()])
            else:
                # Return failure type
                return failure_type(**result)

        # Rename function
        mutation_fn.__name__ = self._to_camel_case(
            function_metadata.function_name.replace('fn_', '')
        )
        mutation_fn.__doc__ = annotation.description

        return mutation_fn

    def _build_input_class(
        self,
        input_schema: dict,
        function_name: str
    ) -&gt; Type:
        &quot;&quot;&quot;Build GraphQL input class from schema.&quot;&quot;&quot;
        class_name = f&quot;{self._to_pascal_case(function_name)}Input&quot;

        annotations = {}
        for field_name, field_def in input_schema.items():
            python_type = self._graphql_type_to_python(field_def['type'])
            annotations[field_name] = python_type

        input_cls = type(
            class_name,
            (object,),
            {'__annotations__': annotations}
        )

        return input_cls

    def _graphql_type_to_python(self, graphql_type: str) -&gt; str:
        &quot;&quot;&quot;Map GraphQL type string to Python type.&quot;&quot;&quot;
        mapping = {
            'string': 'str',
            'int': 'int',
            'boolean': 'bool',
            'float': 'float',
            'uuid': 'UUID',
        }
        return mapping.get(graphql_type.lower(), 'str')
</code></pre>
<hr />
<h3 id="feature-6-whereinput-orderby-auto-generation"><strong>Feature 6: WhereInput &amp; OrderBy Auto-Generation</strong></h3>
<p><strong>What it does:</strong>
- For each type, generates <code>WhereInput</code> with field-specific operators
- For each type, generates <code>OrderByInput</code> with ASC/DESC options
- Uses existing FraiseQL filter generation (Issue #122, #124)</p>
<p><strong>Implementation:</strong></p>
<pre><code class="language-python"># src/fraiseql/introspection/filter_generator.py

class FilterGenerator:
    &quot;&quot;&quot;Auto-generate WhereInput and OrderBy types.&quot;&quot;&quot;

    def generate_where_input(
        self,
        type_class: Type,
        type_metadata: TypeMetadata
    ) -&gt; Type:
        &quot;&quot;&quot;
        Generate WhereInput type for filtering.

        Leverages existing auto-generation from Issue #122/#124.
        &quot;&quot;&quot;
        # Use existing fraiseql.sql.graphql_where_generator
        from fraiseql.sql.graphql_where_generator import generate_where_input_type

        where_input = generate_where_input_type(
            type_name=type_class.__name__,
            fields=type_metadata.columns,
            sql_source=type_metadata.view_name
        )

        return where_input

    def generate_order_by_input(
        self,
        type_class: Type,
        type_metadata: TypeMetadata
    ) -&gt; Type:
        &quot;&quot;&quot;
        Generate OrderByInput type for sorting.

        Leverages existing auto-generation.
        &quot;&quot;&quot;
        from fraiseql.sql.graphql_order_by_generator import generate_order_by_type

        order_by = generate_order_by_type(
            type_name=type_class.__name__,
            fields=type_metadata.columns
        )

        return order_by
</code></pre>
<hr />
<h3 id="feature-7-auto-discovery-api"><strong>Feature 7: Auto-Discovery API</strong></h3>
<p><strong>What it does:</strong>
- Main entry point for users
- Orchestrates introspection ‚Üí generation ‚Üí app creation
- Single function call: <code>auto_discover=True</code></p>
<p><strong>Implementation:</strong></p>
<pre><code class="language-python"># src/fraiseql/auto_discovery.py

from fraiseql.introspection import (
    PostgresIntrospector,
    MetadataParser,
    TypeGenerator,
    QueryGenerator,
    MutationGenerator,
    FilterGenerator
)

class AutoDiscovery:
    &quot;&quot;&quot;Auto-discover and generate GraphQL API from PostgreSQL.&quot;&quot;&quot;

    def __init__(
        self,
        database_url: str,
        view_pattern: str = &quot;v_%&quot;,
        function_pattern: str = &quot;fn_%&quot;,
        schemas: list[str] = [&quot;public&quot;]
    ):
        self.database_url = database_url
        self.view_pattern = view_pattern
        self.function_pattern = function_pattern
        self.schemas = schemas

        self.introspector = PostgresIntrospector(database_url)
        self.metadata_parser = MetadataParser()
        self.type_generator = TypeGenerator()
        self.query_generator = QueryGenerator()
        self.mutation_generator = MutationGenerator()
        self.filter_generator = FilterGenerator()

    async def discover_all(self) -&gt; dict:
        &quot;&quot;&quot;
        Discover and generate complete GraphQL schema.

        Returns:
            {
                'types': [User, Post, ...],
                'queries': [user, users, post, posts, ...],
                'mutations': [createUser, updateUser, ...],
                'where_inputs': {...},
                'order_by_inputs': {...}
            }
        &quot;&quot;&quot;
        result = {
            'types': [],
            'queries': [],
            'mutations': [],
            'where_inputs': {},
            'order_by_inputs': {}
        }

        # 1. Discover types from views
        type_metadata_list = await self.introspector.discover_types(
            view_pattern=self.view_pattern,
            schemas=self.schemas
        )

        type_registry = {}

        for type_metadata in type_metadata_list:
            # Parse annotation
            annotation = self.metadata_parser.parse_type_annotation(
                type_metadata.view_comment
            )

            if not annotation:
                continue  # Skip views without @fraiseql:type

            # Generate type class
            type_class = self.type_generator.generate_type_class(
                type_metadata,
                annotation
            )

            result['types'].append(type_class)
            type_registry[type_class.__name__] = type_class

            # Generate queries for this type
            queries = self.query_generator.generate_queries_for_type(
                type_class,
                type_metadata.view_name
            )
            result['queries'].extend(queries)

            # Generate filter inputs
            where_input = self.filter_generator.generate_where_input(
                type_class,
                type_metadata
            )
            order_by = self.filter_generator.generate_order_by_input(
                type_class,
                type_metadata
            )

            result['where_inputs'][type_class.__name__] = where_input
            result['order_by_inputs'][type_class.__name__] = order_by

        # 2. Discover mutations from functions
        mutation_metadata_list = await self.introspector.discover_mutations(
            function_pattern=self.function_pattern,
            schemas=self.schemas
        )

        for mutation_metadata in mutation_metadata_list:
            # Parse annotation
            annotation = self.metadata_parser.parse_mutation_annotation(
                mutation_metadata.function_comment
            )

            if not annotation:
                continue  # Skip functions without @fraiseql:mutation

            # Generate mutation
            mutation_fn = self.mutation_generator.generate_mutation_for_function(
                mutation_metadata,
                annotation,
                type_registry
            )

            result['mutations'].append(mutation_fn)

        return result


# Public API
async def auto_discover(
    database_url: str,
    **options
) -&gt; dict:
    &quot;&quot;&quot;
    Auto-discover GraphQL API from PostgreSQL metadata.

    Usage:
        schema = await auto_discover(&quot;postgresql://localhost/mydb&quot;)
        app = create_fraiseql_app(**schema)
    &quot;&quot;&quot;
    discovery = AutoDiscovery(database_url, **options)
    return await discovery.discover_all()
</code></pre>
<hr />
<h3 id="feature-8-updated-create_fraiseql_app"><strong>Feature 8: Updated create_fraiseql_app</strong></h3>
<p><strong>What it does:</strong>
- Extends existing <code>create_fraiseql_app</code> to support <code>auto_discover=True</code>
- Handles auto-discovered types, queries, mutations</p>
<p><strong>Implementation:</strong></p>
<pre><code class="language-python"># src/fraiseql/fastapi/__init__.py (extend existing)

from fraiseql.auto_discovery import auto_discover

async def create_fraiseql_app(
    database_url: str,
    types: Optional[list[Type]] = None,
    queries: Optional[list[callable]] = None,
    mutations: Optional[list[callable]] = None,
    auto_discover: bool = False,  # NEW
    auto_discover_options: Optional[dict] = None,  # NEW
    **kwargs
):
    &quot;&quot;&quot;
    Create FraiseQL FastAPI application.

    Args:
        database_url: PostgreSQL connection string
        types: List of @type classes (optional if auto_discover=True)
        queries: List of @query functions (optional if auto_discover=True)
        mutations: List of @mutation functions (optional if auto_discover=True)
        auto_discover: Enable automatic schema discovery from PostgreSQL
        auto_discover_options: Options for auto-discovery
    &quot;&quot;&quot;
    if auto_discover:
        # Auto-discover schema from database
        schema = await auto_discover(
            database_url,
            **(auto_discover_options or {})
        )

        # Merge with manually defined types/queries/mutations
        types = (types or []) + schema['types']
        queries = (queries or []) + schema['queries']
        mutations = (mutations or []) + schema['mutations']

    # Existing app creation logic
    # ...
</code></pre>
<hr />
<h2 id="implementation-checklist">üìã Implementation Checklist</h2>
<h3 id="phase-1-core-introspection-week-1"><strong>Phase 1: Core Introspection (Week 1)</strong></h3>
<ul>
<li>[ ] <strong>PostgresIntrospector</strong> class</li>
<li>[ ] <code>discover_types()</code> - Find views with metadata</li>
<li>[ ] <code>discover_mutations()</code> - Find functions with metadata</li>
<li>
<p>[ ] Connection pooling and error handling</p>
</li>
<li>
<p>[ ] <strong>MetadataParser</strong> class</p>
</li>
<li>[ ] <code>parse_type_annotation()</code> - Parse <code>@fraiseql:type</code></li>
<li>[ ] <code>parse_mutation_annotation()</code> - Parse <code>@fraiseql:mutation</code></li>
<li>[ ] YAML parsing and validation</li>
</ul>
<p><strong>Deliverable</strong>: Can introspect database and parse metadata</p>
<hr />
<h3 id="phase-2-type-generation-week-2"><strong>Phase 2: Type Generation (Week 2)</strong></h3>
<ul>
<li>[ ] <strong>TypeGenerator</strong> class</li>
<li>[ ] <code>generate_type_class()</code> - Create Python classes dynamically</li>
<li>[ ] PostgreSQL type ‚Üí Python type mapping</li>
<li>[ ] JSONB column introspection</li>
<li>
<p>[ ] Handle trinity pattern (id, identifier, data)</p>
</li>
<li>
<p>[ ] <strong>Unit tests</strong> for type generation</p>
</li>
<li>[ ] Test all PostgreSQL type mappings</li>
<li>[ ] Test JSONB field extraction</li>
<li>[ ] Test class decoration</li>
</ul>
<p><strong>Deliverable</strong>: Can generate @type classes from views</p>
<hr />
<h3 id="phase-3-query-generation-week-3"><strong>Phase 3: Query Generation (Week 3)</strong></h3>
<ul>
<li>[ ] <strong>QueryGenerator</strong> class</li>
<li>[ ] <code>generate_queries_for_type()</code> - Standard queries</li>
<li>[ ] find_one(id) query</li>
<li>[ ] find_all(where, order_by) query</li>
<li>
<p>[ ] connection(first, after) query (Relay)</p>
</li>
<li>
<p>[ ] <strong>Integration tests</strong></p>
</li>
<li>[ ] Test generated queries execute correctly</li>
<li>[ ] Test filtering with WhereInput</li>
<li>[ ] Test sorting with OrderBy</li>
</ul>
<p><strong>Deliverable</strong>: Can generate queries automatically</p>
<hr />
<h3 id="phase-4-mutation-generation-week-4"><strong>Phase 4: Mutation Generation (Week 4)</strong></h3>
<ul>
<li>[ ] <strong>MutationGenerator</strong> class</li>
<li>[ ] <code>generate_mutation_for_function()</code> - Create mutations</li>
<li>[ ] Parse function parameters ‚Üí GraphQL input</li>
<li>[ ] Handle JSONB return type</li>
<li>
<p>[ ] Union[Success, Failure] return types</p>
</li>
<li>
<p>[ ] <strong>Integration tests</strong></p>
</li>
<li>[ ] Test mutation execution</li>
<li>[ ] Test success/failure handling</li>
<li>[ ] Test input validation</li>
</ul>
<p><strong>Deliverable</strong>: Can generate mutations from functions</p>
<hr />
<h3 id="phase-5-filter-auto-generation-week-5"><strong>Phase 5: Filter Auto-Generation (Week 5)</strong></h3>
<ul>
<li>[ ] <strong>FilterGenerator</strong> class</li>
<li>[ ] Integrate with existing <code>graphql_where_generator.py</code></li>
<li>[ ] Integrate with existing <code>graphql_order_by_generator.py</code></li>
<li>[ ] Generate WhereInput per type</li>
<li>
<p>[ ] Generate OrderByInput per type</p>
</li>
<li>
<p>[ ] <strong>Tests</strong></p>
</li>
<li>[ ] Test filter generation for all field types</li>
<li>[ ] Test operator availability (eq, neq, gt, contains, etc.)</li>
</ul>
<p><strong>Deliverable</strong>: Auto-generated filters work end-to-end</p>
<hr />
<h3 id="phase-6-auto-discovery-api-week-6"><strong>Phase 6: Auto-Discovery API (Week 6)</strong></h3>
<ul>
<li>[ ] <strong>AutoDiscovery</strong> class</li>
<li>[ ] <code>discover_all()</code> - Orchestrate full discovery</li>
<li>[ ] Handle type registry (resolve references)</li>
<li>
<p>[ ] Error handling and logging</p>
</li>
<li>
<p>[ ] <strong>Updated create_fraiseql_app</strong></p>
</li>
<li>[ ] <code>auto_discover=True</code> parameter</li>
<li>[ ] Merge auto-discovered + manual schema</li>
<li>
<p>[ ] Documentation</p>
</li>
<li>
<p>[ ] <strong>End-to-end tests</strong></p>
</li>
<li>[ ] Test complete pipeline: DB ‚Üí GraphQL</li>
<li>[ ] Test with printoptim_backend schema</li>
<li>[ ] Performance benchmarks</li>
</ul>
<p><strong>Deliverable</strong>: Full auto-discovery works end-to-end</p>
<hr />
<h3 id="phase-7-production-polish-week-7-8"><strong>Phase 7: Production Polish (Week 7-8)</strong></h3>
<ul>
<li>[ ] <strong>Error handling</strong></li>
<li>[ ] Graceful handling of missing metadata</li>
<li>[ ] Validation of @fraiseql annotations</li>
<li>
<p>[ ] Helpful error messages</p>
</li>
<li>
<p>[ ] <strong>Performance</strong></p>
</li>
<li>[ ] Cache introspection results</li>
<li>[ ] Lazy loading of types</li>
<li>
<p>[ ] Connection pooling</p>
</li>
<li>
<p>[ ] <strong>Documentation</strong></p>
</li>
<li>[ ] Usage guide for auto-discovery</li>
<li>[ ] Migration guide (manual ‚Üí auto)</li>
<li>
<p>[ ] Best practices for metadata annotations</p>
</li>
<li>
<p>[ ] <strong>Examples</strong></p>
</li>
<li>[ ] Complete example with SpecQL ‚Üí AutoFraiseQL</li>
<li>[ ] Real-world use cases</li>
</ul>
<p><strong>Deliverable</strong>: Production-ready AutoFraiseQL</p>
<hr />
<h2 id="api-usage-example">üéØ API Usage Example</h2>
<h3 id="before-manual-fraiseql"><strong>Before (Manual FraiseQL)</strong></h3>
<pre><code class="language-python">from fraiseql import type, query, mutation
from fraiseql.fastapi import create_fraiseql_app

# Must define every type manually
@type(sql_source=&quot;v_user&quot;)
class User:
    id: UUID
    identifier: str
    email: str
    name: str

# Must define every query manually
@query
async def user(info, id: UUID) -&gt; User:
    db = info.context[&quot;db&quot;]
    return await db.find_one(&quot;v_user&quot;, where={&quot;id&quot;: id})

@query
async def users(info, where: dict = None) -&gt; list[User]:
    db = info.context[&quot;db&quot;]
    return await db.find(&quot;v_user&quot;, where=where)

# Must define every mutation manually
@mutation
async def create_user(info, name: str, email: str) -&gt; User:
    # ...

app = create_fraiseql_app(
    database_url=&quot;postgresql://localhost/mydb&quot;,
    types=[User],
    queries=[user, users],
    mutations=[create_user]
)
</code></pre>
<p><strong>Lines of Python code</strong>: ~40 lines</p>
<hr />
<h3 id="after-autofraiseql"><strong>After (AutoFraiseQL)</strong></h3>
<pre><code class="language-python">from fraiseql.fastapi import create_fraiseql_app

# PostgreSQL already has metadata:
# COMMENT ON VIEW v_user IS '@fraiseql:type ...'
# COMMENT ON FUNCTION fn_create_user IS '@fraiseql:mutation ...'

app = create_fraiseql_app(
    database_url=&quot;postgresql://localhost/mydb&quot;,
    auto_discover=True  # üéØ That's it!
)
</code></pre>
<p><strong>Lines of Python code</strong>: ~5 lines</p>
<p><strong>Reduction</strong>: 87% less code</p>
<hr />
<h2 id="key-design-decisions">üí° Key Design Decisions</h2>
<h3 id="1-metadata-in-postgresql-comments"><strong>1. Metadata in PostgreSQL Comments</strong></h3>
<p><strong>Why?</strong>
- Single source of truth (database schema)
- Version controlled with migrations
- Visible in database tools (pgAdmin, DBeaver)
- No external configuration files</p>
<p><strong>Format:</strong></p>
<pre><code class="language-sql">COMMENT ON VIEW v_user IS '@fraiseql:type
trinity: true
description: User account';
</code></pre>
<hr />
<h3 id="2-yaml-in-comments"><strong>2. YAML in Comments</strong></h3>
<p><strong>Why?</strong>
- Readable and writable by humans
- Structured data (not just text)
- Easy to parse (yaml library)
- Familiar to developers</p>
<hr />
<h3 id="3-pattern-based-discovery"><strong>3. Pattern-Based Discovery</strong></h3>
<p><strong>Why?</strong>
- Explicit opt-in (views/functions must match pattern)
- Prevents accidental exposure
- Follows PostgreSQL conventions (v_<em>, fn_</em>)</p>
<p><strong>Configuration:</strong></p>
<pre><code class="language-python">auto_discover=True,
auto_discover_options={
    'view_pattern': 'v_%',     # Only v_* views
    'function_pattern': 'fn_%', # Only fn_* functions
    'schemas': ['public', 'catalog']  # Specific schemas
}
</code></pre>
<hr />
<h3 id="4-merge-auto-manual"><strong>4. Merge Auto + Manual</strong></h3>
<p><strong>Why?</strong>
- Gradual migration path
- Custom logic for complex cases
- Override auto-generated behavior</p>
<p><strong>Example:</strong></p>
<pre><code class="language-python"># Some types auto-discovered, some manual
app = create_fraiseql_app(
    database_url=&quot;...&quot;,
    auto_discover=True,  # Discovers 90% of schema
    types=[CustomComplexType],  # Override 10% manually
    queries=[custom_query]
)
</code></pre>
<hr />
<h2 id="benefits">üöÄ Benefits</h2>
<h3 id="1-developer-productivity"><strong>1. Developer Productivity</strong></h3>
<ul>
<li><strong>Before</strong>: 40 lines Python per entity</li>
<li><strong>After</strong>: 0 lines Python (just metadata in SQL)</li>
<li><strong>Speedup</strong>: 10-20x faster development</li>
</ul>
<h3 id="2-maintainability"><strong>2. Maintainability</strong></h3>
<ul>
<li><strong>Single source of truth</strong>: Database schema</li>
<li><strong>Version controlled</strong>: SQL migrations</li>
<li><strong>No code duplication</strong>: Type definitions in one place</li>
</ul>
<h3 id="3-specql-compatibility"><strong>3. SpecQL Compatibility</strong></h3>
<pre><code>SpecQL (YAML) ‚Üí SQL Generator ‚Üí PostgreSQL (with metadata)
                                       ‚Üì
                                 AutoFraiseQL
                                       ‚Üì
                                  GraphQL API
</code></pre>
<p><strong>Complete pipeline</strong>: YAML business logic ‚Üí Working API (no Python)</p>
<hr />
<h2 id="success-criteria">‚úÖ Success Criteria</h2>
<p>AutoFraiseQL is successful when:</p>
<ol>
<li>‚úÖ <strong>Zero Python code required</strong> for standard CRUD operations</li>
<li>‚úÖ <strong>Complete introspection</strong> of views, functions, types from PostgreSQL</li>
<li>‚úÖ <strong>Metadata-driven</strong> schema generation from comments</li>
<li>‚úÖ <strong>Compatible with SpecQL</strong> generated schemas</li>
<li>‚úÖ <strong>Performance</strong> equivalent to manual FraiseQL</li>
<li>‚úÖ <strong>Production-ready</strong> error handling, caching, docs</li>
<li>‚úÖ <strong>Backward compatible</strong> with existing manual FraiseQL apps</li>
</ol>
<hr />
<h2 id="estimated-effort">üìä Estimated Effort</h2>
<table>
<thead>
<tr>
<th>Phase</th>
<th>Duration</th>
<th>Complexity</th>
</tr>
</thead>
<tbody>
<tr>
<td>Core Introspection</td>
<td>1 week</td>
<td>Medium</td>
</tr>
<tr>
<td>Type Generation</td>
<td>1 week</td>
<td>Medium</td>
</tr>
<tr>
<td>Query Generation</td>
<td>1 week</td>
<td>Low</td>
</tr>
<tr>
<td>Mutation Generation</td>
<td>1 week</td>
<td>High</td>
</tr>
<tr>
<td>Filter Auto-Gen</td>
<td>1 week</td>
<td>Low (leverage existing)</td>
</tr>
<tr>
<td>Auto-Discovery API</td>
<td>1 week</td>
<td>Medium</td>
</tr>
<tr>
<td>Production Polish</td>
<td>2 weeks</td>
<td>Medium</td>
</tr>
<tr>
<td><strong>Total</strong></td>
<td><strong>8 weeks</strong></td>
<td><strong>Medium-High</strong></td>
</tr>
</tbody>
</table>
<hr />
<h2 id="next-steps">üéØ Next Steps</h2>
<ol>
<li><strong>Validate approach</strong> with FraiseQL team</li>
<li><strong>Create POC</strong> for introspection + type generation (Week 1)</li>
<li><strong>Iterate</strong> based on feedback</li>
<li><strong>Full implementation</strong> (Weeks 2-8)</li>
<li><strong>Release</strong> as FraiseQL v2.0 or v1.4 feature</li>
</ol>
<hr />
<p><strong>END OF REQUIREMENTS DOCUMENT</strong></p>
              
            </div>
          </div><footer>

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
          
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="Versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    
    
    
  </span>
</div>
    <script src="../../js/jquery-3.6.0.min.js"></script>
    <script>var base_url = "../..";</script>
    <script src="../../js/theme_extra.js"></script>
    <script src="../../js/theme.js"></script>
      <script src="../../search/main.js"></script>
    <script>
        jQuery(function () {
            SphinxRtdTheme.Navigation.enable(true);
        });
    </script>

</body>
</html>
