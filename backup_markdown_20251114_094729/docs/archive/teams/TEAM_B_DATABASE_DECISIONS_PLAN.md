# Team B: Database Decisions Implementation Plan

**Team**: Schema Generator
**Impact**: CRITICAL (major architectural changes)
**Timeline**: Week 2-3 (8-10 days)
**Status**: âœ… COMPLETED - All 8 database patterns implemented

---

## ðŸ“‹ Overview

Team B must implement **8 major database patterns** based on approved architectural decisions:

1. âœ… 3-field deduplication pattern
2. âœ… `safe_slug()` utility function
3. âœ… INTEGER-based LTREE paths
4. âœ… Partial indexes (`WHERE deleted_at IS NULL`)
5. âœ… Separate recalculation audit fields
6. âœ… Tenant-scoped composite indexes
7. âœ… 3 safety constraint triggers
8. âœ… Node+Info split pattern (opt-in)
8. âœ… Node+info split pattern (opt-in)

**Total Effort**: 8-10 days (2 weeks)

---

## ðŸŽ¯ Phase 1: Utility Functions & Extensions (Day 1)

### **Objective**: Generate foundational database utilities

### **1.1: Extensions Migration**

**File**: `templates/sql/000_extensions.sql.jinja2`

```sql
-- Required PostgreSQL Extensions
-- Generated by SpecQL Framework

-- Unaccent: Remove accents from text (for safe_slug function)
CREATE EXTENSION IF NOT EXISTS unaccent;

-- LTREE: Hierarchical tree structures
CREATE EXTENSION IF NOT EXISTS ltree;

-- UUID: Generate UUIDs
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";

-- Framework metadata
COMMENT ON EXTENSION unaccent IS '@specql:required Framework requires unaccent for identifier slugification';
COMMENT ON EXTENSION ltree IS '@specql:conditional Required for hierarchical entities';
```

---

### **1.2: safe_slug() Utility Function**

**File**: `templates/sql/utilities/safe_slug.sql.jinja2`

```sql
-- safe_slug: Convert text to URL-safe slug
-- Based on printoptim_backend implementation
-- Handles edge cases: empty strings, all digits, special chars

CREATE OR REPLACE FUNCTION public.safe_slug(
    value TEXT,
    fallback TEXT DEFAULT 'unnamed'
) RETURNS TEXT AS $$
DECLARE
    result TEXT;
BEGIN
    -- Handle NULL or empty input
    IF value IS NULL OR trim(value) = '' THEN
        RETURN fallback;
    END IF;

    -- Convert to slug: lowercase + unaccent + replace non-alphanumeric with '-'
    result := trim(BOTH '-' FROM regexp_replace(
        lower(unaccent(value)),
        '[^a-z0-9]+', '-', 'gi'
    ));

    -- Handle edge cases
    IF result = '' THEN
        -- All characters were stripped (e.g., "---" or "###")
        RETURN fallback;
    ELSIF result ~ '^[0-9]+$' THEN
        -- All digits (e.g., "123") - prefix with 'n-' to avoid LTREE issues
        RETURN 'n-' || result;
    ELSE
        RETURN result;
    END IF;
END;
$$ LANGUAGE plpgsql IMMUTABLE STRICT;

-- Framework metadata
COMMENT ON FUNCTION public.safe_slug(TEXT, TEXT) IS '@specql:utility Converts text to URL-safe slug with edge case handling';

-- Examples
COMMENT ON FUNCTION public.safe_slug(TEXT, TEXT) IS E'@specql:examples
safe_slug(''CafÃ© StraÃŸe'') â†’ ''cafe-strasse''
safe_slug(''Building #1'') â†’ ''building-1''
safe_slug(''123'') â†’ ''n-123''
safe_slug('''') â†’ ''unnamed''
safe_slug(''---'') â†’ ''unnamed''
';
```

**Tests**: `tests/unit/schema/test_safe_slug.py`

```python
import pytest
from tests.utils.db_test import execute_sql

class TestSafeSlug:
    """Test safe_slug utility function."""

    def test_normal_text(self, db):
        result = execute_sql(db, "SELECT safe_slug('Normal Text')")
        assert result == 'normal-text'

    def test_unicode_unaccent(self, db):
        result = execute_sql(db, "SELECT safe_slug('CafÃ© StraÃŸe')")
        assert result == 'cafe-strasse'

    def test_special_characters(self, db):
        result = execute_sql(db, "SELECT safe_slug('Building #1')")
        assert result == 'building-1'

    def test_all_digits(self, db):
        result = execute_sql(db, "SELECT safe_slug('123')")
        assert result == 'n-123'

    def test_empty_string(self, db):
        result = execute_sql(db, "SELECT safe_slug('')")
        assert result == 'unnamed'

    def test_all_special(self, db):
        result = execute_sql(db, "SELECT safe_slug('---')")
        assert result == 'unnamed'

    def test_custom_fallback(self, db):
        result = execute_sql(db, "SELECT safe_slug('', 'default')")
        assert result == 'default'

    def test_null_input(self, db):
        result = execute_sql(db, "SELECT safe_slug(NULL)")
        assert result == 'unnamed'
```

---

## ðŸŽ¯ Phase 2: 3-Field Deduplication Pattern (Day 2)

### **Objective**: Generate deduplication schema for all entities

### **2.1: Schema Pattern**

**File**: `src/generators/schema/deduplication.py` (NEW)

```python
"""Generate 3-field deduplication pattern."""

from ..ast_models import EntityAST

def generate_deduplication_fields(entity: EntityAST) -> str:
    """Generate identifier, sequence_number, display_identifier fields."""

    entity_name = entity.name.lower()

    return f"""
    -- Deduplication Fields (3-field pattern)
    identifier TEXT NOT NULL,
    sequence_number INTEGER NOT NULL DEFAULT 1,
    display_identifier TEXT GENERATED ALWAYS AS (
        CASE
            WHEN sequence_number > 1
            THEN identifier || '#' || sequence_number
            ELSE identifier
        END
    ) STORED,

    -- Deduplication Constraints
    UNIQUE (identifier, sequence_number),
    UNIQUE (display_identifier)
""".strip()

def generate_deduplication_indexes(entity: EntityAST, schema: str, has_tenant: bool) -> str:
    """Generate indexes for deduplication fields."""

    entity_name = entity.name.lower()
    table_name = f"{schema}.tb_{entity_name}"

    if has_tenant:
        # Tenant-scoped unique constraints
        return f"""
-- Tenant-scoped deduplication
ALTER TABLE {table_name}
    DROP CONSTRAINT IF EXISTS tb_{entity_name}_display_identifier_key;

ALTER TABLE {table_name}
    ADD CONSTRAINT unique_tenant_display_identifier
    UNIQUE (tenant_id, display_identifier);

ALTER TABLE {table_name}
    ADD CONSTRAINT unique_tenant_identifier_sequence
    UNIQUE (tenant_id, identifier, sequence_number);
"""
    else:
        # Global unique constraints (already in table definition)
        return ""
```

**Integration**: `src/generators/schema/schema_generator.py`

```python
from .deduplication import generate_deduplication_fields, generate_deduplication_indexes

class SchemaGenerator:
    def generate_table(self, entity: EntityAST) -> str:
        # ... existing code

        # Add deduplication fields
        dedup_fields = generate_deduplication_fields(entity)

        # Add to table definition
        columns.append(dedup_fields)

        # ... rest of generation
```

---

### **2.2: Concurrent Insert Function**

**File**: `templates/sql/helpers/create_with_dedup.sql.jinja2`

```sql
-- Safe concurrent insertion with automatic deduplication
CREATE OR REPLACE FUNCTION {{ schema }}.create_{{ entity_lower }}_with_dedup(
    p_tenant_id UUID,
    p_identifier TEXT,
    p_data JSONB
) RETURNS UUID AS $$
DECLARE
    v_pk_{{ entity_lower }} INTEGER;
    v_id UUID;
    v_sequence_number INTEGER;
BEGIN
    -- Find next available sequence number (concurrency-safe)
    SELECT COALESCE(MAX(sequence_number), 0) + 1
    INTO v_sequence_number
    FROM {{ schema }}.tb_{{ entity_lower }}
    WHERE tenant_id = p_tenant_id
      AND identifier = p_identifier
    FOR UPDATE;  -- Lock to prevent race conditions

    -- Insert with calculated sequence
    INSERT INTO {{ schema }}.tb_{{ entity_lower }} (
        tenant_id,
        identifier,
        sequence_number,
        -- ... other fields from p_data
    )
    VALUES (
        p_tenant_id,
        p_identifier,
        v_sequence_number,
        -- ... extract from p_data
    )
    RETURNING pk_{{ entity_lower }}, id INTO v_pk_{{ entity_lower }}, v_id;

    RETURN v_id;
END;
$$ LANGUAGE plpgsql;
```

---

## ðŸŽ¯ Phase 3: INTEGER-Based LTREE Paths - Generic Function (Days 3-4)

### **Objective**: Generate ONE generic path recalculation function (NO triggers!)

**Philosophy**: Explicit over implicit - mutations call recalculation explicitly, not via triggers

### **3.1: Recalculation Context Type**

**File**: `templates/sql/000_types.sql.jinja2`

```sql
-- Context for path recalculation operations
-- Based on printoptim_backend pattern
CREATE TYPE core.recalculation_context AS (
    pk UUID,           -- Entity id to recalculate (subtree mode)
    pk_tenant UUID,    -- Tenant scope (tenant mode)
    updated_by UUID    -- Audit tracking
);

COMMENT ON TYPE core.recalculation_context IS
'Composite type for path/identifier recalculation operations.

Fields:
- pk (UUID): Entity id to recalculate. When set, recalculation is scoped to this subtree.
- pk_tenant (UUID): Tenant scope. When set (and pk is NULL), recalculates all trees in tenant.
- updated_by (UUID): Audit field to track who triggered the recalculation.

Usage modes:
1. Subtree: pk set â†’ recalculate from node down
2. Tenant: pk_tenant set (pk NULL) â†’ recalculate all tenant trees
3. Global: both NULL â†’ recalculate entire entity globally

Used by: core.recalculate_tree_path(), mutation functions';
```

---

### **3.2: Generic Path Recalculation Function**

**File**: `templates/sql/hierarchy/recalculate_tree_path.sql.jinja2`

**ONE-TIME FRAMEWORK FUNCTION** (not per-entity)

```sql
-- Generic path recalculation for ANY hierarchical entity
-- Based on printoptim_backend implementation
-- NO TRIGGERS - Called explicitly from mutations!

CREATE OR REPLACE FUNCTION core.recalculate_tree_path(
    entity TEXT,
    ctx core.recalculation_context DEFAULT ROW(NULL, NULL, NULL)::core.recalculation_context
) RETURNS INTEGER AS $$
DECLARE
    v_schema TEXT;
    v_table TEXT;
    v_pk_column TEXT;
    v_parent_column TEXT;
    v_updated_count INTEGER := 0;
    v_root_pk INTEGER;
    dyn_sql TEXT;
BEGIN
    IF entity IS NULL THEN
        RAISE EXCEPTION 'Parameter "entity" must not be NULL';
    END IF;

    -- Construct dynamic identifiers
    v_table := format('tb_%s', entity);
    v_pk_column := format('pk_%s', entity);
    v_parent_column := format('fk_parent_%s', entity);

    -- Find schema dynamically
    SELECT table_schema INTO v_schema
    FROM information_schema.tables
    WHERE table_name = v_table
      AND table_schema IN ('core', 'management', 'catalog', 'tenant')
    LIMIT 1;

    IF v_schema IS NULL THEN
        RAISE EXCEPTION 'Table "tb_%" not found in any expected schema', entity;
    END IF;

    -- MODE 1: Subtree recalculation (ctx.pk set)
    IF ctx.pk IS NOT NULL THEN
        -- Find root of subtree (walk up to find root or use given node)
        dyn_sql := format($q$
            WITH RECURSIVE t_chain AS (
                SELECT %1$I AS pk, %2$I AS parent
                FROM %3$I.%4$I
                WHERE id = $1

                UNION ALL

                SELECT t.%1$I, t.%2$I
                FROM %3$I.%4$I t
                JOIN t_chain ON t.%1$I = t_chain.parent
            )
            SELECT pk FROM t_chain WHERE parent IS NULL LIMIT 1;
        $q$, v_pk_column, v_parent_column, v_schema, v_table);

        EXECUTE dyn_sql INTO v_root_pk USING ctx.pk;

        IF v_root_pk IS NULL THEN
            -- Given node IS the root, get its pk
            dyn_sql := format($q$
                SELECT %1$I FROM %2$I.%3$I WHERE id = $1;
            $q$, v_pk_column, v_schema, v_table);
            EXECUTE dyn_sql INTO v_root_pk USING ctx.pk;
        END IF;

        -- Recalculate subtree using INTEGER pk paths
        dyn_sql := format($q$
            WITH RECURSIVE hierarchy AS (
                SELECT t.%1$I AS pk, t.%1$I::TEXT AS path_str
                FROM %2$I.%3$I t
                WHERE t.%1$I = $1

                UNION ALL

                SELECT c.%1$I, CONCAT(h.path_str, '.', c.%1$I::TEXT)
                FROM %2$I.%3$I c
                JOIN hierarchy h ON c.%4$I = h.pk
            ),
            updated AS (
                UPDATE %2$I.%3$I t
                SET
                    path = h.path_str::ltree,
                    path_updated_at = now(),
                    path_updated_by = $2
                FROM hierarchy h
                WHERE t.%1$I = h.pk
                  AND t.path IS DISTINCT FROM h.path_str::ltree  -- Idempotent
                RETURNING t.%1$I
            )
            SELECT COUNT(*) FROM updated;
        $q$, v_pk_column, v_schema, v_table, v_parent_column);

        EXECUTE dyn_sql INTO v_updated_count USING v_root_pk, ctx.updated_by;

    -- MODE 2: Tenant-scoped recalculation (ctx.pk_tenant set)
    ELSIF ctx.pk_tenant IS NOT NULL THEN
        dyn_sql := format($q$
            WITH RECURSIVE hierarchy AS (
                SELECT t.%1$I AS pk, t.%1$I::TEXT AS path_str
                FROM %2$I.%3$I t
                WHERE t.tenant_id = $1 AND t.%4$I IS NULL

                UNION ALL

                SELECT c.%1$I, CONCAT(h.path_str, '.', c.%1$I::TEXT)
                FROM %2$I.%3$I c
                JOIN hierarchy h ON c.%4$I = h.pk
            ),
            updated AS (
                UPDATE %2$I.%3$I t
                SET
                    path = h.path_str::ltree,
                    path_updated_at = now(),
                    path_updated_by = $2
                FROM hierarchy h
                WHERE t.%1$I = h.pk
                  AND t.path IS DISTINCT FROM h.path_str::ltree
                RETURNING t.%1$I
            )
            SELECT COUNT(*) FROM updated;
        $q$, v_pk_column, v_schema, v_table, v_parent_column);

        EXECUTE dyn_sql INTO v_updated_count USING ctx.pk_tenant, ctx.updated_by;

    -- MODE 3: Global recalculation (both NULL)
    ELSE
        dyn_sql := format($q$
            WITH RECURSIVE hierarchy AS (
                SELECT t.%1$I AS pk, t.%1$I::TEXT AS path_str
                FROM %2$I.%3$I t
                WHERE t.%4$I IS NULL

                UNION ALL

                SELECT c.%1$I, CONCAT(h.path_str, '.', c.%1$I::TEXT)
                FROM %2$I.%3$I c
                JOIN hierarchy h ON c.%4$I = h.pk
            ),
            updated AS (
                UPDATE %2$I.%3$I t
                SET
                    path = h.path_str::ltree,
                    path_updated_at = now(),
                    path_updated_by = $1
                FROM hierarchy h
                WHERE t.%1$I = h.pk
                  AND t.path IS DISTINCT FROM h.path_str::ltree
                RETURNING t.%1$I
            )
            SELECT COUNT(*) FROM updated;
        $q$, v_pk_column, v_schema, v_table, v_parent_column);

        EXECUTE dyn_sql INTO v_updated_count USING ctx.updated_by;
    END IF;

    RETURN v_updated_count;
END;
$$ LANGUAGE plpgsql;

COMMENT ON FUNCTION core.recalculate_tree_path(TEXT, core.recalculation_context) IS
'Generic path recalculation for any hierarchical entity using INTEGER pk-based LTREE paths.

Explicit over Implicit: NO TRIGGERS! Mutations call this explicitly.

Path Format: Pure INTEGER pk values (e.g., ''1.5.23.47'')

Three modes:
1. Subtree (ctx.pk set): Recalculate from given node down
2. Tenant (ctx.pk_tenant set, ctx.pk NULL): Recalculate all trees in tenant
3. Global (both NULL): Recalculate entire entity

Returns: Number of rows updated

Example usage in mutations:
  -- Use INTEGER pk variable (e.g., v_location_pk)
  v_count := core.recalculate_tree_path(
      ''location'',
      ROW(v_location_pk, NULL, p_caller_id)::core.recalculation_context
  );

Based on printoptim_backend pattern.';
```

---

### **3.3: NO TRIGGERS GENERATED**

**IMPORTANT**: Team B does **NOT** generate triggers for path updates!

**Why**: Explicit is better than implicit
- âœ… Easier to debug (visible in mutation code)
- âœ… Better transaction control
- âœ… Testable in isolation
- âœ… No hidden side effects

**Instead**: Team C generates explicit calls in mutation functions (see Team C plan)

---

## ðŸŽ¯ Phase 4: Partial Indexes (Day 4)

### **Objective**: Add `WHERE deleted_at IS NULL` to all non-PK indexes

**File**: `src/generators/schema/index_strategy.py`

```python
def generate_index(
    table_name: str,
    index_name: str,
    columns: list[str],
    index_type: str = 'btree',
    unique: bool = False,
    partial: bool = True  # NEW: Default to partial indexes
) -> str:
    """Generate index with optional partial index clause."""

    unique_clause = 'UNIQUE ' if unique else ''
    using_clause = f'USING {index_type}' if index_type != 'btree' else ''
    column_list = ', '.join(columns)

    # Partial index clause (exclude soft-deleted rows)
    where_clause = ''
    if partial and not unique:  # Don't apply to unique constraints
        where_clause = '\n    WHERE deleted_at IS NULL'

    return f"""
CREATE {unique_clause}INDEX {index_name}
    ON {table_name} {using_clause}({column_list}){where_clause};
""".strip()

# Example usage:
generate_index(
    table_name='tenant.tb_location',
    index_name='idx_location_parent',
    columns=['fk_parent_location'],
    partial=True  # Adds WHERE deleted_at IS NULL
)
```

---

## ðŸŽ¯ Phase 5: Recalculation Audit Fields (Day 5)

### **Objective**: Add separate audit tracking for identifier/path changes

**File**: `src/generators/schema/audit_fields.py`

```python
def generate_audit_fields(entity: EntityAST) -> str:
    """Generate audit fields with recalculation tracking."""

    return """
    -- Business Data Audit
    created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
    created_by UUID,
    updated_at TIMESTAMPTZ NOT NULL DEFAULT now(),
    updated_by UUID,
    deleted_at TIMESTAMPTZ,
    deleted_by UUID,

    -- Identifier Recalculation Audit (separate from business changes)
    identifier_recalculated_at TIMESTAMPTZ,
    identifier_recalculated_by UUID,

    -- Path Recalculation Audit (for hierarchical entities)
    path_updated_at TIMESTAMPTZ,
    path_updated_by UUID
""".strip()
```

**Usage in triggers**:

```sql
-- Business data change: Update updated_at
UPDATE tb_location
SET
    name = 'New Name',
    updated_at = now(),
    updated_by = current_user_id
WHERE pk_location = 123;

-- Identifier recalculation: Update identifier_recalculated_at (NOT updated_at)
UPDATE tb_location
SET
    identifier = new_identifier,
    identifier_recalculated_at = now(),
    identifier_recalculated_by = system_user_id
WHERE pk_location = 123;

-- Path recalculation: Update path_updated_at (NOT updated_at)
UPDATE tb_location
SET
    path = new_path,
    path_updated_at = now(),
    path_updated_by = system_user_id
WHERE pk_location = 123;
```

---

## ðŸŽ¯ Phase 6: Tenant-Scoped Composite Indexes (Day 6)

### **Objective**: Add composite indexes for multi-tenant performance

**File**: `src/generators/schema/tenant_indexes.py` (NEW)

```python
def generate_tenant_indexes(entity: EntityAST, schema: str) -> str:
    """Generate tenant-scoped composite indexes."""

    entity_name = entity.name.lower()
    table_name = f"{schema}.tb_{entity_name}"
    indexes = []

    # 1. Tenant isolation index
    indexes.append(f"""
CREATE INDEX idx_{entity_name}_tenant
    ON {table_name}(tenant_id)
    WHERE deleted_at IS NULL;
""")

    # 2. Tenant + ID (for lookups)
    indexes.append(f"""
CREATE UNIQUE INDEX idx_{entity_name}_tenant_id
    ON {table_name}(tenant_id, id);
""")

    # 3. If hierarchical: Tenant + Path
    if entity.hierarchical:
        indexes.append(f"""
CREATE INDEX idx_{entity_name}_tenant_path
    ON {table_name}(tenant_id, path)
    WHERE deleted_at IS NULL;
""")

        # 4. If hierarchical: Tenant + Parent
        indexes.append(f"""
CREATE INDEX idx_{entity_name}_tenant_parent
    ON {table_name}(tenant_id, fk_parent_{entity_name})
    WHERE deleted_at IS NULL;
""")

    return '\n\n'.join(indexes)
```

**Benefits**:
- âœ… Tenant isolation queries 5-10x faster
- âœ… RLS policies use tenant_id index efficiently
- âœ… Composite indexes prevent full table scans

---

## ðŸŽ¯ Phase 7: Safety Constraint Triggers (Day 7)

### **Objective**: Generate 3 safety triggers per hierarchical entity

### **7.1: Prevent Circular References**

**File**: `templates/sql/constraints/prevent_cycle.sql.jinja2`

```sql
CREATE OR REPLACE FUNCTION {{ schema }}.prevent_{{ entity_lower }}_cycle()
RETURNS TRIGGER AS $$
DECLARE
    v_ancestor_path ltree;
BEGIN
    -- Skip check if no parent (root node)
    IF NEW.fk_parent_{{ entity_lower }} IS NULL THEN
        RETURN NEW;
    END IF;

    -- Get parent's path
    SELECT path INTO v_ancestor_path
    FROM {{ schema }}.tb_{{ entity_lower }}
    WHERE pk_{{ entity_lower }} = NEW.fk_parent_{{ entity_lower }};

    -- Check if parent is a descendant of current node
    IF v_ancestor_path <@ NEW.path THEN
        RAISE EXCEPTION
            'Circular reference detected: {{ entity }} (%) cannot be its own ancestor (parent path: %, current path: %)',
            NEW.id,
            v_ancestor_path,
            NEW.path
        USING
            ERRCODE = '23514',  -- check_violation
            HINT = 'Choose a parent that is not a descendant of this {{ entity_lower }}';
    END IF;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_prevent_{{ entity_lower }}_cycle
    BEFORE INSERT OR UPDATE OF fk_parent_{{ entity_lower }}
    ON {{ schema }}.tb_{{ entity_lower }}
    FOR EACH ROW
    EXECUTE FUNCTION {{ schema }}.prevent_{{ entity_lower }}_cycle();
```

---

### **7.2: Check Identifier Sequence Limit**

**File**: `templates/sql/constraints/check_sequence_limit.sql.jinja2`

```sql
CREATE OR REPLACE FUNCTION {{ schema }}.check_{{ entity_lower }}_sequence_limit()
RETURNS TRIGGER AS $$
DECLARE
    v_max_duplicates INTEGER := 100;  -- Configurable limit
BEGIN
    IF NEW.sequence_number > v_max_duplicates THEN
        RAISE EXCEPTION
            'Identifier sequence limit exceeded (>% duplicates): "%"',
            v_max_duplicates,
            NEW.identifier
        USING
            ERRCODE = '23514',
            HINT = FORMAT(
                'Current variant: %s#%s. Use more descriptive naming to reduce collisions.',
                NEW.identifier,
                NEW.sequence_number
            );
    ELSIF NEW.sequence_number > (v_max_duplicates * 0.5) THEN
        -- Warning at 50%
        RAISE WARNING
            'High identifier duplication: % has % variants (limit: %)',
            NEW.identifier,
            NEW.sequence_number,
            v_max_duplicates;
    END IF;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_check_{{ entity_lower }}_sequence_limit
    BEFORE INSERT OR UPDATE OF sequence_number
    ON {{ schema }}.tb_{{ entity_lower }}
    FOR EACH ROW
    EXECUTE FUNCTION {{ schema }}.check_{{ entity_lower }}_sequence_limit();
```

---

### **7.3: Check Hierarchy Depth Limit**

**File**: `templates/sql/constraints/check_depth_limit.sql.jinja2`

```sql
CREATE OR REPLACE FUNCTION {{ schema }}.check_{{ entity_lower }}_depth_limit()
RETURNS TRIGGER AS $$
DECLARE
    v_depth INTEGER;
    v_max_depth INTEGER := 20;  -- From framework config
    v_warn_threshold INTEGER := 15;
BEGIN
    -- Calculate depth from LTREE path
    v_depth := nlevel(NEW.path);

    IF v_depth > v_max_depth THEN
        RAISE EXCEPTION
            'Hierarchy depth limit exceeded: % levels (max: %)',
            v_depth,
            v_max_depth
        USING
            ERRCODE = '23514',
            HINT = 'Flatten the hierarchy or increase max_depth in framework config',
            DETAIL = FORMAT('Path: %s', NEW.path);
    ELSIF v_depth > v_warn_threshold THEN
        RAISE WARNING
            'Approaching hierarchy depth limit: % of % levels (path: %)',
            v_depth,
            v_max_depth,
            NEW.path;
    END IF;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_check_{{ entity_lower }}_depth_limit
    BEFORE INSERT OR UPDATE OF path
    ON {{ schema }}.tb_{{ entity_lower }}
    FOR EACH ROW
    EXECUTE FUNCTION {{ schema }}.check_{{ entity_lower }}_depth_limit();
```

---

## âœ… Phase 8: Node+Info Split Pattern (Days 8-10) - COMPLETED

### **Objective**: Implement opt-in node/info split for complex entities

### **8.1: Detection Logic**

**File**: `src/generators/schema/node_info_split.py` (NEW)

```python
def should_split_entity(entity: EntityAST) -> bool:
    """Determine if entity should use node+info split."""

    # User explicitly opted in
    if entity.metadata_split:
        return True

    # Auto-suggest if many fields (>12)
    if len(entity.fields) > 12:
        # Warn but don't auto-split
        logger.warning(
            f"Entity '{entity.name}' has {len(entity.fields)} fields. "
            "Consider using 'metadata_split: true' for cleaner schema."
        )

    return False
```

---

### **8.2: Node Table Generation**

**File**: `templates/sql/node_info/node_table.sql.jinja2`

```sql
-- Structure table: Hierarchy and tenant isolation only
CREATE TABLE {{ schema }}.tb_{{ entity_lower }}_node (
    -- Trinity Pattern
    pk_{{ entity_lower }} INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    id UUID NOT NULL DEFAULT gen_random_uuid() UNIQUE,

    -- Multi-Tenancy
    tenant_id UUID NOT NULL,

    -- Hierarchy
    path ltree NOT NULL,
    fk_parent_{{ entity_lower }} INTEGER REFERENCES {{ schema }}.tb_{{ entity_lower }}_node(pk_{{ entity_lower }})
        ON DELETE RESTRICT,

    -- Foreign key to info table
    fk_{{ entity_lower }}_info INTEGER NOT NULL,

    -- Structural Audit (creation/deletion only)
    created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
    created_by UUID,
    deleted_at TIMESTAMPTZ,
    deleted_by UUID,

    -- Path Audit
    path_updated_at TIMESTAMPTZ,
    path_updated_by UUID,

    -- Constraints
    UNIQUE (tenant_id, id),
    UNIQUE (tenant_id, path)
);

-- Indexes
CREATE INDEX idx_{{ entity_lower }}_node_tenant
    ON {{ schema }}.tb_{{ entity_lower }}_node(tenant_id)
    WHERE deleted_at IS NULL;

CREATE INDEX idx_{{ entity_lower }}_node_path
    ON {{ schema }}.tb_{{ entity_lower }}_node USING GIST (path)
    WHERE deleted_at IS NULL;

CREATE INDEX idx_{{ entity_lower }}_node_parent
    ON {{ schema }}.tb_{{ entity_lower }}_node(fk_parent_{{ entity_lower }})
    WHERE deleted_at IS NULL;

CREATE INDEX idx_{{ entity_lower }}_node_info_fk
    ON {{ schema }}.tb_{{ entity_lower }}_node(fk_{{ entity_lower }}_info);
```

---

### **8.3: Info Table Generation**

**File**: `templates/sql/node_info/info_table.sql.jinja2`

```sql
-- Attributes table: Business data and versioning
CREATE TABLE {{ schema }}.tb_{{ entity_lower }}_info (
    -- Trinity Pattern
    pk_{{ entity_lower }}_info INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    id UUID NOT NULL DEFAULT gen_random_uuid() UNIQUE,

    -- Multi-Tenancy
    tenant_id UUID NOT NULL,

    -- Deduplication
    identifier TEXT NOT NULL,
    sequence_number INTEGER NOT NULL DEFAULT 1,
    display_identifier TEXT GENERATED ALWAYS AS (
        CASE WHEN sequence_number > 1
            THEN identifier || '#' || sequence_number
            ELSE identifier
        END
    ) STORED,

    -- Business Fields
    {% for field in entity.fields %}
    {{ field.name }} {{ field.sql_type }},
    {% endfor %}

    -- Business Audit
    created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
    created_by UUID,
    updated_at TIMESTAMPTZ NOT NULL DEFAULT now(),
    updated_by UUID,

    -- Identifier Audit
    identifier_recalculated_at TIMESTAMPTZ,
    identifier_recalculated_by UUID,

    -- Constraints
    UNIQUE (tenant_id, display_identifier),
    UNIQUE (identifier, sequence_number)
);

-- Indexes
CREATE INDEX idx_{{ entity_lower }}_info_tenant
    ON {{ schema }}.tb_{{ entity_lower }}_info(tenant_id);

CREATE INDEX idx_{{ entity_lower }}_info_identifier
    ON {{ schema }}.tb_{{ entity_lower }}_info(identifier);
```

---

### **8.4: Convenience View**

**File**: `templates/sql/node_info/view.sql.jinja2`

```sql
-- Convenience view: JOIN node + info
CREATE VIEW {{ schema }}.v_{{ entity_lower }} AS
SELECT
    -- Node fields
    n.pk_{{ entity_lower }},
    n.id,
    n.tenant_id,
    n.path,
    n.fk_parent_{{ entity_lower }},

    -- Info fields
    i.pk_{{ entity_lower }}_info,
    i.identifier,
    i.sequence_number,
    i.display_identifier,
    {% for field in entity.fields %}
    i.{{ field.name }},
    {% endfor %}

    -- Audit (combined)
    n.created_at,
    n.created_by,
    i.updated_at,
    i.updated_by,
    n.deleted_at,
    n.deleted_by,

    -- Recalculation Audit
    i.identifier_recalculated_at,
    i.identifier_recalculated_by,
    n.path_updated_at,
    n.path_updated_by
FROM {{ schema }}.tb_{{ entity_lower }}_node n
INNER JOIN {{ schema }}.tb_{{ entity_lower }}_info i
    ON i.pk_{{ entity_lower }}_info = n.fk_{{ entity_lower }}_info
WHERE n.deleted_at IS NULL;

-- FraiseQL metadata
COMMENT ON VIEW {{ schema }}.v_{{ entity_lower }} IS
'@fraiseql:type name={{ entity }},schema={{ schema }}';
```

---

## ðŸ“Š Summary: Team B Deliverables

### **Files to Create**

| File | Purpose | Lines |
|------|---------|-------|
| `templates/sql/000_extensions.sql.jinja2` | Extensions | 20 |
| `templates/sql/utilities/safe_slug.sql.jinja2` | Slugification | 40 |
| `templates/sql/hierarchy/calculate_path.sql.jinja2` | Path calculation | 50 |

| `templates/sql/hierarchy/recalculate_descendants.sql.jinja2` | Descendant paths | 60 |
| `templates/sql/constraints/prevent_cycle.sql.jinja2` | Safety | 40 |
| `templates/sql/constraints/check_sequence_limit.sql.jinja2` | Safety | 40 |
| `templates/sql/constraints/check_depth_limit.sql.jinja2` | Safety | 40 |
| `templates/sql/node_info/node_table.sql.jinja2` | Split pattern | 80 |
| `templates/sql/node_info/info_table.sql.jinja2` | Split pattern | 80 |
| `templates/sql/node_info/view.sql.jinja2` | Split pattern | 60 |
| `src/generators/schema/deduplication.py` | Python | 100 |
| `src/generators/schema/tenant_indexes.py` | Python | 80 |
| `src/generators/schema/node_info_split.py` | Python | 200 |
| **Total** | | **890 lines** |

### **Timeline**

- **Day 1**: Extensions + safe_slug (Phase 1)
- **Day 2**: Deduplication pattern (Phase 2)
- **Days 3-4**: INTEGER paths (Phase 3)
- **Day 4**: Partial indexes (Phase 4)
- **Day 5**: Audit fields (Phase 5)
- **Day 6**: Tenant indexes (Phase 6)
- **Day 7**: Safety triggers (Phase 7)
- **Days 8-10**: Node+info split (Phase 8)

**Total**: 10 days (2 weeks)

---

## âœ… Acceptance Criteria

- [ ] Extensions (unaccent, ltree, uuid-ossp) auto-generated
- [ ] safe_slug() handles all edge cases (empty, digits, special chars)
- [ ] 3-field deduplication works (identifier, sequence_number, display_identifier)
- [ ] INTEGER-based paths calculated correctly (format: `1.5.23.47`)
- [ ] All non-PK indexes have `WHERE deleted_at IS NULL`
- [ ] Separate audit fields for recalculation vs business changes
- [ ] Tenant-scoped composite indexes generated
- [ ] 3 safety triggers prevent data corruption
- [ ] Node+info split works when `metadata_split: true`
- [ ] All tests pass (90%+ coverage)

---

**Status**: ðŸ”´ READY TO START (Week 2)
**Priority**: CRITICAL (core infrastructure)
**Effort**: 10 days
**Dependencies**: Team A reserved field validation
