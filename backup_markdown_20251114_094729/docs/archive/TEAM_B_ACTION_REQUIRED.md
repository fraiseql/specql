# Team B: Action Required - Add `app.log_and_return_mutation()` Helper

**Date**: 2025-11-08
**Priority**: ğŸš¨ **CRITICAL** - Blocking Team C Integration
**Status**: NEEDS IMPLEMENTATION
**Estimated Time**: 30 minutes

---

## ğŸ¯ WHAT'S NEEDED

Team C's generated functions are **already calling** `app.log_and_return_mutation()`, but Team B hasn't **generated** this function yet.

**Current State**:
- âœ… Team C templates correctly USE the function
- âŒ Team B doesn't GENERATE the function
- ğŸ”´ Result: Generated SQL will fail to compile in PostgreSQL

**Required Action**: Add `app.log_and_return_mutation()` to Team B's base app schema generation.

---

## ğŸ“‹ BACKGROUND

### Why This Function Exists

Every mutation (create, update, delete) needs to return a standardized `app.mutation_result`. Rather than duplicating the result-building logic across every business schema (`crm.*`, `management.*`, `inventory.*`, etc.), we use a **shared utility function** in the `app.*` schema.

### Architecture Decision

```
app.*           â†’ Cross-cutting concerns (types, utilities, API wrappers)
  â”œâ”€â”€ app.mutation_result (type) âœ… Already generated by Team B
  â””â”€â”€ app.log_and_return_mutation() âŒ MISSING - needs to be added

crm.*           â†’ Business logic (uses app utilities)
  â””â”€â”€ crm.create_contact() â†’ calls app.log_and_return_mutation()

management.*    â†’ Business logic (uses app utilities)
  â””â”€â”€ management.create_company() â†’ calls app.log_and_return_mutation()
```

### Benefits
- âœ… Single source of truth (one function, not duplicated per schema)
- âœ… Easy maintenance (update logic in one place)
- âœ… Consistent behavior (all mutations return identical structure)
- âœ… Future extensibility (add audit logging in one place)

**Reference**: See `docs/teams/TEAM_C_HELPER_FUNCTIONS_SCHEMA.md` for full architectural rationale.

---

## ğŸ”¨ IMPLEMENTATION

### Option 1: Add to Existing Schema Generator (Recommended)

**File**: `src/generators/schema/schema_generator.py` or `src/generators/app_foundation_generator.py`

**Add this method**:

```python
def generate_app_log_and_return_mutation(self) -> str:
    """
    Generate shared app.log_and_return_mutation utility function

    This function is used by ALL business schemas (crm, management, etc.)
    to build standardized mutation_result responses.

    Returns:
        SQL DDL for the helper function
    """
    return """
-- ============================================================================
-- SHARED UTILITY: app.log_and_return_mutation
-- Used by ALL business schemas for standardized mutation responses
-- ============================================================================
CREATE OR REPLACE FUNCTION app.log_and_return_mutation(
    p_tenant_id UUID,
    p_user_id UUID,
    p_entity TEXT,
    p_entity_id UUID,
    p_operation TEXT,
    p_status TEXT,
    p_updated_fields TEXT[],
    p_message TEXT,
    p_object_data JSONB,
    p_extra_metadata JSONB DEFAULT NULL
) RETURNS app.mutation_result
LANGUAGE plpgsql
AS $$
DECLARE
    v_result app.mutation_result;
BEGIN
    -- TODO Phase 2: Add audit logging to app.tb_mutation_audit
    -- INSERT INTO app.tb_mutation_audit (
    --     tenant_id, user_id, entity, entity_id, operation, status,
    --     updated_fields, message, timestamp
    -- ) VALUES (
    --     p_tenant_id, p_user_id, p_entity, p_entity_id, p_operation, p_status,
    --     p_updated_fields, p_message, now()
    -- );

    -- Build standardized result
    v_result.id := p_entity_id;
    v_result.updated_fields := p_updated_fields;
    v_result.status := p_status;
    v_result.message := p_message;
    v_result.object_data := p_object_data;
    v_result.extra_metadata := COALESCE(p_extra_metadata, '{}'::jsonb);

    RETURN v_result;
END;
$$;

COMMENT ON FUNCTION app.log_and_return_mutation IS
  '@fraiseql:utility Shared utility for building mutation_result responses. Used by all business schemas (crm, management, inventory, etc.) to ensure consistent mutation return structure.';
"""
```

**Then update the orchestration to include it**:

```python
def generate_app_foundation(self) -> str:
    """Generate base app schema with types and utilities"""
    parts = [
        "-- App Schema Foundation",
        "CREATE SCHEMA IF NOT EXISTS app;",
        "",
        self.generate_mutation_result_type(),  # Existing
        "",
        self.generate_app_log_and_return_mutation(),  # NEW
        "",
    ]
    return "\n".join(parts)
```

---

### Option 2: Create Dedicated Template (Alternative)

**File**: `templates/sql/app_helpers.sql.j2`

```sql
{# App schema helper functions #}

-- ============================================================================
-- SHARED UTILITY: app.log_and_return_mutation
-- Used by ALL business schemas for standardized mutation responses
-- ============================================================================
CREATE OR REPLACE FUNCTION app.log_and_return_mutation(
    p_tenant_id UUID,
    p_user_id UUID,
    p_entity TEXT,
    p_entity_id UUID,
    p_operation TEXT,
    p_status TEXT,
    p_updated_fields TEXT[],
    p_message TEXT,
    p_object_data JSONB,
    p_extra_metadata JSONB DEFAULT NULL
) RETURNS app.mutation_result
LANGUAGE plpgsql
AS $$
DECLARE
    v_result app.mutation_result;
BEGIN
    -- Build standardized result
    v_result.id := p_entity_id;
    v_result.updated_fields := p_updated_fields;
    v_result.status := p_status;
    v_result.message := p_message;
    v_result.object_data := p_object_data;
    v_result.extra_metadata := COALESCE(p_extra_metadata, '{}'::jsonb);

    RETURN v_result;
END;
$$;

COMMENT ON FUNCTION app.log_and_return_mutation IS
  '@fraiseql:utility Shared helper for mutation responses';
```

**Then load the template in your generator**:

```python
def generate_app_helpers(self) -> str:
    """Generate app schema helper functions"""
    template = self.env.get_template("app_helpers.sql.j2")
    return template.render()
```

---

## ğŸ—ï¸ MIGRATION PLACEMENT

### Critical: Must Be in Base App Schema Migration

The helper function **MUST** be generated in `migrations/000_app_foundation.sql` **BEFORE** any entity-specific migrations.

**Correct Order**:
```
migrations/
â”œâ”€â”€ 000_app_foundation.sql
â”‚   â”œâ”€â”€ CREATE SCHEMA app;
â”‚   â”œâ”€â”€ CREATE TYPE app.mutation_result AS (...);  âœ… Existing
â”‚   â””â”€â”€ CREATE FUNCTION app.log_and_return_mutation(...);  âŒ ADD THIS
â”‚
â”œâ”€â”€ 001_mutation_metadata.sql
â”‚   â””â”€â”€ CREATE SCHEMA mutation_metadata;
â”‚
â”œâ”€â”€ 100_crm_contact.sql
â”‚   â”œâ”€â”€ CREATE TABLE crm.tb_contact (...);
â”‚   â”œâ”€â”€ CREATE FUNCTION crm.contact_pk(...);
â”‚   â””â”€â”€ CREATE FUNCTION crm.create_contact(...);  â†’ calls app.log_and_return_mutation()
â”‚
â””â”€â”€ 200_management_company.sql
    â””â”€â”€ CREATE FUNCTION management.create_company(...);  â†’ calls app.log_and_return_mutation()
```

**Why This Matters**: Entity migrations (100+) depend on this function. If it's not in the base migration, entity migrations will fail.

---

## ğŸ§ª VERIFICATION

### Test 1: Function Generation

After implementing, verify the function is generated:

```bash
# Generate base app schema
uv run python -m src.generators.schema.schema_generator

# Check output includes the function
grep -n "app.log_and_return_mutation" migrations/000_app_foundation.sql
```

**Expected**: Should find the function definition.

### Test 2: PostgreSQL Compilation

Apply the migration to verify SQL is valid:

```bash
# Create test database
createdb test_specql

# Apply migration
psql test_specql < migrations/000_app_foundation.sql

# Verify function exists
psql test_specql -c "\df app.log_and_return_mutation"
```

**Expected**: Function should be listed with correct signature.

### Test 3: Team C Integration

Generate a complete entity with Team C's functions:

```bash
# Generate entity (includes Team C functions)
uv run python -m src.cli.generate entities/examples/contact_lightweight.yaml

# Apply to database
psql test_specql < migrations/*.sql

# Verify no errors
echo $?  # Should be 0
```

**Expected**: All migrations apply successfully without errors.

### Test 4: Call the Function

Execute a simple test call:

```bash
psql test_specql -c "
SELECT app.log_and_return_mutation(
    p_tenant_id := gen_random_uuid(),
    p_user_id := gen_random_uuid(),
    p_entity := 'contact',
    p_entity_id := gen_random_uuid(),
    p_operation := 'INSERT',
    p_status := 'success',
    p_updated_fields := ARRAY['email', 'status']::TEXT[],
    p_message := 'Test message',
    p_object_data := '{\"test\": true}'::jsonb,
    p_extra_metadata := null
);
"
```

**Expected**: Should return a properly structured `mutation_result`.

---

## ğŸ“ ACCEPTANCE CRITERIA

- [ ] Function `app.log_and_return_mutation()` is generated
- [ ] Function is in `migrations/000_app_foundation.sql` (before entity migrations)
- [ ] Function has correct signature (10 parameters, returns `app.mutation_result`)
- [ ] Function includes FraiseQL annotation comment
- [ ] Migration applies to PostgreSQL without errors
- [ ] Function can be called successfully
- [ ] Team C's generated entity migrations compile without errors
- [ ] Tests pass: `uv run pytest tests/integration/`

---

## ğŸ› TROUBLESHOOTING

### Issue: "function app.log_and_return_mutation does not exist"

**Cause**: Function not generated or in wrong migration file.

**Fix**: Ensure function is in `000_app_foundation.sql` and migrations are applied in order.

### Issue: "type app.mutation_result does not exist"

**Cause**: Migration order problem - function created before type.

**Fix**: Ensure type is created **before** function in the same migration:
```sql
-- 1. Create type first
CREATE TYPE app.mutation_result AS (...);

-- 2. Then create function
CREATE FUNCTION app.log_and_return_mutation(...) RETURNS app.mutation_result ...
```

### Issue: "column v_result.id does not exist"

**Cause**: Incorrect composite type field assignment syntax.

**Fix**: Use correct syntax:
```sql
-- Correct:
v_result.id := p_entity_id;

-- Wrong:
v_result['id'] := p_entity_id;  -- This is for JSONB, not composite types
```

---

## ğŸ“š REFERENCE DOCUMENTATION

**Architecture**:
- `docs/teams/TEAM_C_HELPER_FUNCTIONS_SCHEMA.md` - Full architectural rationale

**How Team C Uses It**:
- `templates/sql/core_create_function.sql.j2:23` - Validation errors
- `templates/sql/core_create_function.sql.j2:44` - FK not found errors
- `templates/sql/core_create_function.sql.j2:73` - Success response
- `templates/sql/core_update_function.sql.j2` - Update operations
- `templates/sql/core_delete_function.sql.j2` - Delete operations

**Team C Status**:
- `TEAM_C_EXECUTIVE_SUMMARY.md` - Overview of Team C completion
- `TEAM_C_VERIFICATION_AND_NEXT_STEPS.md` - Detailed next steps

---

## ğŸš€ IMPLEMENTATION CHECKLIST

### Step 1: Code Changes (20 min)
- [ ] Add `generate_app_log_and_return_mutation()` method to schema generator
- [ ] Update orchestration to include helper function in base migration
- [ ] Ensure function is generated **after** `app.mutation_result` type

### Step 2: Testing (10 min)
- [ ] Run generation: `uv run python -m src.generators.schema.schema_generator`
- [ ] Verify function in `migrations/000_app_foundation.sql`
- [ ] Apply to test database: `psql test < migrations/000_app_foundation.sql`
- [ ] Call function to verify it works

### Step 3: Integration (5 min)
- [ ] Generate test entity with Team C functions
- [ ] Verify entity migrations compile successfully
- [ ] Run integration tests: `uv run pytest tests/integration/`

### Step 4: Documentation (5 min)
- [ ] Update Team B completion status
- [ ] Note function added to base migration
- [ ] Inform Team C blocker is resolved

**Total Time**: ~40 minutes

---

## ğŸ’¬ QUESTIONS?

**Q: Why not generate this per-schema (crm.log_and_return_mutation, management.log_and_return_mutation, etc.)?**

**A**: Code duplication. Every schema would have identical code. Updating logic would require changing N functions. The `app.*` schema is designed for cross-cutting utilities like this.

**Q: Can I add audit logging now?**

**A**: The TODO comment is there for future Phase 2. For now, just build and return the result. Audit logging can be added later without breaking existing code.

**Q: Does this need to be in Team B or could Team E do it?**

**A**: Team B owns schema generation and the `app.*` schema foundation. This logically belongs with the base schema setup. Team E orchestrates but doesn't generate schema-level utilities.

**Q: What if we want different return logic per schema?**

**A**: That violates the standardization principle. All mutations should return the same structure. Schema-specific logic goes in the business functions (crm.create_contact), not the utility helper.

---

## âœ… READY TO IMPLEMENT?

This is a **straightforward addition** that unblocks Team C's integration testing. The function is simple, well-defined, and has clear test criteria.

**Recommended Approach**: Option 1 (add method to existing schema generator) for simplicity.

**Next Steps After Implementation**:
1. âœ… Verify migrations generate correctly
2. âœ… Test in PostgreSQL
3. âœ… Notify Team C that blocker is resolved
4. ğŸš€ Team C proceeds with integration tests

---

**Status**: ğŸ”´ BLOCKING TEAM C
**Priority**: CRITICAL
**Assignee**: Team B
**Estimated Completion**: 30-40 minutes
**Next Review**: After implementation + testing

---

**Last Updated**: 2025-11-08
**Created By**: Architecture Review + Team C Coordination
**Reference**: TEAM_C_EXECUTIVE_SUMMARY.md, TEAM_C_HELPER_FUNCTIONS_SCHEMA.md
