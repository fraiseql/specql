# SpecQL Generated Code Patterns

**Technical reference for all generated PostgreSQL + PL/pgSQL patterns** ðŸ—ï¸

## Overview

SpecQL generates production-ready PostgreSQL code following proven patterns. This document details every generated artifact, naming convention, and architectural decision.

**Generated per entity:**
- âœ… PostgreSQL table with Trinity pattern
- âœ… Helper functions for ID conversion
- âœ… CRUD functions with error handling
- âœ… Custom business logic functions
- âœ… Indexes for performance
- âœ… Constraints for data integrity
- âœ… Comments for GraphQL auto-discovery

## Trinity Pattern Architecture

### Table Structure

Every SpecQL entity generates a table following the Trinity pattern:

```sql
CREATE TABLE crm.tb_contact (
    -- ========================================================================
    -- Trinity Pattern: INTEGER primary key for performance
    -- ========================================================================
    pk_contact INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,

    -- ========================================================================
    -- Trinity Pattern: UUID for stable public API
    -- ========================================================================
    id UUID DEFAULT gen_random_uuid() NOT NULL,

    -- ========================================================================
    -- Multi-Tenancy: Denormalized from JWT (if tenant schema)
    -- ========================================================================
    tenant_id UUID NOT NULL,

    -- ========================================================================
    -- Business Fields (from YAML)
    -- ========================================================================
    email TEXT NOT NULL,
    first_name TEXT NOT NULL,
    last_name TEXT NOT NULL,

    -- ========================================================================
    -- Foreign Keys (Trinity Pattern: INTEGER references)
    -- ========================================================================
    fk_organization INTEGER,

    -- ========================================================================
    -- Audit Fields (Trinity Pattern standard)
    -- ========================================================================
    created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
    created_by UUID,
    updated_at TIMESTAMPTZ NOT NULL DEFAULT now(),
    updated_by UUID,
    deleted_at TIMESTAMPTZ,
    deleted_by UUID,

    -- ========================================================================
    -- Constraints
    -- ========================================================================
    CONSTRAINT tb_contact_id_key UNIQUE (id)
);
```

### Column Naming Conventions

| Pattern | Example | Purpose |
|---------|---------|---------|
| `pk_{entity}` | `pk_contact` | Internal INTEGER primary key |
| `id` | `id` | External UUID identifier |
| `fk_{entity}` | `fk_organization` | Foreign key references |
| `tenant_id` | `tenant_id` | Multi-tenancy isolation |
| `{field}` | `email` | Business fields (snake_case) |
| `created_at` | `created_at` | Audit timestamp |
| `created_by` | `created_by` | Audit user reference |

### Helper Functions

#### Primary Key Resolution (`{entity}_pk`)

Converts external identifiers to internal INTEGER primary keys:

```sql
-- UUID/text identifier â†’ INTEGER pk
CREATE FUNCTION crm.contact_pk(p_identifier TEXT, p_tenant_id UUID)
RETURNS INTEGER AS $$
    SELECT pk_contact
    FROM crm.tb_contact
    WHERE (id::TEXT = p_identifier
        OR pk_contact::TEXT = p_identifier)
      AND tenant_id = p_tenant_id
    LIMIT 1;
$$ LANGUAGE sql STABLE;
```

**Usage:**
```sql
-- All these work:
SELECT crm.contact_pk('550e8400-e29b-41d4-a716-446655440000', tenant_id);
SELECT crm.contact_pk('123', tenant_id);  -- INTEGER pk as text
SELECT crm.contact_pk('identifier-123', tenant_id);  -- Human-readable identifier
```

#### UUID Resolution (`{entity}_id`)

Converts internal INTEGER primary keys to external UUIDs:

```sql
-- INTEGER pk â†’ UUID
CREATE FUNCTION crm.contact_id(p_pk INTEGER)
RETURNS UUID AS $$
    SELECT id FROM crm.tb_contact
    WHERE pk_contact = p_pk;
$$ LANGUAGE sql STABLE;
```

**Usage:**
```sql
SELECT crm.contact_id(123);  -- Returns UUID for pk_contact = 123
```

#### Identifier Resolution (`{entity}_identifier`)

Converts UUIDs to human-readable identifiers:

```sql
-- UUID â†’ TEXT identifier
CREATE FUNCTION crm.contact_identifier(p_id UUID)
RETURNS TEXT AS $$
    SELECT identifier FROM crm.tb_contact
    WHERE id = p_id;
$$ LANGUAGE sql STABLE;
```

## CRUD Functions

### Create Function (`create_{entity}`)

Generated INSERT function with validation and error handling:

```sql
CREATE FUNCTION crm.create_contact(
    -- Multi-tenancy parameter (automatic)
    tenant_id UUID,

    -- Business parameters (from YAML fields)
    email TEXT,
    first_name TEXT,
    last_name TEXT
)
RETURNS app.mutation_result
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = crm, app, common
AS $$
DECLARE
    v_result app.mutation_result;
    v_pk INTEGER;
BEGIN
    -- Input validation
    IF email IS NULL THEN
        RETURN app.error_result('Email is required');
    END IF;

    -- Business logic validation
    IF EXISTS (SELECT 1 FROM crm.tb_contact
               WHERE email = create_contact.email
                 AND tenant_id = create_contact.tenant_id
                 AND deleted_at IS NULL) THEN
        RETURN app.error_result('Email already exists');
    END IF;

    -- Insert record
    INSERT INTO crm.tb_contact (
        tenant_id, email, first_name, last_name
    ) VALUES (
        tenant_id, email, first_name, last_name
    ) RETURNING pk_contact INTO v_pk;

    -- Return success with created object
    v_result.success := true;
    v_result.message := 'Contact created successfully';
    v_result.object := json_build_object(
        'id', crm.contact_id(v_pk),
        'email', email,
        'firstName', first_name,
        'lastName', last_name
    );

    RETURN v_result;
END;
$$;
```

### Update Function (`update_{entity}`)

Generated UPDATE function with optimistic locking:

```sql
CREATE FUNCTION crm.update_contact(
    tenant_id UUID,
    contact_id UUID,  -- UUID identifier
    email TEXT = NULL,
    first_name TEXT = NULL,
    last_name TEXT = NULL
)
RETURNS app.mutation_result
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = crm, app, common
AS $$
DECLARE
    v_result app.mutation_result;
    v_pk INTEGER;
BEGIN
    -- Resolve UUID to pk
    v_pk := crm.contact_pk(contact_id::TEXT, tenant_id);
    IF v_pk IS NULL THEN
        RETURN app.error_result('Contact not found');
    END IF;

    -- Update only provided fields
    UPDATE crm.tb_contact SET
        email = COALESCE(email, email),
        first_name = COALESCE(first_name, first_name),
        last_name = COALESCE(last_name, last_name),
        updated_at = now(),
        updated_by = current_user_id()
    WHERE pk_contact = v_pk
      AND tenant_id = tenant_id;

    -- Return updated object
    SELECT json_build_object(
        'id', id,
        'email', email,
        'firstName', first_name,
        'lastName', last_name
    ) INTO v_result.object
    FROM crm.tb_contact
    WHERE pk_contact = v_pk;

    v_result.success := true;
    v_result.message := 'Contact updated successfully';

    RETURN v_result;
END;
$$;
```

### Delete Function (`delete_{entity}`)

Soft delete with audit trail:

```sql
CREATE FUNCTION crm.delete_contact(
    tenant_id UUID,
    contact_id UUID
)
RETURNS app.mutation_result
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = crm, app, common
AS $$
DECLARE
    v_result app.mutation_result;
    v_pk INTEGER;
BEGIN
    -- Resolve and validate
    v_pk := crm.contact_pk(contact_id::TEXT, tenant_id);
    IF v_pk IS NULL THEN
        RETURN app.error_result('Contact not found');
    END IF;

    -- Soft delete
    UPDATE crm.tb_contact SET
        deleted_at = now(),
        deleted_by = current_user_id()
    WHERE pk_contact = v_pk
      AND tenant_id = tenant_id;

    v_result.success := true;
    v_result.message := 'Contact deleted successfully';

    RETURN v_result;
END;
$$;
```

## Custom Action Functions

### Business Logic Actions

Custom actions from YAML generate specialized functions:

```yaml
actions:
  - name: qualify_lead
    description: "Convert lead to qualified prospect"
    steps:
      - validate: status = 'lead'
      - update: Contact SET status = 'qualified', qualified_at = now()
      - notify: sales_team "New qualified lead"
```

**Generated:**
```sql
CREATE FUNCTION crm.qualify_lead(
    tenant_id UUID,
    contact_id UUID
)
RETURNS app.mutation_result
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = crm, app, common
AS $$
DECLARE
    v_result app.mutation_result;
    v_pk INTEGER;
    v_status TEXT;
BEGIN
    -- Resolve identifier
    v_pk := crm.contact_pk(contact_id::TEXT, tenant_id);
    IF v_pk IS NULL THEN
        RETURN app.error_result('Contact not found');
    END IF;

    -- Get current status
    SELECT status INTO v_status
    FROM crm.tb_contact
    WHERE pk_contact = v_pk;

    -- Business validation
    IF v_status != 'lead' THEN
        RETURN app.error_result('Contact must be a lead to qualify');
    END IF;

    -- Execute business logic
    UPDATE crm.tb_contact SET
        status = 'qualified',
        qualified_at = now(),
        updated_at = now(),
        updated_by = current_user_id()
    WHERE pk_contact = v_pk;

    -- Notification (would integrate with external system)
    -- PERFORM notify_sales_team('New qualified lead: ' || contact_id);

    v_result.success := true;
    v_result.message := 'Lead qualified successfully';

    RETURN v_result;
END;
$$;
```

### Complex Multi-Step Actions

Actions can orchestrate multiple operations:

```yaml
actions:
  - name: create_opportunity
    description: "Create opportunity with contact and organization"
    steps:
      - validate: contact_email IS NOT NULL
      - insert: Contact
      - insert: Opportunity
      - call: send_welcome_email(contact.email)
      - notify: sales_team "New opportunity created"
```

## Indexes and Performance

### Automatic Indexes

SpecQL generates performance-optimized indexes:

```sql
-- Unique constraints (automatic)
CREATE UNIQUE INDEX idx_tb_contact_id ON crm.tb_contact(id);
CREATE UNIQUE INDEX idx_tb_contact_email ON crm.tb_contact(email) WHERE deleted_at IS NULL;

-- Foreign key indexes (automatic)
CREATE INDEX idx_tb_contact_fk_organization ON crm.tb_contact(fk_organization);

-- Multi-tenancy indexes (automatic for tenant schema)
CREATE INDEX idx_tb_contact_tenant ON crm.tb_contact(tenant_id);

-- Performance indexes for common queries
CREATE INDEX idx_tb_contact_status ON crm.tb_contact(status) WHERE deleted_at IS NULL;
CREATE INDEX idx_tb_contact_created_at ON crm.tb_contact(created_at) WHERE deleted_at IS NULL;

-- Composite indexes for tenant isolation
CREATE INDEX idx_tb_contact_tenant_status ON crm.tb_contact(tenant_id, status) WHERE deleted_at IS NULL;
```

### Index Naming Convention

| Pattern | Example | Purpose |
|---------|---------|---------|
| `idx_tb_{entity}_id` | `idx_tb_contact_id` | UUID lookup |
| `idx_tb_{entity}_{field}` | `idx_tb_contact_email` | Field lookup |
| `idx_tb_{entity}_fk_{entity}` | `idx_tb_contact_fk_org` | Foreign key |
| `idx_tb_{entity}_tenant` | `idx_tb_contact_tenant` | Tenant isolation |
| `idx_tb_{entity}_tenant_{field}` | `idx_tb_contact_tenant_status` | Tenant-scoped queries |

## Constraints and Data Integrity

### Check Constraints

Rich types generate automatic CHECK constraints:

```sql
-- Email validation
ALTER TABLE crm.tb_contact
ADD CONSTRAINT contact_email_check
CHECK (email ~ '^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$');

-- Phone validation (E.164)
ALTER TABLE crm.tb_contact
ADD CONSTRAINT contact_phone_check
CHECK (phone ~ '^\+[1-9]\d{1,14}$');

-- Percentage range
ALTER TABLE crm.tb_contact
ADD CONSTRAINT contact_score_check
CHECK (score >= 0 AND score <= 100);

-- Enum validation
ALTER TABLE crm.tb_contact
ADD CONSTRAINT contact_status_check
CHECK (status IN ('lead', 'qualified', 'customer'));
```

### Foreign Key Constraints

Automatic referential integrity:

```sql
-- Trinity pattern: INTEGER foreign keys
ALTER TABLE crm.tb_contact
ADD CONSTRAINT tb_contact_fk_organization_fkey
FOREIGN KEY (fk_organization)
REFERENCES crm.tb_organization(pk_organization);

-- Multi-tenancy: Cross-tenant validation
ALTER TABLE crm.tb_contact
ADD CONSTRAINT tb_contact_tenant_organization_fkey
FOREIGN KEY (tenant_id, fk_organization)
REFERENCES crm.tb_organization(tenant_id, pk_organization);
```

### Unique Constraints

Business uniqueness rules:

```sql
-- Global unique
ALTER TABLE crm.tb_contact
ADD CONSTRAINT tb_contact_email_key UNIQUE (email);

-- Tenant-scoped unique
ALTER TABLE crm.tb_contact
ADD CONSTRAINT tb_contact_tenant_email_key UNIQUE (tenant_id, email);
```

## Multi-Tenancy Patterns

### Row Level Security (RLS)

Automatic tenant isolation for `tenant` schema:

```sql
-- Enable RLS
ALTER TABLE crm.tb_contact ENABLE ROW LEVEL SECURITY;

-- Tenant isolation policy
CREATE POLICY tenant_isolation ON crm.tb_contact
  USING (tenant_id = current_tenant_id());

-- Function security
CREATE FUNCTION crm.create_contact(...) RETURNS app.mutation_result
SECURITY DEFINER  -- Runs with elevated privileges
SET search_path = crm, app, common;  -- Controlled schema access
```

### Tenant Context Functions

```sql
-- Set current tenant (from JWT)
CREATE FUNCTION app.set_current_tenant(p_tenant_id UUID) RETURNS VOID AS $$
BEGIN
    -- Store in session variable
    PERFORM set_config('app.current_tenant_id', p_tenant_id::TEXT, false);
END;
$$ LANGUAGE plpgsql;

-- Get current tenant
CREATE FUNCTION app.current_tenant_id() RETURNS UUID AS $$
BEGIN
    RETURN current_setting('app.current_tenant_id', true)::UUID;
END;
$$ LANGUAGE plpgsql;
```

## GraphQL Integration (FraiseQL)

### Function Annotations

All functions get FraiseQL annotations for auto-discovery:

```sql
-- Mutation annotation
COMMENT ON FUNCTION crm.create_contact(UUID, TEXT, TEXT, TEXT) IS
  'Create a new contact
@fraiseql:mutation
@fraiseql:impact contact_created';

-- Query annotation
COMMENT ON FUNCTION crm.get_contacts(UUID) IS
  'Get all contacts for tenant
@fraiseql:query(name: "contacts")
@fraiseql:type ContactConnection';
```

### Table Annotations

Tables get GraphQL type information:

```sql
COMMENT ON TABLE crm.tb_contact IS
  'Customer contact information
@fraiseql:type Contact
trinity: true';

COMMENT ON COLUMN crm.tb_contact.email IS
  'Primary email address
@fraiseql:field
type: Email!
required: true';
```

## Error Handling Patterns

### Mutation Result Type

Standardized error/success responses:

```sql
-- Result type definition
CREATE TYPE app.mutation_result AS (
    success BOOLEAN,
    message TEXT,
    object JSONB,      -- Created/updated object
    errors JSONB       -- Validation errors
);

-- Success result function
CREATE FUNCTION app.success_result(p_message TEXT, p_object JSONB DEFAULT NULL)
RETURNS app.mutation_result AS $$
BEGIN
    RETURN (true, p_message, p_object, NULL)::app.mutation_result;
END;
$$ LANGUAGE plpgsql;

-- Error result function
CREATE FUNCTION app.error_result(p_message TEXT, p_errors JSONB DEFAULT NULL)
RETURNS app.mutation_result AS $$
BEGIN
    RETURN (false, p_message, NULL, p_errors)::app.mutation_result;
END;
$$ LANGUAGE plpgsql;
```

### Validation Error Format

Structured validation errors:

```sql
-- Validation error example
SELECT app.error_result(
    'Validation failed',
    jsonb_build_object(
        'email', jsonb_build_object(
            'code', 'EMAIL_INVALID',
            'message', 'Email format is invalid'
        ),
        'phone', jsonb_build_object(
            'code', 'PHONE_INVALID',
            'message', 'Phone must be in E.164 format'
        )
    )
);
```

## File Organization

### Directory Structure

Generated files follow numbered system:

```
db/schema/
â”œâ”€â”€ 00_foundation/           # App types, extensions
â”‚   â”œâ”€â”€ 00_extensions.sql
â”‚   â””â”€â”€ 01_types.sql
â”œâ”€â”€ 10_tables/               # Table definitions
â”‚   â”œâ”€â”€ contact.sql
â”‚   â””â”€â”€ organization.sql
â”œâ”€â”€ 20_helpers/              # Helper functions
â”‚   â”œâ”€â”€ contact_helpers.sql
â”‚   â””â”€â”€ organization_helpers.sql
â”œâ”€â”€ 30_functions/            # Business functions
â”‚   â”œâ”€â”€ create_contact.sql
â”‚   â”œâ”€â”€ update_contact.sql
â”‚   â”œâ”€â”€ qualify_lead.sql
â”‚   â””â”€â”€ create_organization.sql
â””â”€â”€ 40_indexes/              # Performance indexes
    â”œâ”€â”€ contact_indexes.sql
    â””â”€â”€ organization_indexes.sql
```

### Numbering Systems

#### Decimal System (Default)
Simple sequential numbering:

```
00_foundation/
10_tables/
20_helpers/
30_functions/
40_indexes/
```

#### Hexadecimal System (Enterprise)
Hierarchical registry-based:

```
01_app/
â”œâ”€â”€ 01_foundation/
â”œâ”€â”€ 02_types/
â””â”€â”€ 03_utilities/
02_domain/
â”œâ”€â”€ 01_crm/
â”‚   â”œâ”€â”€ 01_tables/
â”‚   â”œâ”€â”€ 02_helpers/
â”‚   â””â”€â”€ 03_functions/
â””â”€â”€ 02_billing/
    â”œâ”€â”€ 01_tables/
    â”œâ”€â”€ 02_helpers/
    â””â”€â”€ 03_functions/
```

## Migration Patterns

### Schema Evolution

Safe migration generation:

```sql
-- Migration file example
BEGIN;

-- Add new column
ALTER TABLE crm.tb_contact ADD COLUMN phone TEXT;

-- Add check constraint
ALTER TABLE crm.tb_contact ADD CONSTRAINT contact_phone_check
CHECK (phone ~ '^\+[1-9]\d{1,14}$');

-- Add comment for GraphQL
COMMENT ON COLUMN crm.tb_contact.phone IS
  'Phone number in E.164 format
@fraiseql:field
type: Phone';

COMMIT;
```

### Backward Compatibility

Generated code maintains compatibility:

```sql
-- Function overloading for new parameters
CREATE FUNCTION crm.create_contact(
    tenant_id UUID,
    email TEXT,
    first_name TEXT,
    last_name TEXT,
    phone TEXT DEFAULT NULL  -- New optional parameter
) RETURNS app.mutation_result AS $$
-- Implementation
$$ LANGUAGE plpgsql;
```

## Testing Patterns

### Generated Test Fixtures

```sql
-- Test data generation
INSERT INTO crm.tb_contact (
    tenant_id, id, email, first_name, last_name
) VALUES
    ('test-tenant'::UUID, gen_random_uuid(), 'john@example.com', 'John', 'Doe'),
    ('test-tenant'::UUID, gen_random_uuid(), 'jane@example.com', 'Jane', 'Smith');

-- Test helper functions
CREATE FUNCTION test.create_test_contact(
    p_email TEXT,
    p_first_name TEXT,
    p_last_name TEXT
) RETURNS UUID AS $$
DECLARE
    v_result app.mutation_result;
BEGIN
    SELECT * INTO v_result FROM crm.create_contact(
        'test-tenant'::UUID, p_email, p_first_name, p_last_name
    );

    IF NOT v_result.success THEN
        RAISE EXCEPTION 'Failed to create test contact: %', v_result.message;
    END IF;

    RETURN (v_result.object->>'id')::UUID;
END;
$$ LANGUAGE plpgsql;
```

## Performance Characteristics

### Query Optimization

Generated queries are optimized for common patterns:

```sql
-- Efficient tenant-scoped queries
SELECT c.* FROM crm.tb_contact c
WHERE c.tenant_id = current_tenant_id()
  AND c.deleted_at IS NULL
  AND c.status = 'active'
ORDER BY c.created_at DESC
LIMIT 50;

-- Uses indexes:
-- idx_tb_contact_tenant_status (tenant_id, status)
-- idx_tb_contact_created_at (created_at)
```

### Connection Pooling

Functions designed for connection pooler compatibility:

```sql
-- No session state dependencies
CREATE FUNCTION crm.get_contact(p_id UUID)
RETURNS JSONB AS $$
    SELECT json_build_object(
        'id', c.id,
        'email', c.email,
        'firstName', c.first_name,
        'lastName', c.last_name
    )
    FROM crm.tb_contact c
    WHERE c.id = p_id
      AND c.tenant_id = current_tenant_id()
      AND c.deleted_at IS NULL;
$$ LANGUAGE sql STABLE;  -- Can be pooled
```

## Security Patterns

### SQL Injection Prevention

All generated code uses parameterized queries:

```sql
-- Safe parameterized query
EXECUTE 'SELECT * FROM crm.tb_contact WHERE email = $1 AND tenant_id = $2'
INTO v_contact
USING p_email, p_tenant_id;
```

### Privilege Escalation Prevention

Functions run with controlled permissions:

```sql
-- SECURITY DEFINER with restricted search path
CREATE FUNCTION crm.create_contact(...) RETURNS app.mutation_result
SECURITY DEFINER
SET search_path = crm, app, common  -- No public schema access
AS $$
-- Function body
$$ LANGUAGE plpgsql;
```

## Next Steps

- **Read YAML Syntax**: DSL specification in `docs/reference/yaml-syntax.md`
- **Check Scalar Types**: Type reference in `docs/reference/scalar-types.md`
- **Browse Templates**: See Jinja2 templates in `templates/sql/`
- **Run Generation**: Execute `specql generate entities/*.yaml` to see patterns

---

**Production patterns, generated automatically.** ðŸ”§