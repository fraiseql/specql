# SpecQL Schema Generator

**Business-focused YAML â†’ PostgreSQL + GraphQL Backend**

Transform 40 lines of YAML into a production-ready backend with PostgreSQL schema, GraphQL API, and automated tests.

---

## ğŸš€ Quick Start

### Installation

```bash
# Clone repository
git clone <repo-url>
cd printoptim_backend_poc

# Setup environment
uv venv
source .venv/bin/activate

# Install dependencies
make install
```

### Generate Your First Entity

```bash
# 1. Create entity definition
cat > entities/examples/contact.yaml <<'EOF'
entity: Contact
schema: crm
description: "Customer contact information"
fields:
  email: text
  first_name: text
  last_name: text
  status: enum(lead, qualified, customer)
actions:
  - name: create_contact
    steps:
      - validate: email MATCHES email_pattern
      - insert: Contact
  - name: qualify_lead
    requires: caller.can_edit_contact
    steps:
      - validate: status = 'lead'
      - update: Contact SET status = 'qualified'
EOF

# 2. Generate schema files and build migration
specql generate entities/examples/contact.yaml

# 3. View generated files
ls -R db/schema/
ls db/generated/

# 4. Apply to database
confiture migrate up --env local
```

**Result**: Working PostgreSQL schema + GraphQL API in < 10 minutes! ğŸ‰

---

## ğŸ› ï¸ CLI Commands

### SpecQL Commands

```bash
# Generate schema from entity files
specql generate entities/examples/*.yaml

# Generate for specific environment
specql generate --env production entities/examples/*.yaml

# Validate entity files
specql validate entities/examples/*.yaml

# Show differences between entity and existing schema
specql diff entities/examples/contact.yaml --compare db/schema/10_tables/contact.sql
```

### Confiture Commands

```bash
# Build migration from generated schema files
confiture build --env local

# Apply migration to database
confiture migrate up --env local

# Check migration status
confiture migrate status --env local

# Rollback migration
confiture migrate down --env local
```

### Development Commands

```bash
# Run all tests
make test

# Run linting and type checking
make lint
make typecheck

# Generate documentation
make docs
```

### Running Tests

#### Full Test Suite

```bash
# Run all tests (including database tests)
make test

# Run without database tests
uv run pytest -m "not database"
```

#### Database Tests

Database integration tests require PostgreSQL:

```bash
# 1. Create test database
createdb specql_test

# 2. Load schema
psql specql_test < tests/schema/setup.sql

# 3. Run database tests
uv run pytest -m database -v
```

**Environment Variables** (optional):

```bash
# Configure database connection
export TEST_DB_HOST=localhost
export TEST_DB_PORT=5432
export TEST_DB_NAME=specql_test
export TEST_DB_USER=$USER
export TEST_DB_PASSWORD=

# Run tests
make test
```

**CI/CD Setup**:

```yaml
# GitHub Actions example
- name: Setup PostgreSQL
  run: |
    sudo apt-get install postgresql postgresql-contrib
    sudo -u postgres createdb specql_test
    sudo -u postgres psql specql_test < tests/schema/setup.sql

- name: Run Tests
  env:
    TEST_DB_HOST: localhost
    TEST_DB_NAME: specql_test
    TEST_DB_USER: postgres
    TEST_DB_PASSWORD: postgres
  run: uv run pytest -v
```

---

## ğŸ“Š What Gets Generated

From this YAML (40 lines):

```yaml
entity: Contact
  schema: crm
  fields:
    first_name: text
    last_name: text
    email: text
    status: enum(lead, qualified, customer)
    company: ref(Company)

  actions:
    - name: create_contact
      steps:
        - validate: email MATCHES email_pattern
          error: "invalid_email"
        - insert: Contact
```

You get (2000+ lines):

### âœ… PostgreSQL Schema
```sql
-- Trinity Pattern table
CREATE TABLE crm.tb_contact (
    pk_contact INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    id UUID DEFAULT gen_random_uuid() NOT NULL,
    first_name TEXT,
    last_name TEXT,
    email TEXT,
    status TEXT CHECK (status IN ('lead', 'qualified', 'customer')),
    fk_company INTEGER REFERENCES management.tb_organization(pk_organization),
    created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT now(),
    deleted_at TIMESTAMPTZ
);

-- Trinity helper functions
CREATE FUNCTION core.contact_pk(p_identifier TEXT) RETURNS INTEGER ...
CREATE FUNCTION core.contact_id(p_pk INTEGER) RETURNS UUID ...

-- Business logic functions
CREATE FUNCTION crm.fn_create_contact(p_input JSONB) RETURNS TABLE(...) ...

-- FraiseQL view
CREATE VIEW crm.v_contact AS ...
```

### âœ… GraphQL API (via FraiseQL)

**Two-Layer Architecture**:
- **App Layer** (`app.*`): GraphQL API entry points with `@fraiseql:mutation`
- **Core Layer** (`schema.*`): Internal business logic, NO annotations

FraiseQL introspects **only** the app layer for GraphQL schema generation.

```graphql
type Contact {
  id: UUID!
  firstName: String
  lastName: String
  email: String
  status: ContactStatus
  company: Company
}

enum ContactStatus {
  LEAD
  QUALIFIED
  CUSTOMER
}

type Mutation {
  createContact(input: CreateContactInput!): ContactResult!
}
```

### âœ… TypeScript Types
```typescript
interface Contact {
  id: string;
  firstName?: string;
  lastName?: string;
  email: string;
  status: 'lead' | 'qualified' | 'customer';
  company?: Company;
}

type CreateContactInput = {
  email: string;
  status: ContactStatus;
};
```

### âœ… Auto-Generated Tests
- Happy path tests
- Validation tests
- Foreign key tests
- Edge case tests

---

## ğŸ’¡ Key Features

### 1. **SpecQL DSL** - Business Logic Language

Write workflows, not boilerplate:

```yaml
actions:
  - name: qualify_lead
    requires: contact.status = 'lead' AND caller.is_owner
    steps:
      - validate: lead_score >= 70
        error: "insufficient_lead_score"
      - update: Contact SET status = 'qualified'
      - call: create_opportunity(contact_id = contact.id)
      - notify: owner(email, 'Lead qualified!')
```

Compiles to production PostgreSQL with audit, events, and error handling.

### 2. **Trinity Pattern** - Optimal Performance

Every table has:
- `pk_*` (INTEGER) - Fast joins
- `id` (UUID) - Stable external ID
- `identifier` (TEXT) - Human-readable key

Best of all worlds: performance + stability + usability.

### 3. **Group Leader Pattern** - Data Coherence

Prevent impossible data combinations:

```yaml
field_groups:
  - group_leader: fk_company
    dependent_fields: [company_country, company_address]
```

Database triggers ensure company address always matches company.

### 4. **Hierarchical Numbering** - AI-Discoverable

Self-documenting paths:
```
01_write_side/013_catalog/0132_manufacturer/01321_manufacturer/013211_tb_manufacturer.sql
â”‚  â””â”€ layer   â””â”€ domain  â””â”€ group        â””â”€ entity       â””â”€ table code + name
```

### 5. **AI Agents** (Phase 4) - Automation

```yaml
agents:
  - name: lead_scoring_agent
    type: ai_llm
    observes: ['contact.created', 'activity.logged']
    strategy: |
      Score leads 0-100 based on company size, industry fit, engagement
```

Framework provides sandbox, LLM integration, audit trail.

---

## ğŸ—ï¸ Architecture

```
YAML Entity (40 lines)
    â†“
SpecQL Parser (Team A)
    â†“
Entity AST
    â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚        â”‚            â”‚              â”‚
â†“        â†“            â†“              â†“
Tables   Functions   Views        Numbering
(Team B) (Team B)    (Team D)     (Team C)
    â†“
PostgreSQL Schema
    â†“
FraiseQL Introspection (Team D)
    â†“
GraphQL API + TypeScript Types
```

---

## ğŸ“ Repository Structure

```
printoptim_backend_poc/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ core/           # Team A: SpecQL parser
â”‚   â”œâ”€â”€ generators/     # Team B: SQL generators
â”‚   â”œâ”€â”€ numbering/      # Team C: Hierarchical organization
â”‚   â”œâ”€â”€ integration/    # Team D: FraiseQL + GraphQL
â”‚   â””â”€â”€ cli/            # Team E: Developer tools
â”œâ”€â”€ tests/
â”‚   â”œâ”€â”€ unit/           # Fast, isolated tests
â”‚   â””â”€â”€ integration/    # End-to-end tests
â”œâ”€â”€ templates/          # Jinja2 templates
â”œâ”€â”€ entities/           # YAML entity definitions
â””â”€â”€ generated/          # Output (git-ignored)
```

See [REPOSITORY_STRUCTURE.md](REPOSITORY_STRUCTURE.md) for full details.

---

## ğŸ§ª Testing

```bash
# Run all tests
make test

# Run specific team tests
make teamA-test    # Core parser
make teamB-test    # SQL generators
make teamC-test    # Numbering system
make teamD-test    # Integration layer
make teamE-test    # CLI tools

# Code quality
make lint          # Ruff linting
make typecheck     # Mypy type checking
make coverage      # Coverage report
```

---

## ğŸ“š Documentation

- [Getting Started Guide](docs/guides/getting-started.md) (TODO)
- [SpecQL DSL Reference](docs/guides/specql-dsl-reference.md) (TODO)
- [Implementation Plan](docs/architecture/IMPLEMENTATION_PLAN_SPECQL.md)
- [Contributing Guide](CONTRIBUTING.md)
- [Repository Structure](REPOSITORY_STRUCTURE.md)

---

## ğŸ¤ Contributing

We use a **team-based parallelization strategy** with 5 independent work streams.

See [CONTRIBUTING.md](CONTRIBUTING.md) for:
- Development workflow (TDD)
- Team assignments
- Testing guidelines
- PR process

---

## ğŸ“Š Project Status

**Phase**: 1 - Core Parser + SQL Generators
**Progress**: 5% (Repository structure complete)
**Timeline**: 10 weeks to production-ready platform

### Milestones

- [ ] **Week 1-2**: Core parser + basic SQL generation
- [ ] **Week 3-4**: Trinity tables + action compilation
- [ ] **Week 5-6**: Numbering system + manifest
- [ ] **Week 7-8**: AI agent runtime
- [ ] **Week 9-10**: Production polish + migration tools

---

## ğŸ¯ ROI & Benefits

### Time Savings
- **Before**: 6 hours to create entity manually
- **After**: 1 hour (mostly writing YAML)
- **Savings**: 83% faster

### Code Quality
- âœ… Consistent patterns across all entities
- âœ… Complete documentation (auto-generated)
- âœ… Comprehensive tests (auto-generated)
- âœ… No copy-paste errors

### Strategic Value
- Same YAML â†’ Multiple outputs (SQL, GraphQL, TypeScript)
- Schema migrations via regeneration (99% faster)
- AI-discoverable structure (LLM-friendly)

---

## ğŸ”— Related Projects

- **FraiseQL** - GraphQL introspection framework
- **TestFoundry** - Test data generation
- **Trinity Pattern** - PostgreSQL best practices

---

## ğŸ“„ License

[License TBD]

---

## ğŸ™ Acknowledgments

Built with insights from:
- SpecQL business logic patterns
- FraiseQL integration requirements
- printoptim_backend Trinity pattern
- TestFoundry group leader pattern

---

**Built by the PrintOptim Team** ğŸš€
