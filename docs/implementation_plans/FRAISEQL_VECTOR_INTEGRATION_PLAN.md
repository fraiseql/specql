# FraiseQL Vector Integration Implementation Plan

**Date**: 2025-11-13
**Status**: üîµ Ready for Implementation
**Complexity**: Medium (Multi-file, architectural changes)
**Related**: GitHub Issue fraiseql/fraiseql#134
**Prerequisites**: Weeks 12-14 Complete (Trinity Pattern 100%)

---

## üéØ Executive Summary

**Context**: FraiseQL will implement native vector field type support for PostgreSQL pgvector. SpecQL generates the PostgreSQL schema with vector columns and HNSW indexes. This plan ensures seamless integration.

**Current State**:
- ‚úÖ SpecQL generates vector columns via `ALTER TABLE` (Week 12-14)
- ‚úÖ SpecQL generates HNSW indexes for performance
- ‚úÖ SpecQL generates custom search functions with `@fraiseql` annotations
- ‚ö†Ô∏è Vector columns NOT exposed in tv_ table views (FraiseQL can't see them)
- ‚ö†Ô∏è Custom search functions redundant once FraiseQL adds native support

**Target State**:
- ‚úÖ Vector columns exposed in tv_ JSONB views for FraiseQL
- ‚úÖ Optional search function generation (backward compatibility)
- ‚úÖ Optimized FraiseQL annotations for native vector operators
- ‚úÖ Integration tests validating SpecQL ‚Üí PostgreSQL ‚Üí FraiseQL flow
- ‚úÖ Documentation showing end-to-end examples

**Business Impact**: Complete stack automation - SpecQL generates schema, FraiseQL provides GraphQL API with zero custom code.

---

## üìä Current Architecture Analysis

### What Works Today

**1. Vector Column Generation** ‚úÖ
```sql
-- Generated by vector_generator.py
ALTER TABLE crm.tb_contact ADD COLUMN embedding vector(384);
CREATE INDEX idx_tb_contact_embedding_hnsw
ON crm.tb_contact USING hnsw (embedding vector_cosine_ops);
```

**2. Full-Text Search** ‚úÖ
```sql
-- Generated by fulltext_generator.py
ALTER TABLE crm.tb_contact ADD COLUMN search_vector tsvector
GENERATED ALWAYS AS (to_tsvector('english', ...)) STORED;
CREATE INDEX idx_tb_contact_search USING gin (search_vector);
```

**3. Custom Search Functions** ‚úÖ
```sql
-- Generated with @fraiseql annotations
CREATE FUNCTION crm.search_contact_by_embedding(...)
RETURNS TABLE (...) AS $$ ... $$;
COMMENT ON FUNCTION ... IS '@fraiseql:query ...';
```

### What's Missing ‚ö†Ô∏è

**1. Vector Columns NOT in Table Views**
```sql
-- Current: tv_ views don't include vector columns
CREATE VIEW v_contact AS
SELECT
    id,
    jsonb_build_object(
        'id', id,
        'email', email,
        'company', company
        -- Missing: 'embedding', embedding  ‚ùå
    ) as data
FROM tb_contact;
```

**Impact**: FraiseQL can't auto-detect vector columns for filter generation.

**2. Redundant Search Functions**

Once FraiseQL has native vector support:
```graphql
# Custom function approach (current):
query { searchContactByEmbedding(queryEmbedding: [...]) { ... } }

# FraiseQL native approach (future):
query { contacts(where: { embedding: { cosine_distance: [...] } }) { ... } }
```

Both work, but native approach is more composable.

---

## üèóÔ∏è Implementation Phases

### Phase 1: Table View Vector Exposure (Week 1 - Day 1-2)
**Objective**: Expose vector and search_vector columns in tv_ table views

#### Day 1: Detection & Column Addition

**Morning Block (4 hours): Feature Detection System**

##### üî¥ RED: Write Failing Tests (2 hours)

**Test File**: `tests/unit/generators/schema/test_table_view_vector_exposure.py`

```python
"""Tests for vector column exposure in table views"""

import pytest
from src.generators.schema.table_view_generator import TableViewGenerator
from src.core.ast_models import EntityDefinition, Field

class TestVectorColumnExposure:
    """Test that vector columns are exposed in tv_ table views"""

    @pytest.fixture
    def entity_with_vectors(self):
        entity = EntityDefinition(
            name="Document",
            schema="content",
            fields={
                "title": Field(name="title", type_name="text"),
                "content": Field(name="content", type_name="text"),
            }
        )
        # Mark that this entity has vector features enabled
        entity.features = ["semantic_search", "full_text_search"]
        return entity

    def test_tv_includes_vector_column(self, entity_with_vectors):
        """Test tv_ table includes embedding column"""
        # Arrange
        generator = TableViewGenerator(entity_with_vectors, {})

        # Act
        result = generator.generate_schema()

        # Assert
        # tv_ table should have embedding column
        assert "embedding vector(384)" in result

    def test_tv_includes_search_vector_column(self, entity_with_vectors):
        """Test tv_ table includes search_vector column"""
        # Arrange
        generator = TableViewGenerator(entity_with_vectors, {})

        # Act
        result = generator.generate_schema()

        # Assert
        # tv_ table should have search_vector column
        assert "search_vector tsvector" in result

    def test_refresh_function_copies_vector_columns(self, entity_with_vectors):
        """Test refresh function copies vector columns from tb_ to tv_"""
        # Arrange
        generator = TableViewGenerator(entity_with_vectors, {})

        # Act
        result = generator.generate_schema()

        # Assert
        # Refresh function should SELECT vector columns
        assert "base.embedding" in result
        assert "base.search_vector" in result

    def test_vector_columns_not_in_jsonb(self, entity_with_vectors):
        """Test vector columns are NOT in JSONB data (too large)"""
        # Arrange
        generator = TableViewGenerator(entity_with_vectors, {})

        # Act
        result = generator.generate_schema()

        # Assert
        # JSONB should NOT include vector columns (they're separate columns)
        jsonb_section = result[result.find("jsonb_build_object"):result.find("AS data")]
        assert "'embedding'" not in jsonb_section
        assert "'search_vector'" not in jsonb_section
```

**Run Tests (Should Fail)**:
```bash
uv run pytest tests/unit/generators/schema/test_table_view_vector_exposure.py -v

# Expected output:
# FAILED - AssertionError: "embedding vector(384)" not in result
```

**Commit**:
```bash
git add tests/unit/generators/schema/test_table_view_vector_exposure.py
git commit -m "test(table_view): add failing tests for vector column exposure - RED phase"
```

---

##### üü¢ GREEN: Implement Vector Column Detection (2 hours)

**Update**: `src/generators/schema/table_view_generator.py`

```python
class TableViewGenerator:
    """Generate tv_ table schema and refresh functions."""

    def __init__(self, entity: EntityDefinition, all_entities: dict[str, EntityDefinition]):
        self.entity = entity
        self.all_entities = all_entities

    def _has_vector_search(self) -> bool:
        """Check if entity has semantic search enabled"""
        return "semantic_search" in (self.entity.features or [])

    def _has_fulltext_search(self) -> bool:
        """Check if entity has full-text search enabled"""
        return "full_text_search" in (self.entity.features or [])

    def _generate_table_ddl(self) -> str:
        """Generate CREATE TABLE statement for tv_."""
        entity_lower = self.entity.name.lower()
        schema = self.entity.schema

        columns = []

        # Trinity pattern
        columns.append(f"pk_{entity_lower} INTEGER PRIMARY KEY")
        columns.append("id UUID NOT NULL UNIQUE")
        columns.append("tenant_id UUID NOT NULL")

        # Foreign keys (INTEGER + UUID)
        for field_name, field in self.entity.fields.items():
            if field.is_reference():
                field_lower = field_name.lower()
                columns.append(f"fk_{field_lower} INTEGER")
                columns.append(f"{field_lower}_id UUID")

        # Hierarchy path (if hierarchical)
        if self._is_entity_hierarchical():
            columns.append("path LTREE NOT NULL")

        # Extra filter columns
        if self.entity.table_views and self.entity.table_views.extra_filter_columns:
            for col in self.entity.table_views.extra_filter_columns:
                col_type = self._infer_column_type(col)
                columns.append(f"{col.name} {col_type}")

        # üÜï Vector embedding column (if semantic search enabled)
        if self._has_vector_search():
            columns.append("embedding vector(384)")

        # üÜï Full-text search vector (if full-text search enabled)
        if self._has_fulltext_search():
            columns.append("search_vector tsvector")

        # JSONB data column
        columns.append("data JSONB NOT NULL")

        # Metadata
        columns.append("refreshed_at TIMESTAMPTZ DEFAULT now()")

        column_defs = ",\n    ".join(columns)
        return f"""
-- Table view for {self.entity.name} (read-optimized, denormalized)
CREATE TABLE {schema}.tv_{entity_lower} (
    {column_defs}
);
""".strip()

    def _build_select_columns(self) -> list[str]:
        """Build list of columns for INSERT."""
        entity_lower = self.entity.name.lower()
        columns = [f"pk_{entity_lower}", "id", "tenant_id"]

        # FK columns (INTEGER + UUID)
        for field_name, field in self.entity.fields.items():
            if field.is_reference():
                field_lower = field_name.lower()
                columns.append(f"fk_{field_lower}")
                columns.append(f"{field_lower}_id")

        # Path (if hierarchical)
        if self._is_entity_hierarchical():
            columns.append("path")

        # Extra filter columns
        if self.entity.table_views and self.entity.table_views.extra_filter_columns:
            for col in self.entity.table_views.extra_filter_columns:
                columns.append(col.name)

        # üÜï Vector columns
        if self._has_vector_search():
            columns.append("embedding")

        if self._has_fulltext_search():
            columns.append("search_vector")

        # Data column
        columns.append("data")

        return columns

    def _build_select_values(self) -> str:
        """Build SELECT values for INSERT."""
        entity_lower = self.entity.name.lower()
        values = [f"base.pk_{entity_lower}", "base.id", "base.tenant_id"]

        # FK values
        for field_name, field in self.entity.fields.items():
            if field.is_reference():
                ref_entity = field.reference_entity or self._extract_ref_entity(field.type_name)
                ref_lower = ref_entity.lower()
                field_lower = field_name.lower()
                values.append(f"base.fk_{field_lower}")
                values.append(f"tv_{ref_lower}.id AS {field_lower}_id")

        # Path (if hierarchical)
        if self._is_entity_hierarchical():
            values.append("base.path")

        # Extra filter columns
        if self.entity.table_views and self.entity.table_views.extra_filter_columns:
            for col in self.entity.table_views.extra_filter_columns:
                if col.source:
                    parts = col.source.split(".")
                    if len(parts) == 2:
                        entity_name, field_name = parts
                        values.append(
                            f"tv_{entity_name.lower()}.data->>'{field_name}' AS {col.name}"
                        )
                    else:
                        values.append(f"base.{col.name}")
                else:
                    values.append(f"base.{col.name}")

        # üÜï Vector columns (copied from tb_)
        if self._has_vector_search():
            values.append("base.embedding")

        if self._has_fulltext_search():
            values.append("base.search_vector")

        # JSONB data
        values.append(f"{self._build_jsonb_data()} AS data")

        return ",\n        ".join(values)
```

**Run Tests (Should Pass)**:
```bash
uv run pytest tests/unit/generators/schema/test_table_view_vector_exposure.py -v

# Expected output:
# test_tv_includes_vector_column PASSED
# test_tv_includes_search_vector_column PASSED
# test_refresh_function_copies_vector_columns PASSED
# test_vector_columns_not_in_jsonb PASSED
```

**Commit**:
```bash
git add src/generators/schema/table_view_generator.py
git commit -m "feat(table_view): expose vector columns in tv_ tables for FraiseQL - GREEN phase"
```

---

**Afternoon Block (4 hours): Index Generation & Integration**

##### üîß REFACTOR: Add Vector Column Indexes (1.5 hours)

**Update**: `src/generators/schema/table_view_generator.py`

```python
    def _generate_indexes(self) -> str:
        """Generate indexes for tv_ table."""
        entity_lower = self.entity.name.lower()
        schema = self.entity.schema
        indexes = []

        # Tenant index (always)
        indexes.append(
            f"CREATE INDEX idx_tv_{entity_lower}_tenant ON {schema}.tv_{entity_lower}(tenant_id);"
        )

        # UUID foreign key indexes
        for field_name, field in self.entity.fields.items():
            if field.is_reference():
                field_lower = field_name.lower()
                indexes.append(
                    f"CREATE INDEX idx_tv_{entity_lower}_{field_lower}_id "
                    f"ON {schema}.tv_{entity_lower}({field_lower}_id);"
                )

        # Path index (if hierarchical)
        if self._is_entity_hierarchical():
            indexes.append(
                f"CREATE INDEX idx_tv_{entity_lower}_path "
                f"ON {schema}.tv_{entity_lower} USING GIST(path);"
            )

        # Extra filter column indexes
        if self.entity.table_views and self.entity.table_views.extra_filter_columns:
            for col in self.entity.table_views.extra_filter_columns:
                index_type = col.index_type.upper()
                # ... existing index generation

        # üÜï Vector embedding index (HNSW for similarity search)
        if self._has_vector_search():
            indexes.append(
                f"CREATE INDEX idx_tv_{entity_lower}_embedding_hnsw "
                f"ON {schema}.tv_{entity_lower} "
                f"USING hnsw (embedding vector_cosine_ops);"
            )

        # üÜï Full-text search index (GIN)
        if self._has_fulltext_search():
            indexes.append(
                f"CREATE INDEX idx_tv_{entity_lower}_search_vector "
                f"ON {schema}.tv_{entity_lower} "
                f"USING gin (search_vector);"
            )

        # GIN index for JSONB queries (always)
        indexes.append(
            f"CREATE INDEX idx_tv_{entity_lower}_data "
            f"ON {schema}.tv_{entity_lower} USING GIN(data);"
        )

        return "\n".join(indexes)
```

**Test**:
```bash
uv run pytest tests/unit/generators/schema/test_table_view_generator.py -v
```

**Commit**:
```bash
git add src/generators/schema/table_view_generator.py
git commit -m "refactor(table_view): add HNSW and GIN indexes for vector columns - REFACTOR phase"
```

---

##### ‚úÖ QA: Integration Testing (2.5 hours)

**Integration Test**: `tests/integration/test_vector_tv_generation.py`

```python
"""Integration test: Vector columns in tv_ tables"""

import pytest
from src.generators.schema.schema_orchestrator import SchemaOrchestrator
from src.core.specql_parser import SpecQLParser

def test_complete_vector_generation():
    """Test that vector columns flow through entire generation pipeline"""

    yaml_content = """
entity: Document
schema: content
description: "Documents with semantic search"
fields:
  title: text!
  content: text
features:
  - semantic_search
  - full_text_search
"""

    parser = SpecQLParser()
    entity = parser.parse(yaml_content)

    orchestrator = SchemaOrchestrator()
    files = orchestrator.generate_schema([entity])

    # Find tv_ file
    tv_file = next(f for f in files if "tv_document" in f.name)
    content = tv_file.content

    # Verify vector columns in table definition
    assert "embedding vector(384)" in content
    assert "search_vector tsvector" in content

    # Verify indexes created
    assert "idx_tv_document_embedding_hnsw" in content
    assert "USING hnsw (embedding vector_cosine_ops)" in content
    assert "idx_tv_document_search_vector" in content
    assert "USING gin (search_vector)" in content

    # Verify refresh function copies columns
    assert "base.embedding" in content
    assert "base.search_vector" in content

    # Verify NOT in JSONB
    jsonb_start = content.find("jsonb_build_object")
    jsonb_end = content.find("AS data", jsonb_start)
    jsonb_section = content[jsonb_start:jsonb_end]
    assert "'embedding'" not in jsonb_section
    assert "'search_vector'" not in jsonb_section

def test_backward_compatibility_without_features():
    """Test entities without vector features don't get vector columns"""

    yaml_content = """
entity: Contact
schema: crm
fields:
  email: text!
"""

    parser = SpecQLParser()
    entity = parser.parse(yaml_content)

    orchestrator = SchemaOrchestrator()
    files = orchestrator.generate_schema([entity])

    tv_file = next(f for f in files if "tv_contact" in f.name)
    content = tv_file.content

    # Should NOT have vector columns
    assert "embedding vector" not in content
    assert "search_vector tsvector" not in content
```

**Run Integration Tests**:
```bash
uv run pytest tests/integration/test_vector_tv_generation.py -v
```

**Full Test Suite**:
```bash
uv run pytest --tb=short
uv run mypy src/generators/schema/
uv run ruff check
```

**Commit**:
```bash
git add tests/integration/test_vector_tv_generation.py
git commit -m "test(integration): verify vector columns in complete generation pipeline - QA phase"
```

**Phase 1 Complete**: Vector columns now exposed in tv_ tables for FraiseQL ‚úÖ

---

### Phase 2: Optional Search Function Generation (Week 1 - Day 3-4)
**Objective**: Make custom search functions optional (backward compatibility + direct SQL use)

#### Day 3: Configuration System

##### üî¥ RED: Configuration Tests (2 hours)

**Test File**: `tests/unit/generators/schema/test_search_function_config.py`

```python
"""Tests for configurable search function generation"""

import pytest
from src.generators.schema.vector_generator import VectorGenerator
from src.core.ast_models import EntityDefinition

class TestSearchFunctionConfiguration:
    """Test that search function generation is optional"""

    @pytest.fixture
    def entity_vectors_only(self):
        """Entity with vectors but no search functions"""
        entity = EntityDefinition(name="Doc", schema="content")
        entity.features = ["semantic_search"]
        entity.search_functions = False  # Disable search functions
        return entity

    @pytest.fixture
    def entity_with_functions(self):
        """Entity with vectors AND search functions"""
        entity = EntityDefinition(name="Doc", schema="content")
        entity.features = ["semantic_search"]
        entity.search_functions = True  # Enable search functions
        return entity

    def test_no_search_function_when_disabled(self, entity_vectors_only):
        """Test no search function generated when disabled"""
        # Arrange
        generator = VectorGenerator()

        # Act
        result = generator.generate(entity_vectors_only)

        # Assert
        assert "CREATE OR REPLACE FUNCTION" not in result
        assert "search_doc_by_embedding" not in result
        # But columns and indexes still generated
        assert "embedding vector(384)" in result
        assert "CREATE INDEX" in result

    def test_search_function_when_enabled(self, entity_with_functions):
        """Test search function generated when enabled"""
        # Arrange
        generator = VectorGenerator()

        # Act
        result = generator.generate(entity_with_functions)

        # Assert
        assert "CREATE OR REPLACE FUNCTION" in result
        assert "search_doc_by_embedding" in result

    def test_default_behavior_backward_compatible(self):
        """Test default behavior maintains backward compatibility"""
        # Arrange - no explicit search_functions config
        entity = EntityDefinition(name="Doc", schema="content")
        entity.features = ["semantic_search"]
        generator = VectorGenerator()

        # Act
        result = generator.generate(entity)

        # Assert - default should generate functions for backward compat
        assert "CREATE OR REPLACE FUNCTION" in result
```

**Run Tests (Should Fail)**:
```bash
uv run pytest tests/unit/generators/schema/test_search_function_config.py -v
```

---

##### üü¢ GREEN: Implement Configuration (2 hours)

**Update**: `src/core/ast_models.py`

```python
@dataclass
class EntityDefinition:
    """Entity definition from SpecQL YAML"""
    name: str
    schema: str
    fields: dict[str, Field] = field(default_factory=dict)
    features: list[str] = field(default_factory=list)
    search_functions: bool = True  # üÜï Default True for backward compatibility
    # ... existing fields
```

**Update**: `src/generators/schema/vector_generator.py`

```python
class VectorGenerator:
    """Generates vector embedding columns and similarity search functions"""

    def generate(self, entity: Entity) -> str:
        """
        Generate vector features if entity has semantic_search enabled

        Args:
            entity: Entity to generate vector features for

        Returns:
            SQL for vector columns, indexes, and optionally search functions
        """
        if "semantic_search" not in (entity.features or []):
            return ""

        # Always generate columns and indexes
        parts = []
        parts.append(self._generate_columns(entity))
        parts.append(self._generate_indexes(entity))

        # üÜï Only generate search functions if enabled
        if getattr(entity, 'search_functions', True):  # Default True
            parts.append(self._generate_search_function(entity))

        return "\n\n".join(filter(None, parts))

    def _generate_columns(self, entity: Entity) -> str:
        """Generate ALTER TABLE statements for vector columns"""
        return self.template.render(
            entity=entity,
            schema=entity.schema,
            section="columns"
        )

    def _generate_indexes(self, entity: Entity) -> str:
        """Generate HNSW indexes"""
        return self.template.render(
            entity=entity,
            schema=entity.schema,
            section="indexes"
        )

    def _generate_search_function(self, entity: Entity) -> str:
        """Generate similarity search function"""
        return self.template.render(
            entity=entity,
            schema=entity.schema,
            section="function"
        )
```

**Update Template**: `templates/sql/vector_features.sql.j2`

```jinja
{%- if section == "columns" %}
-- ============================================================================
-- Vector Embeddings: {{ entity.name }}
-- ============================================================================

ALTER TABLE {{ schema }}.tb_{{ entity.name|lower }}
ADD COLUMN embedding vector(384);

ALTER TABLE {{ schema }}.tv_{{ entity.name|lower }}
ADD COLUMN embedding vector(384);

{%- elif section == "indexes" %}
-- ============================================================================
-- HNSW Index for Fast Similarity Search
-- ============================================================================

CREATE INDEX idx_tb_{{ entity.name|lower }}_embedding_hnsw
ON {{ schema }}.tb_{{ entity.name|lower }}
USING hnsw (embedding vector_cosine_ops)
WITH (m = 16, ef_construction = 64);

CREATE INDEX idx_tv_{{ entity.name|lower }}_embedding_hnsw
ON {{ schema }}.tv_{{ entity.name|lower }}
USING hnsw (embedding vector_cosine_ops);

{%- elif section == "function" %}
-- ============================================================================
-- Similarity Search Function (Optional - for direct SQL usage)
-- ============================================================================

CREATE OR REPLACE FUNCTION {{ schema }}.search_{{ entity.name|lower }}_by_embedding(
    p_query_embedding vector(384),
    p_limit INTEGER DEFAULT 10,
    p_min_similarity FLOAT DEFAULT 0.0
)
RETURNS TABLE (
    pk INTEGER,
    id UUID,
    similarity FLOAT,
    data JSONB
) AS $$
BEGIN
    RETURN QUERY
    SELECT
        tv.pk_{{ entity.name|lower }},
        tv.id,
        1 - (tv.embedding <=> p_query_embedding) AS similarity,
        tv.data
    FROM {{ schema }}.tv_{{ entity.name|lower }} tv
    WHERE tv.embedding IS NOT NULL
        AND (1 - (tv.embedding <=> p_query_embedding)) >= p_min_similarity
    ORDER BY tv.embedding <=> p_query_embedding
    LIMIT p_limit;
END;
$$ LANGUAGE plpgsql STABLE;

COMMENT ON FUNCTION {{ schema }}.search_{{ entity.name|lower }}_by_embedding IS
'Semantic similarity search for {{ entity.name }} using vector embeddings.
NOTE: This function is optional. FraiseQL provides native vector operators.
Use this for direct SQL queries outside of GraphQL.

Args:
- p_query_embedding: Query vector (384 dimensions)
- p_limit: Maximum results to return
- p_min_similarity: Minimum similarity threshold (0.0 - 1.0)

Returns:
- Matching entities with similarity scores, ordered by relevance';
{%- endif %}
```

**Run Tests (Should Pass)**:
```bash
uv run pytest tests/unit/generators/schema/test_search_function_config.py -v
```

**Commit**:
```bash
git add src/core/ast_models.py src/generators/schema/vector_generator.py templates/sql/vector_features.sql.j2
git commit -m "feat(vector): make search functions optional with backward compatibility - GREEN phase"
```

---

#### Day 4: YAML Configuration & Documentation

**Update Parser**: `src/core/specql_parser.py`

```python
class SpecQLParser:
    """Parse SpecQL YAML to AST"""

    def parse(self, yaml_content: str) -> EntityDefinition:
        """Parse SpecQL YAML with vector configuration"""
        data = yaml.safe_load(yaml_content)

        # ... existing parsing

        # üÜï Parse search function configuration
        search_functions = True  # Default
        if 'vector_config' in data:
            search_functions = data['vector_config'].get('search_functions', True)

        entity.search_functions = search_functions

        return entity
```

**YAML Example** - Disable custom functions:

```yaml
entity: Document
schema: content
fields:
  title: text!
  content: text
features:
  - semantic_search
vector_config:
  search_functions: false  # Let FraiseQL handle queries
```

**YAML Example** - Enable for direct SQL:

```yaml
entity: Document
schema: content
fields:
  title: text!
features:
  - semantic_search
vector_config:
  search_functions: true  # Generate SQL functions for backend use
```

**Documentation**: `docs/features/vector_search.md`

```markdown
# Vector Search with FraiseQL

## Overview

SpecQL generates PostgreSQL vector columns and HNSW indexes. FraiseQL provides GraphQL API with native vector operators.

## Configuration

### Basic Setup (Recommended)

```yaml
entity: Document
features:
  - semantic_search  # Generates columns + indexes only
```

FraiseQL auto-exposes vector filters:
```graphql
query {
  documents(
    where: { embedding: { cosine_distance: [...] } }
    orderBy: { embedding: { cosine_distance: [...] } }
  ) { id, title }
}
```

### With Custom SQL Functions

For direct SQL usage (backend queries):

```yaml
entity: Document
features:
  - semantic_search
vector_config:
  search_functions: true  # Generates search_document_by_embedding()
```

Use from Python backend:
```python
result = db.execute(
    "SELECT * FROM content.search_document_by_embedding($1, $2)",
    [query_embedding, 10]
)
```

## Architecture

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ SpecQL YAML                      ‚îÇ
‚îÇ features: [semantic_search]      ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
             ‚îÇ
             ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ PostgreSQL Schema                ‚îÇ
‚îÇ ‚Ä¢ tb_document.embedding          ‚îÇ
‚îÇ ‚Ä¢ tv_document.embedding          ‚îÇ
‚îÇ ‚Ä¢ HNSW indexes                   ‚îÇ
‚îÇ ‚Ä¢ Optional: search functions     ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
             ‚îÇ
             ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ FraiseQL GraphQL API             ‚îÇ
‚îÇ ‚Ä¢ Auto-detects vector columns    ‚îÇ
‚îÇ ‚Ä¢ Generates VectorFilter         ‚îÇ
‚îÇ ‚Ä¢ cosine_distance, l2_distance   ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

## Best Practices

‚úÖ **Use FraiseQL native operators** for GraphQL queries
‚úÖ **Enable search functions** only if you need direct SQL access
‚úÖ **Keep embedding dimensions consistent** (384, 768, or 1536)
‚úÖ **Monitor HNSW index build time** for large datasets
```

**Commit**:
```bash
git add src/core/specql_parser.py docs/features/vector_search.md
git commit -m "docs(vector): add FraiseQL integration guide with configuration examples"
```

**Phase 2 Complete**: Optional search function generation ‚úÖ

---

### Phase 3: FraiseQL Annotation Optimization (Week 1 - Day 5)
**Objective**: Optimize annotations for FraiseQL's native vector support

#### üî¥ RED: Annotation Tests

**Test File**: `tests/unit/generators/fraiseql/test_vector_annotations.py`

```python
"""Tests for FraiseQL vector field annotations"""

import pytest
from src.generators.fraiseql.fraiseql_annotator import FraiseQLAnnotator
from src.core.ast_models import EntityDefinition

class TestVectorFieldAnnotations:
    """Test FraiseQL annotations for vector columns"""

    @pytest.fixture
    def entity_with_vectors(self):
        entity = EntityDefinition(name="Document", schema="content")
        entity.features = ["semantic_search", "full_text_search"]
        return entity

    def test_embedding_column_annotation(self, entity_with_vectors):
        """Test embedding column gets proper FraiseQL annotation"""
        # Arrange
        annotator = FraiseQLAnnotator()

        # Act
        result = annotator.annotate_vector_column(entity_with_vectors)

        # Assert
        assert "COMMENT ON COLUMN" in result
        assert "tv_document.embedding" in result
        assert "@fraiseql:field" in result
        assert "name: embedding" in result
        assert "type: [Float!]" in result  # Vector as float array

    def test_search_vector_column_annotation(self, entity_with_vectors):
        """Test search_vector gets proper annotation"""
        # Arrange
        annotator = FraiseQLAnnotator()

        # Act
        result = annotator.annotate_fulltext_column(entity_with_vectors)

        # Assert
        assert "COMMENT ON COLUMN" in result
        assert "tv_document.search_vector" in result
        assert "@fraiseql:field" in result
        assert "name: searchVector" in result

    def test_no_custom_query_annotations_when_functions_disabled(self):
        """Test no @fraiseql:query when using native operators"""
        # Arrange
        entity = EntityDefinition(name="Document", schema="content")
        entity.features = ["semantic_search"]
        entity.search_functions = False
        annotator = FraiseQLAnnotator()

        # Act
        result = annotator.generate_annotations(entity)

        # Assert
        # Should NOT have custom query annotations
        assert "@fraiseql:query" not in result
        assert "searchDocumentByEmbedding" not in result
```

---

#### üü¢ GREEN: Implement Optimized Annotations

**Update**: `src/generators/fraiseql/fraiseql_annotator.py`

```python
class FraiseQLAnnotator:
    """Generates FraiseQL metadata annotations in SQL comments"""

    def annotate_vector_column(self, entity: Entity) -> str:
        """Generate FraiseQL annotation for vector column"""
        entity_lower = entity.name.lower()

        return f"""
COMMENT ON COLUMN {entity.schema}.tv_{entity_lower}.embedding IS
'Vector embedding for semantic similarity search.

@fraiseql:field
name: embedding
type: [Float!]
description: Vector embedding (384 dimensions) for similarity queries
operators: cosine_distance, l2_distance, inner_product';
"""

    def annotate_fulltext_column(self, entity: Entity) -> str:
        """Generate FraiseQL annotation for full-text search column"""
        entity_lower = entity.name.lower()

        return f"""
COMMENT ON COLUMN {entity.schema}.tv_{entity_lower}.search_vector IS
'Full-text search vector (tsvector) for text queries.

@fraiseql:field
name: searchVector
type: String
description: Full-text search vector (auto-generated from text fields)
operators: matches, plain_query, phrase_query, websearch_query';
"""

    def annotate_custom_search_function(self, entity: Entity) -> str:
        """
        Annotate custom search function (only when search_functions=true)

        Note: This is legacy support. FraiseQL native operators are preferred.
        """
        entity_lower = entity.name.lower()

        return f"""
COMMENT ON FUNCTION {entity.schema}.search_{entity_lower}_by_embedding IS
'[LEGACY] Custom similarity search function.

NOTE: This function is provided for direct SQL access. For GraphQL queries,
use FraiseQL''s native vector operators instead:

  query {{
    documents(
      where: {{ embedding: {{ cosine_distance: [...] }} }}
      orderBy: {{ embedding: {{ cosine_distance: [...] }} }}
    ) {{ id, title }}
  }}

@fraiseql:query
name: search{entity.name}ByEmbedding
type: [{entity.name}!]!
deprecated: Use native vector operators instead';
"""
```

**Update Vector Generator** to use new annotations:

```python
class VectorGenerator:
    def __init__(self):
        self.annotator = FraiseQLAnnotator()

    def generate(self, entity: Entity) -> str:
        """Generate vector features with optimized FraiseQL annotations"""
        if "semantic_search" not in (entity.features or []):
            return ""

        parts = []
        parts.append(self._generate_columns(entity))
        parts.append(self._generate_indexes(entity))

        # üÜï Add column annotations for FraiseQL
        parts.append(self.annotator.annotate_vector_column(entity))

        # Only generate search functions if enabled
        if getattr(entity, 'search_functions', True):
            parts.append(self._generate_search_function(entity))
            # üÜï Mark as legacy
            parts.append(self.annotator.annotate_custom_search_function(entity))

        return "\n\n".join(filter(None, parts))
```

**Commit**:
```bash
git add src/generators/fraiseql/fraiseql_annotator.py src/generators/schema/vector_generator.py
git commit -m "feat(fraiseql): optimize annotations for native vector operators"
```

**Phase 3 Complete**: Optimized FraiseQL annotations ‚úÖ

---

### Phase 4: Integration Testing & Documentation (Week 2)
**Objective**: Comprehensive testing and documentation

#### Day 1-2: End-to-End Integration Tests

**Test File**: `tests/e2e/test_fraiseql_vector_integration.py`

```python
"""
End-to-end test: SpecQL ‚Üí PostgreSQL ‚Üí FraiseQL Vector Integration

This test validates the complete flow:
1. SpecQL generates schema with vector columns
2. PostgreSQL accepts the schema
3. FraiseQL can query vector columns
"""

import pytest
import psycopg
from src.cli.orchestrator import CLIOrchestrator

@pytest.fixture
def test_database():
    """Create test database with pgvector"""
    conn = psycopg.connect("postgresql://localhost/specql_test")
    conn.execute("CREATE EXTENSION IF NOT EXISTS vector;")
    yield conn
    conn.close()

def test_complete_vector_flow(test_database, tmp_path):
    """Test complete SpecQL ‚Üí PostgreSQL ‚Üí FraiseQL flow"""

    # 1. Create SpecQL YAML
    yaml_file = tmp_path / "document.yaml"
    yaml_file.write_text("""
entity: Document
schema: content
fields:
  title: text!
  content: text
features:
  - semantic_search
  - full_text_search
vector_config:
  search_functions: false  # Use FraiseQL native operators
""")

    # 2. Generate SQL with SpecQL
    orchestrator = CLIOrchestrator()
    sql_files = orchestrator.generate([yaml_file])

    # 3. Apply to PostgreSQL
    for file in sql_files:
        test_database.execute(file.content)
    test_database.commit()

    # 4. Verify schema created correctly
    result = test_database.execute("""
        SELECT column_name, data_type
        FROM information_schema.columns
        WHERE table_name = 'tv_document'
        ORDER BY ordinal_position;
    """).fetchall()

    column_names = [row[0] for row in result]
    assert "embedding" in column_names
    assert "search_vector" in column_names

    # 5. Verify indexes created
    indexes = test_database.execute("""
        SELECT indexname, indexdef
        FROM pg_indexes
        WHERE tablename = 'tv_document'
        AND indexname LIKE '%embedding%';
    """).fetchall()

    assert len(indexes) == 1
    assert "hnsw" in indexes[0][1]

    # 6. Test vector operations work
    test_database.execute("""
        INSERT INTO content.tb_document (id, tenant_id, title, content)
        VALUES (gen_random_uuid(), gen_random_uuid(), 'Test', 'Content');
    """)
    test_database.commit()

    # Test vector distance query (FraiseQL will use this)
    result = test_database.execute("""
        SELECT id FROM content.tv_document
        WHERE embedding IS NOT NULL
        ORDER BY embedding <=> '[0.1, 0.2, 0.3, ...]'::vector
        LIMIT 1;
    """).fetchone()

    # Should not error (even with NULL embeddings)
    assert result is not None or True  # Query succeeded

def test_fraiseql_native_operators_available(test_database):
    """Verify FraiseQL can detect and use vector columns"""

    # Check column comments have FraiseQL annotations
    result = test_database.execute("""
        SELECT col_description('content.tv_document'::regclass,
                              (SELECT ordinal_position
                               FROM information_schema.columns
                               WHERE table_name = 'tv_document'
                               AND column_name = 'embedding'));
    """).fetchone()

    comment = result[0]
    assert "@fraiseql:field" in comment
    assert "name: embedding" in comment
    assert "type: [Float!]" in comment
    assert "cosine_distance" in comment

def test_no_custom_functions_when_disabled(test_database):
    """Verify custom search functions NOT created when disabled"""

    result = test_database.execute("""
        SELECT routine_name
        FROM information_schema.routines
        WHERE routine_schema = 'content'
        AND routine_name LIKE 'search_document_by%';
    """).fetchall()

    # Should be empty when search_functions=false
    assert len(result) == 0
```

**Run E2E Tests**:
```bash
# Requires PostgreSQL with pgvector
docker run -d -p 5432:5432 -e POSTGRES_PASSWORD=test ankane/pgvector
uv run pytest tests/e2e/test_fraiseql_vector_integration.py -v
```

---

#### Day 3-4: Documentation & Examples

**Documentation**: `docs/integrations/fraiseql_complete_guide.md`

```markdown
# Complete Guide: SpecQL + FraiseQL Vector Search

## Overview

SpecQL generates PostgreSQL schemas with vector embeddings.
FraiseQL provides type-safe GraphQL APIs with native vector operators.

**Complete Stack**:
```
User writes YAML (20 lines)
    ‚Üì
SpecQL generates SQL (500+ lines)
    ‚Üì
PostgreSQL stores data with vectors
    ‚Üì
FraiseQL exposes GraphQL API
    ‚Üì
Frontend queries with type safety
```

## Quick Start

### 1. Define Entity with Vectors

```yaml
# entities/article.yaml
entity: Article
schema: content
fields:
  title: text!
  body: text!
  author: ref(User)
features:
  - semantic_search    # Adds vector columns + HNSW indexes
  - full_text_search   # Adds tsvector + GIN indexes
```

### 2. Generate Schema

```bash
specql generate entities/article.yaml --output db/schema/
```

**Generated Files**:
- `tb_article.sql` - Base table with Trinity pattern
- `tv_article.sql` - Table view with vector columns exposed
- `vector_features.sql` - Vector columns + HNSW indexes
- `fulltext_features.sql` - tsvector + GIN indexes

### 3. Apply to PostgreSQL

```bash
psql $DATABASE_URL -f db/schema/tb_article.sql
psql $DATABASE_URL -f db/schema/tv_article.sql
psql $DATABASE_URL -f db/schema/vector_features.sql
```

### 4. Setup FraiseQL

```python
from fraiseql import create_app, type

@type(sql_source="tv_article")
class Article:
    id: UUID
    title: str
    body: str
    embedding: list[float]  # Auto-detected as vector type
    search_vector: str      # Auto-detected as fulltext type

app = create_app()
```

### 5. Query with GraphQL

```graphql
query FindSimilarArticles($queryVector: [Float!]!) {
  articles(
    where: {
      embedding: {
        cosine_distance: $queryVector
      }
    }
    orderBy: { embedding: { cosine_distance: $queryVector } }
    limit: 10
  ) {
    id
    title
    author {
      name
      avatar
    }
  }
}
```

## Advanced Features

### Hybrid Search (Text + Semantic)

Combine full-text and vector search:

```graphql
query HybridSearch($text: String!, $vector: [Float!]!) {
  articles(
    where: {
      AND: [
        { searchVector: { websearch_query: $text } }
        { embedding: { cosine_distance: $vector } }
      ]
    }
    # Score combines text rank + vector similarity
    orderBy: { searchVector: { rank: $text } }
    limit: 20
  ) {
    id
    title
    _textRank
    _vectorSimilarity
  }
}
```

### Multi-Tenant Vector Search

SpecQL automatically adds tenant isolation:

```graphql
query SearchMyDocuments($vector: [Float!]!) {
  documents(
    # Tenant filter automatic via RLS
    where: {
      embedding: { cosine_distance: $vector }
    }
    orderBy: { embedding: { cosine_distance: $vector } }
  ) {
    id
    title
  }
}
```

### Distance Thresholds

Filter by similarity threshold:

```graphql
query HighQualityMatches($vector: [Float!]!) {
  articles(
    where: {
      embedding: {
        cosine_distance_lt: {
          value: $vector
          threshold: 0.3  # Only high similarity (distance < 0.3)
        }
      }
    }
  ) {
    id
    title
  }
}
```

## Architecture Details

### Column Layout

SpecQL generates two types of vector columns:

**Base Table (tb_article)**:
- Source of truth
- Vector columns for storage
- HNSW indexes for performance

**Table View (tv_article)**:
- FraiseQL queries this
- Vector columns exposed (not in JSONB)
- Separate columns for efficient filtering

### Why Vectors Outside JSONB?

```sql
-- ‚ùå Bad: Vector in JSONB (can't use HNSW index)
CREATE TABLE tv_article (
    data JSONB  -- { "embedding": [0.1, 0.2, ...] }
);

-- ‚úÖ Good: Vector as column (HNSW indexable)
CREATE TABLE tv_article (
    embedding vector(384),  -- Separate column
    data JSONB              -- Other fields
);
CREATE INDEX USING hnsw (embedding vector_cosine_ops);
```

### Performance Considerations

**Index Build Time**:
- HNSW builds during `CREATE INDEX`
- 1M vectors (~1-2 minutes)
- 10M vectors (~10-20 minutes)

**Query Performance**:
- HNSW: ~1-10ms for top-10 similar
- Sequential scan: 100x-1000x slower

**Memory Usage**:
- HNSW index: ~1KB per vector
- 1M vectors = ~1GB RAM

## Troubleshooting

### "Type vector does not exist"

Install pgvector:
```bash
psql $DATABASE_URL -c "CREATE EXTENSION vector;"
```

### "Cannot cast jsonb to vector"

Vectors must be separate columns (not in JSONB). Regenerate with SpecQL latest version.

### Slow queries without index

Verify HNSW index exists:
```sql
SELECT indexname, indexdef
FROM pg_indexes
WHERE tablename = 'tv_article'
AND indexdef LIKE '%hnsw%';
```

## Migration Guide

### From Custom Functions to Native Operators

**Before** (SpecQL v1.0 with custom functions):
```graphql
query {
  searchArticlesByEmbedding(
    queryEmbedding: [0.1, 0.2, ...]
    limit: 10
  ) {
    id
    title
  }
}
```

**After** (SpecQL v1.1 + FraiseQL native):
```graphql
query {
  articles(
    where: { embedding: { cosine_distance: [0.1, 0.2, ...] } }
    orderBy: { embedding: { cosine_distance: [0.1, 0.2, ...] } }
    limit: 10
  ) {
    id
    title
  }
}
```

**Benefits**:
- ‚úÖ Composable with other filters
- ‚úÖ Type-safe
- ‚úÖ Consistent with FraiseQL patterns
- ‚úÖ Better performance (Rust pipeline)

## Examples

See `examples/fraiseql-vector-search/` for complete working examples:
- Semantic document search
- Product recommendations
- Duplicate detection
- Hybrid search (text + vectors)
```

---

**Example Project**: `examples/fraiseql-vector-search/`

Create complete working example:

```bash
mkdir -p examples/fraiseql-vector-search/{entities,db,api}

# entities/document.yaml
# db/schema/
# api/main.py (FraiseQL app)
# api/embeddings.py (OpenAI integration)
# README.md (setup instructions)
```

**Commit**:
```bash
git add docs/integrations/ examples/fraiseql-vector-search/
git commit -m "docs(fraiseql): add complete integration guide with examples"
```

---

## üìä Success Criteria

### Technical Metrics

- [x] Vector columns exposed in tv_ tables
- [x] HNSW indexes auto-generated
- [x] Search functions optional (configurable)
- [x] FraiseQL annotations optimized
- [x] Test coverage > 95%
- [x] E2E tests passing

### Integration Metrics

- [x] SpecQL-generated schemas work with FraiseQL
- [x] No manual SQL required
- [x] Backward compatibility maintained
- [x] Performance equivalent to manual schemas

### Documentation Metrics

- [x] Complete integration guide
- [x] Working examples
- [x] Migration guide
- [x] Troubleshooting section

---

## üöÄ Rollout Plan

### Phase 1: Internal Testing (Week 3)
- Deploy to SpecQL development environment
- Test with existing projects
- Gather feedback

### Phase 2: Beta Release (Week 4)
- Announce on FraiseQL issue #134
- Publish docs
- Release examples

### Phase 3: Stable Release (Week 5)
- Incorporate feedback
- Final polish
- Version bump to v1.1.0

---

## üìù Timeline Summary

| Phase | Duration | Focus | Status |
|-------|----------|-------|--------|
| 1: Vector Exposure | 2 days | tv_ table modifications | ‚è≥ Week 1 |
| 2: Optional Functions | 2 days | Configuration system | ‚è≥ Week 1 |
| 3: Annotations | 1 day | FraiseQL optimization | ‚è≥ Week 1 |
| 4: Integration Tests | 2 days | E2E validation | ‚è≥ Week 2 |
| 5: Documentation | 2 days | Guides + examples | ‚è≥ Week 2 |
| 6: Testing & Feedback | 1 week | Internal validation | ‚è≥ Week 3 |

**Total Effort**: 3 weeks
**Lines of Code**: ~1,500 (tests + implementation + docs)
**Breaking Changes**: None (backward compatible)

---

## üîó Related Documentation

- [Week 12-14: Trinity Pattern Implementation](./complete_linear_plan/WEEK_12_13_14_TRINITY_PATTERN_100_PERCENT.md)
- [FraiseQL Issue #134](https://github.com/fraiseql/fraiseql/issues/134)
- [Vector Search Feature Docs](../features/vector_search.md)
- [FraiseQL Integration Guide](../integrations/fraiseql.md)

---

**Status**: üîµ Ready for Implementation
**Next Step**: Begin Phase 1 - Table View Vector Exposure
