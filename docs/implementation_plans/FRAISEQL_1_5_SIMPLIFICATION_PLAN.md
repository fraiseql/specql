# FraiseQL 1.5 Integration: Simplification Opportunities for SpecQL

**Date**: 2025-11-14
**Status**: Planning
**Priority**: High
**Estimated Impact**: 70% reduction in vector/embedding code (543 â†’ 160 lines)

## Executive Summary

FraiseQL 1.5 introduces native **embeddings and vector search** capabilities that can significantly simplify SpecQL's internal implementation. This document outlines opportunities to reduce maintenance burden, improve standardization, and leverage FraiseQL's optimized vector operations.

**Key Benefit**: Reduce SpecQL's vector/embedding infrastructure by ~383 lines (70%) while improving functionality and maintainability.

---

## Table of Contents

1. [Current State Analysis](#current-state-analysis)
2. [Simplification Opportunities](#simplification-opportunities)
3. [Code Reduction Estimate](#code-reduction-estimate)
4. [Migration Strategy](#migration-strategy)
5. [What to Keep](#what-to-keep)
6. [Next Steps](#next-steps)

---

## Current State Analysis

### SpecQL's Vector/Embedding Implementation (543+ lines)

SpecQL currently implements a comprehensive vector search infrastructure:

#### **1. Vector Generation** (`src/generators/schema/vector_generator.py` - 91 lines)
```python
class VectorGenerator:
    """Generates vector embedding columns and similarity search functions"""

    def generate(self, entity: EntityDefinition) -> str:
        # Generates:
        # - ALTER TABLE statements for vector columns
        # - HNSW indexes for similarity search
        # - Custom search functions (search_<entity>_by_embedding)
        # - FraiseQL annotations
```

**Responsibilities:**
- Generate `ALTER TABLE ... ADD COLUMN embedding vector(384)`
- Create HNSW indexes (`CREATE INDEX ... USING hnsw`)
- Generate custom SQL search functions
- Annotate for FraiseQL discovery

#### **2. Embedding Service** (`src/infrastructure/services/embedding_service.py` - 163 lines)
```python
class EmbeddingService:
    """Service for generating semantic embeddings from text"""

    def __init__(self, model_name: str = "all-MiniLM-L6-v2"):
        self.model = SentenceTransformer(model_name)
        self.embedding_dimension = 384
```

**Responsibilities:**
- Load sentence-transformers models
- Generate 384-dim embeddings
- Batch processing
- Cosine similarity calculations
- Model caching with LRU

#### **3. Pattern Embedding Service** (`src/pattern_library/embeddings_pg.py` - 229 lines)
```python
class PatternEmbeddingService:
    """Generate and manage pattern embeddings using PostgreSQL + pgvector"""

    def __init__(self, connection_string: Optional[str] = None):
        self.model = SentenceTransformer("all-MiniLM-L6-v2")
        self.conn = psycopg.connect(connection_string)
        register_vector(self.conn)
```

**Responsibilities:**
- PostgreSQL + pgvector integration
- Pattern-specific embedding generation
- Semantic search retrieval (`retrieve_similar`)
- HNSW index management
- Connection pooling

#### **4. CLI Commands** (`src/cli/embeddings.py` - 60 lines)
```bash
specql embeddings generate          # Generate embeddings for all patterns
specql embeddings test-retrieval    # Test pattern retrieval with a query
```

**Responsibilities:**
- Generate embeddings command
- Test retrieval command
- Rich table output formatting

#### **5. FraiseQL Annotations** (`src/generators/fraiseql/fraiseql_annotator.py`)
```python
def annotate_vector_column(self, entity: EntityDefinition) -> str:
    """Generate FraiseQL annotation for vector column"""
    return f"""
    COMMENT ON COLUMN {entity.schema}.tv_{entity_lower}.embedding IS
    '@fraiseql:field
    name: embedding
    type: [Float!]
    operators: cosine_distance, l2_distance, inner_product';
    """

def annotate_custom_search_function(self, entity: EntityDefinition) -> str:
    """Annotate custom search function (legacy support)"""
    # Marks custom functions as deprecated
    # Recommends FraiseQL native operators instead
```

**Current SQL Generation Example:**
```sql
-- Generated by SpecQL for semantic_search feature
ALTER TABLE crm.tv_document ADD COLUMN embedding vector(384);

CREATE INDEX idx_tv_document_embedding_hnsw
ON crm.tv_document
USING hnsw (embedding vector_cosine_ops)
WITH (m = 16, ef_construction = 64);

CREATE FUNCTION crm.search_document_by_embedding(
    p_query_embedding vector(384),
    p_limit INTEGER DEFAULT 10,
    p_min_similarity FLOAT DEFAULT 0.5
)
RETURNS TABLE(...) AS $$
    SELECT
        *,
        1 - (embedding <=> p_query_embedding) AS similarity
    FROM crm.tv_document
    WHERE (1 - (embedding <=> p_query_embedding)) >= p_min_similarity
    ORDER BY embedding <=> p_query_embedding
    LIMIT p_limit;
$$ LANGUAGE SQL STABLE;
```

---

## Simplification Opportunities

### ðŸŽ¯ **1. Remove Custom Vector Search Functions** (Est. savings: ~150 lines)

#### Current State

SpecQL generates custom SQL search functions for every entity with `semantic_search` feature:

```sql
CREATE FUNCTION search_document_by_embedding(
    p_query_embedding vector(384),
    p_limit INTEGER DEFAULT 10,
    p_min_similarity FLOAT DEFAULT 0.5
)
RETURNS TABLE(...) AS $$
    SELECT *, 1 - (embedding <=> p_query_embedding) AS similarity
    FROM tv_document
    WHERE (1 - (embedding <=> p_query_embedding)) >= p_min_similarity
    ORDER BY embedding <=> p_query_embedding
    LIMIT p_limit;
$$ LANGUAGE SQL;
```

Users then call these functions:
```sql
SELECT * FROM search_document_by_embedding('[0.123, 0.456, ...]'::vector, 10, 0.7);
```

#### With FraiseQL 1.5

FraiseQL should natively expose vector operators in GraphQL:

```graphql
query FindSimilarDocuments($queryEmbedding: [Float!]!) {
  documents(
    where: {
      embedding: {
        cosineDistance: {
          vector: $queryEmbedding,
          threshold: 0.7
        }
      }
    }
    orderBy: { embedding: { cosineDistance: $queryEmbedding } }
    limit: 10
  ) {
    id
    title
    content
    similarity  # Auto-calculated by FraiseQL
  }
}
```

**Benefits:**
- âœ… Type-safe GraphQL queries instead of raw SQL
- âœ… No custom function generation per entity
- âœ… FraiseQL handles operator optimization
- âœ… Consistent API across all vector-enabled entities

#### What to Remove

**Files/Methods to simplify:**
- `VectorGenerator._generate_search_function()` (src/generators/schema/vector_generator.py:66-72)
- Custom function templates in `templates/sql/vector_features.sql.j2`
- `FraiseQLAnnotator.annotate_custom_search_function()` (fraiseql_annotator.py:146-172)
- `FraiseQLAnnotator.annotate_search_functions()` (fraiseql_annotator.py:202-248)

**What to keep:**
- Vector column generation (FraiseQL needs columns to exist)
- HNSW index generation (critical for performance)
- Optional annotations for custom descriptions

---

### ðŸŽ¯ **2. Delegate Embedding Generation to FraiseQL 1.5** (Est. savings: ~300 lines)

#### Current State

SpecQL maintains its own embedding infrastructure:

```python
# Load model
service = EmbeddingService(model_name="all-MiniLM-L6-v2")

# Generate embeddings
embedding = service.generate_embedding("some text content")

# Store in PostgreSQL
conn.execute(
    "UPDATE pattern_library.domain_patterns SET embedding = %s WHERE id = %s",
    (embedding, pattern_id)
)
```

This requires:
- Model loading and caching
- Batch processing logic
- PostgreSQL connection management
- CLI commands for embedding generation
- Manual trigger on data changes

#### With FraiseQL 1.5

FraiseQL 1.5 should provide embedding generation as a service/plugin:

```yaml
# config/fraiseql.yaml
embeddings:
  provider: sentence_transformers
  model: all-MiniLM-L6-v2
  dimensions: 384
  auto_generate: true  # FraiseQL watches inserts/updates

  # Configure which fields to embed
  entities:
    - name: Document
      fields: [title, content]
      combine_strategy: weighted  # title:0.3, content:0.7

    - name: DomainPattern
      fields: [name, description, category]
      combine_strategy: concat
```

FraiseQL automatically:
- Loads the embedding model once (shared across all entities)
- Generates embeddings on INSERT/UPDATE via triggers or hooks
- Handles batching for performance
- Exposes embedding status in GraphQL

```graphql
query {
  documents {
    id
    title
    _embedding {
      status      # "generated", "pending", "failed"
      generatedAt
      model
    }
  }
}

mutation {
  regenerateEmbeddings(entity: "Document", where: { id: 123 })
}
```

#### What to Simplify

**Deprecate (with migration period):**
- `src/infrastructure/services/embedding_service.py` (163 lines)
  - Keep for backward compatibility during transition
  - Add deprecation warnings pointing to FraiseQL 1.5
  - Remove after 2-3 releases

**Simplify:**
- `src/pattern_library/embeddings_pg.py` (229 lines â†’ ~80 lines)
  - **Remove:** Embedding generation logic
  - **Remove:** Model loading/caching
  - **Remove:** PostgreSQL connection management
  - **Keep:** Pattern-specific text extraction (`_pattern_to_text`)
  - **Keep:** Domain logic for combining pattern fields
  - **Delegate:** Embedding generation to FraiseQL API

```python
# Simplified PatternEmbeddingService
class PatternEmbeddingService:
    """Pattern-specific business logic for embeddings (delegates to FraiseQL 1.5)"""

    def __init__(self, fraiseql_client: FraiseQLClient):
        self.client = fraiseql_client  # Use FraiseQL's GraphQL API

    def _pattern_to_text(self, pattern: Dict) -> str:
        """Domain-specific: combine pattern fields into embeddable text"""
        # This logic stays in SpecQL (domain knowledge)
        return f"{pattern['name']} - {pattern['description']} ({pattern['category']})"

    def regenerate_pattern_embeddings(self, pattern_ids: List[int]):
        """Trigger FraiseQL to regenerate embeddings"""
        self.client.mutate("""
            mutation {
              regenerateEmbeddings(
                entity: "DomainPattern"
                where: { id: { in: $patternIds } }
              )
            }
        """, variables={"patternIds": pattern_ids})
```

**Update CLI to proxy:**
```bash
# Old command (deprecated)
specql embeddings generate
# Warning: This command is deprecated. Use 'fraiseql embeddings generate' instead.
# Proxying to FraiseQL...

# New recommended command
fraiseql embeddings generate --entity DomainPattern
```

---

### ðŸŽ¯ **3. Use FraiseQL's Built-in Vector Annotations** (Est. savings: ~50 lines)

#### Current State

SpecQL manually generates COMMENT annotations for vector columns:

```python
def annotate_vector_column(self, entity: EntityDefinition) -> str:
    return f"""
    COMMENT ON COLUMN {entity.schema}.tv_{entity_lower}.embedding IS
    'Vector embedding for semantic similarity search.

    @fraiseql:field
    name: embedding
    type: [Float!]
    description: Vector embedding (384 dimensions) for similarity queries
    operators: cosine_distance, l2_distance, inner_product';
    """
```

This is necessary for FraiseQL to discover and expose vector columns in GraphQL.

#### With FraiseQL 1.5

FraiseQL 1.5 should **auto-discover** vector columns via PostgreSQL introspection:

```sql
-- SpecQL generates the schema
ALTER TABLE crm.tv_document ADD COLUMN embedding vector(384);
CREATE INDEX ON crm.tv_document USING hnsw (embedding vector_cosine_ops);

-- FraiseQL 1.5 auto-detects:
-- 1. Column type is 'vector(384)' (pgvector extension)
-- 2. HNSW index exists â†’ enable optimized queries
-- 3. Automatically expose in GraphQL with vector operators
```

FraiseQL introspection query:
```sql
SELECT
    c.column_name,
    c.data_type,
    c.udt_name,
    format_type(a.atttypid, a.atttypmod) as full_type
FROM information_schema.columns c
JOIN pg_attribute a ON a.attname = c.column_name
WHERE c.table_schema = 'crm'
  AND c.table_name = 'tv_document'
  AND format_type(a.atttypid, a.atttypmod) LIKE 'vector%';

-- Result: embedding | vector(384) | vector | vector(384)
```

**Auto-generated GraphQL schema:**
```graphql
type Document {
  id: ID!
  title: String!
  content: String!
  embedding: [Float!]  # Auto-detected from vector(384)
}

input DocumentWhereInput {
  embedding: VectorFilterInput
}

input VectorFilterInput {
  cosineDistance: VectorDistanceInput
  l2Distance: VectorDistanceInput
  innerProduct: VectorDistanceInput
}

input VectorDistanceInput {
  vector: [Float!]!
  threshold: Float
}
```

#### What to Simplify

**Make `annotate_vector_column()` optional:**
- Only generate annotations for **custom descriptions** or **non-standard configurations**
- Rely on FraiseQL 1.5's auto-discovery for standard cases

```python
def annotate_vector_column(self, entity: EntityDefinition) -> str:
    """Generate FraiseQL annotation ONLY if custom config needed"""

    # Skip if using standard config (384 dims, cosine distance)
    if self._is_standard_vector_config(entity):
        return ""  # Let FraiseQL auto-discover

    # Generate annotation only for custom cases
    return f"""
    COMMENT ON COLUMN {entity.schema}.tv_{entity_lower}.embedding IS
    '@fraiseql:field
    operators: {entity.vector_config.custom_operators}
    distance_metric: {entity.vector_config.distance_metric}';
    """
```

**Benefits:**
- Less boilerplate SQL to generate
- FraiseQL handles standard cases automatically
- SpecQL only adds value for custom configurations

---

### ðŸŽ¯ **4. Simplify Pattern Library Integration** (Est. savings: ~100 lines)

#### Current State

SpecQL pattern library implements its own vector search infrastructure:

```python
class PatternEmbeddingService:
    def __init__(self):
        self.model = SentenceTransformer("all-MiniLM-L6-v2")
        self.conn = psycopg.connect(os.getenv('SPECQL_DB_URL'))
        register_vector(self.conn)

    def retrieve_similar(self, query_embedding, top_k=5):
        """Raw SQL query with pgvector"""
        query = """
            SELECT id, name, category, description,
                   1 - (embedding <=> %s) AS similarity
            FROM pattern_library.domain_patterns
            WHERE embedding IS NOT NULL
              AND (1 - (embedding <=> %s)) >= %s
            ORDER BY embedding <=> %s
            LIMIT %s
        """
        cursor = self.conn.execute(query, [query_embedding] * 4 + [top_k])
        return cursor.fetchall()
```

**Issues:**
- Manual PostgreSQL connection management
- Raw SQL queries (not type-safe)
- Duplicate logic (every service needs similar code)
- No caching or query optimization

#### With FraiseQL 1.5

Define patterns as a FraiseQL entity with `semantic_search` feature:

```yaml
# entities/pattern_library/domain_pattern.yaml
entity: DomainPattern
schema: pattern_library
description: "Reusable domain patterns for SpecQL code generation"

features:
  - semantic_search  # FraiseQL 1.5 handles everything!

fields:
  name: text
  category: text
  description: text
  parameters: json
  implementation: json

  # Vector column auto-managed by FraiseQL 1.5
  # embedding: vector(384)  # No need to declare explicitly
```

Then query via **FraiseQL GraphQL API**:

```python
class PatternEmbeddingService:
    """Simplified service using FraiseQL GraphQL API"""

    def __init__(self, fraiseql_client: FraiseQLClient):
        self.client = fraiseql_client

    def retrieve_similar(
        self,
        query_text: str,  # FraiseQL generates embedding
        top_k: int = 5,
        category_filter: Optional[str] = None
    ) -> List[Dict]:
        """Type-safe GraphQL query instead of raw SQL"""

        query = """
        query FindSimilarPatterns(
            $queryText: String!
            $topK: Int!
            $category: String
        ) {
          domainPatterns(
            where: {
              AND: [
                { embedding: { cosineDistance: { text: $queryText, threshold: 0.5 } } }
                { category: { equals: $category } }
                { deprecated: { equals: false } }
              ]
            }
            orderBy: { embedding: { cosineDistance: $queryText } }
            limit: $topK
          ) {
            id
            name
            category
            description
            parameters
            similarity  # Auto-calculated by FraiseQL
          }
        }
        """

        result = self.client.query(query, variables={
            "queryText": query_text,
            "topK": top_k,
            "category": category_filter
        })

        return result['domainPatterns']
```

**Benefits:**
- âœ… No manual PostgreSQL connection management
- âœ… Type-safe GraphQL queries (IDE autocomplete, validation)
- âœ… FraiseQL handles embedding generation from text
- âœ… Built-in query optimization and caching
- âœ… Consistent API with other FraiseQL entities

#### What to Simplify

**src/pattern_library/embeddings_pg.py:**
- **Remove:** `__init__` PostgreSQL connection setup
- **Remove:** `update_pattern_embedding()` (FraiseQL auto-updates)
- **Remove:** `generate_all_embeddings()` (FraiseQL trigger-based)
- **Remove:** Raw SQL `retrieve_similar()` query
- **Replace:** Use FraiseQL GraphQL client
- **Keep:** `_pattern_to_text()` domain logic

**Before (229 lines):**
```python
class PatternEmbeddingService:
    def __init__(self, connection_string: Optional[str] = None):
        self.model = SentenceTransformer("all-MiniLM-L6-v2")
        self.conn = psycopg.connect(connection_string)
        register_vector(self.conn)

    def embed_pattern(self, pattern: Dict) -> np.ndarray:
        text = self._pattern_to_text(pattern)
        return self.model.encode(text)

    def update_pattern_embedding(self, pattern_id: int, embedding: np.ndarray):
        self.conn.execute("""UPDATE ... SET embedding = %s""", (embedding,))

    def generate_all_embeddings(self):
        # 50+ lines of batch processing logic

    def retrieve_similar(self, query_embedding, top_k=5):
        # 30+ lines of raw SQL queries
```

**After (~80 lines):**
```python
class PatternEmbeddingService:
    def __init__(self, fraiseql_client: FraiseQLClient):
        self.client = fraiseql_client

    def _pattern_to_text(self, pattern: Dict) -> str:
        """Domain-specific text extraction (SpecQL knowledge)"""
        return f"{pattern['name']} - {pattern['description']} ({pattern['category']})"

    def retrieve_similar(self, query_text: str, top_k: int = 5):
        """Type-safe GraphQL query"""
        # 20 lines of GraphQL query
```

---

## Code Reduction Estimate

### Detailed Breakdown

| Component | Current Lines | After FraiseQL 1.5 | Savings | Strategy |
|-----------|--------------|-------------------|---------|----------|
| **vector_generator.py** | 91 | ~40 | **-51** | Remove search function generation, keep schema setup |
| **embedding_service.py** | 163 | 0 | **-163** | Deprecate entirely, add migration guide |
| **embeddings_pg.py** | 229 | ~80 | **-149** | Keep domain logic, use FraiseQL GraphQL API |
| **embeddings CLI** | 60 | ~20 | **-40** | Proxy commands to FraiseQL, deprecation warnings |
| **FraiseQL annotations** | ~50 | ~20 | **-30** | Auto-discovery reduces manual annotations |
| **Templates** | ~50 | ~20 | **-30** | Remove custom function templates |
| **Tests** | ~100 | ~50 | **-50** | Simplify tests to use FraiseQL API |
| **TOTAL** | **~743** | **~230** | **-513 (69%)** | Phased migration with backward compat |

### What Gets Simplified

#### High-Value Simplifications (Remove Entirely)
1. âœ… **Custom search function generation** (-150 lines)
   - No more per-entity SQL functions
   - FraiseQL GraphQL operators replace them

2. âœ… **Embedding model loading** (-163 lines)
   - FraiseQL manages sentence-transformers
   - Shared model across all entities

3. âœ… **PostgreSQL connection management** (-50 lines)
   - FraiseQL handles database connections
   - Use GraphQL client instead

#### Medium-Value Simplifications (Reduce Complexity)
4. âœ… **Pattern library vector search** (-100 lines)
   - Raw SQL â†’ Type-safe GraphQL queries
   - Manual batching â†’ FraiseQL optimization

5. âœ… **Vector column annotations** (-30 lines)
   - Auto-discovery for standard configs
   - Annotations only for custom cases

#### Low-Touch (Keep for Backward Compat)
6. âœ… **Schema generation** (keep)
   - Still need to generate vector columns
   - Still need to create HNSW indexes
   - FraiseQL discovers, SpecQL creates

---

## Migration Strategy

### Phase 1: FraiseQL 1.5 Integration (Week 1)

**Goal:** Validate FraiseQL 1.5 capabilities and test integration

**Tasks:**
1. âœ… **Configure FraiseQL 1.5 with embedding support**
   ```yaml
   # config/fraiseql.yaml
   embeddings:
     provider: sentence_transformers
     model: all-MiniLM-L6-v2
     dimensions: 384
     auto_generate: true
   ```

2. âœ… **Test auto-discovery of existing vector columns**
   - Run FraiseQL introspection on existing `tv_*` tables with vector columns
   - Verify GraphQL schema includes vector operators
   - Test query: `{ documents(where: { embedding: { cosineDistance: {...} } }) }`

3. âœ… **Verify GraphQL vector operator queries work**
   ```graphql
   query TestVectorQuery {
     domainPatterns(
       where: {
         embedding: {
           cosineDistance: {
             text: "audit logging pattern",
             threshold: 0.6
           }
         }
       }
       limit: 5
     ) {
       name
       category
       similarity
     }
   }
   ```

4. âœ… **Benchmark performance vs custom functions**
   - Compare FraiseQL vector operators vs SpecQL's custom SQL functions
   - Measure query latency (p50, p95, p99)
   - Verify HNSW index usage in both approaches
   - Target: FraiseQL performance >= custom functions

**Success Criteria:**
- [ ] FraiseQL auto-discovers all vector columns
- [ ] GraphQL vector queries return correct results
- [ ] Performance is comparable or better than custom functions
- [ ] No breaking changes to existing SpecQL workflows

---

### Phase 2: Deprecation Warnings (Week 2)

**Goal:** Prepare users for migration, maintain backward compatibility

**Tasks:**

1. âœ… **Mark custom search functions as `@deprecated`**
   ```python
   def annotate_custom_search_function(self, entity: EntityDefinition) -> str:
       return f"""
       COMMENT ON FUNCTION {entity.schema}.search_{entity_lower}_by_embedding IS
       '[DEPRECATED] This custom function will be removed in SpecQL v2.0.

       Use FraiseQL vector operators instead:

       GraphQL query:
         {{
           {entity.name.lower()}s(
             where: {{ embedding: {{ cosineDistance: {{ text: "...", threshold: 0.7 }} }} }}
           ) {{ id, title }}
         }}

       Migration guide: docs/migration/fraiseql-1.5-vector-search.md

       @fraiseql:query
       name: search{entity.name}ByEmbedding
       type: [{entity.name}!]!
       deprecated: "Use native vector operators - see migration guide"';
       """
   ```

2. âœ… **Update documentation to recommend FraiseQL vector operators**
   - Add migration guide: `docs/migration/fraiseql-1.5-vector-search.md`
   - Update examples to show FraiseQL GraphQL queries
   - Add comparison table (old SQL vs new GraphQL)
   - Create video tutorial for migration

3. âœ… **Add deprecation warnings to `embedding_service.py`**
   ```python
   class EmbeddingService:
       def __init__(self, model_name: str = "all-MiniLM-L6-v2"):
           warnings.warn(
               "EmbeddingService is deprecated and will be removed in SpecQL v2.0. "
               "Use FraiseQL 1.5 embedding service instead. "
               "See: docs/migration/fraiseql-1.5-vector-search.md",
               DeprecationWarning,
               stacklevel=2
           )
           self.model = SentenceTransformer(model_name)
   ```

4. âœ… **Create proxy CLI commands that delegate to FraiseQL**
   ```python
   @embeddings_cli.command(name="generate")
   def generate_embeddings():
       """[DEPRECATED] Generate embeddings (proxies to FraiseQL)"""
       console.print("[yellow]âš  This command is deprecated.[/yellow]")
       console.print("[yellow]Use 'fraiseql embeddings generate' instead.[/yellow]")
       console.print("[cyan]Proxying to FraiseQL...[/cyan]")

       # Delegate to FraiseQL CLI
       result = subprocess.run([
           "fraiseql", "embeddings", "generate",
           "--entity", "DomainPattern"
       ])

       if result.returncode == 0:
           console.print("[green]âœ“ Embeddings generated via FraiseQL[/green]")
   ```

**Success Criteria:**
- [ ] All deprecation warnings are clear and actionable
- [ ] Migration guide is comprehensive with examples
- [ ] Proxy commands work seamlessly
- [ ] No breaking changes for existing users

---

### Phase 3: Migration to FraiseQL (Week 3-4)

**Goal:** Migrate internal SpecQL usage to FraiseQL 1.5

**Tasks:**

1. âœ… **Migrate pattern library to use FraiseQL GraphQL API**

   **Before:** Direct PostgreSQL + pgvector
   ```python
   # src/pattern_library/embeddings_pg.py (OLD)
   class PatternEmbeddingService:
       def retrieve_similar(self, query_embedding, top_k=5):
           cursor = self.conn.execute("""
               SELECT *, 1 - (embedding <=> %s) AS similarity
               FROM pattern_library.domain_patterns
               WHERE embedding IS NOT NULL
               ORDER BY embedding <=> %s
               LIMIT %s
           """, (query_embedding, query_embedding, top_k))
           return cursor.fetchall()
   ```

   **After:** FraiseQL GraphQL API
   ```python
   # src/pattern_library/fraiseql_patterns.py (NEW)
   class FraiseQLPatternService:
       def __init__(self, fraiseql_client: FraiseQLClient):
           self.client = fraiseql_client

       def retrieve_similar(self, query_text: str, top_k: int = 5):
           return self.client.query("""
               query FindSimilarPatterns($query: String!, $topK: Int!) {
                 domainPatterns(
                   where: { embedding: { cosineDistance: { text: $query } } }
                   limit: $topK
                 ) {
                   id name category description similarity
                 }
               }
           """, {"query": query_text, "topK": top_k})
   ```

2. âœ… **Remove custom search function generation**

   Make it **opt-in** for backward compatibility:
   ```yaml
   # entities/document.yaml
   entity: Document
   features:
     - semantic_search

   # NEW: Opt-in for legacy custom functions
   vector_config:
     generate_custom_functions: false  # Default: false (use FraiseQL)
     # Set to true only if you need direct SQL access
   ```

   ```python
   # src/generators/schema/vector_generator.py
   def generate(self, entity: EntityDefinition) -> str:
       parts = [
           self._generate_columns(entity),
           self._generate_indexes(entity),
       ]

       # Only generate custom functions if explicitly requested
       if entity.vector_config.get('generate_custom_functions', False):
           warnings.warn(
               f"Custom vector search functions for {entity.name} are deprecated. "
               f"Use FraiseQL vector operators instead.",
               DeprecationWarning
           )
           parts.append(self._generate_search_function(entity))

       return "\n\n".join(filter(None, parts))
   ```

3. âœ… **Simplify VectorGenerator to only handle schema setup**

   **New responsibilities (40 lines):**
   ```python
   class VectorGenerator:
       """Generates vector schema (columns + indexes) for FraiseQL discovery"""

       def generate(self, entity: EntityDefinition) -> str:
           """Generate ONLY schema setup - FraiseQL handles queries"""
           if "semantic_search" not in (entity.features or []):
               return ""

           return "\n\n".join([
               self._generate_columns(entity),   # ALTER TABLE ADD COLUMN
               self._generate_indexes(entity),   # CREATE INDEX USING hnsw
               # NO custom functions - FraiseQL provides GraphQL operators
           ])
   ```

4. âœ… **Update tests to use FraiseQL endpoints**

   **Before:** Test custom SQL functions
   ```python
   def test_vector_search_function():
       result = db.execute("""
           SELECT * FROM search_document_by_embedding('[0.1, 0.2, ...]'::vector, 10, 0.7)
       """)
       assert len(result) == 5
   ```

   **After:** Test FraiseQL GraphQL API
   ```python
   def test_fraiseql_vector_search():
       result = fraiseql_client.query("""
           query {
             documents(
               where: { embedding: { cosineDistance: { text: "test query" } } }
               limit: 10
             ) { id title similarity }
           }
       """)
       assert len(result['documents']) > 0
       assert result['documents'][0]['similarity'] > 0.7
   ```

**Success Criteria:**
- [ ] Pattern library successfully migrated to FraiseQL API
- [ ] Custom search function generation is opt-in only
- [ ] VectorGenerator reduced to ~40 lines (schema setup only)
- [ ] All tests pass with FraiseQL endpoints

---

### Phase 4: Cleanup (Week 5)

**Goal:** Remove deprecated code after grace period

**Tasks:**

1. âœ… **Remove `embedding_service.py`** (after 1-2 release grace period)

   **Timeline:**
   - **v1.6**: Add deprecation warnings (Phase 2)
   - **v1.7**: Mark as deprecated, document migration path
   - **v1.8**: Final warning ("will be removed in v2.0")
   - **v2.0**: Remove file entirely

   ```bash
   # Add to CHANGELOG.md
   ## [2.0.0] - BREAKING CHANGES

   ### Removed
   - `src/infrastructure/services/embedding_service.py` - Use FraiseQL 1.5 embedding service
   - `src/cli/embeddings.py` commands - Use `fraiseql embeddings` commands
   - Custom vector search SQL functions - Use FraiseQL GraphQL vector operators
   ```

2. âœ… **Archive old CLI commands**
   ```bash
   git mv src/cli/embeddings.py archive/deprecated/embeddings_cli_v1.py

   # Add tombstone file
   cat > src/cli/embeddings.py << 'EOF'
   """
   REMOVED: Embedding CLI commands moved to FraiseQL 1.5

   Migration:
     specql embeddings generate  â†’  fraiseql embeddings generate
     specql embeddings test-retrieval  â†’  fraiseql embeddings search

   See: docs/migration/fraiseql-1.5-vector-search.md
   """
   raise ImportError(
       "Embedding CLI commands have been removed. "
       "Use FraiseQL 1.5 CLI instead: https://docs.fraiseql.com/cli/embeddings"
   )
   EOF
   ```

3. âœ… **Update all examples and documentation**

   **Files to update:**
   - `docs/guides/semantic_search.md` - Replace SQL examples with GraphQL
   - `examples/*/README.md` - Update vector search examples
   - `docs/reference/features.md` - Update `semantic_search` feature docs
   - `docs/api/graphql.md` - Add FraiseQL vector operator reference

   **Example update:**
   ```diff
   # docs/guides/semantic_search.md

   - ## Using Vector Search
   + ## Using Vector Search (FraiseQL 1.5)

   - ```sql
   - SELECT * FROM search_document_by_embedding('[...]'::vector, 10, 0.7);
   - ```
   + ```graphql
   + query {
   +   documents(
   +     where: { embedding: { cosineDistance: { text: "query", threshold: 0.7 } } }
   +     limit: 10
   +   ) { id title similarity }
   + }
   + ```
   ```

4. âœ… **Create final migration summary**
   ```markdown
   # docs/migration/fraiseql-1.5-complete.md

   # FraiseQL 1.5 Migration Complete

   ## What Changed

   ### Removed
   - Custom SQL search functions (use GraphQL vector operators)
   - `EmbeddingService` class (FraiseQL manages embeddings)
   - `specql embeddings` CLI commands (use `fraiseql embeddings`)

   ### Simplified
   - `VectorGenerator`: 91 â†’ 40 lines (schema setup only)
   - `PatternEmbeddingService`: 229 â†’ 80 lines (GraphQL API)
   - Total reduction: ~513 lines (69%)

   ## Migration Checklist

   - [ ] Replace SQL vector search with GraphQL queries
   - [ ] Update entity YAML: set `generate_custom_functions: false`
   - [ ] Use FraiseQL CLI for embedding management
   - [ ] Update tests to use FraiseQL GraphQL API
   - [ ] Remove direct `EmbeddingService` usage

   ## Benefits

   - âœ… Less code to maintain
   - âœ… Type-safe GraphQL queries
   - âœ… Better performance (FraiseQL optimization)
   - âœ… Automatic embedding generation
   - âœ… Consistent API across all entities
   ```

**Success Criteria:**
- [ ] All deprecated code removed from main branch
- [ ] Documentation fully updated with FraiseQL examples
- [ ] Migration guide comprehensive and tested
- [ ] No user reports of broken migrations

---

### Phase 5: Optimization (Ongoing)

**Goal:** Leverage FraiseQL 1.5 advanced features

**Future Enhancements:**

1. âœ… **Multi-vector search** (if FraiseQL supports)
   ```yaml
   entity: Product
   features:
     - semantic_search

   vector_config:
     vectors:
       - name: description_embedding
         fields: [description]
         dimensions: 384

       - name: image_embedding  # Multi-modal!
         fields: [image_url]
         dimensions: 512
         model: clip-vit-base
   ```

2. âœ… **Hybrid search** (vector + full-text)
   ```graphql
   query HybridSearch($query: String!) {
     documents(
       where: {
         OR: [
           { embedding: { cosineDistance: { text: $query, threshold: 0.6 } } }
           { searchVector: { matches: $query } }
         ]
       }
       orderBy: { _relevance: DESC }  # FraiseQL combines scores
     ) { id title score }
   }
   ```

3. âœ… **Embedding model versioning**
   ```yaml
   embeddings:
     versioning: true  # Track model versions

   # FraiseQL stores model metadata
   query {
     documents {
       _embedding {
         model         # "all-MiniLM-L6-v2"
         version       # "v2.0"
         generatedAt   # "2025-11-14T10:00:00Z"
       }
     }
   }
   ```

---

## What to Keep

### âœ… Essential SpecQL Responsibilities

**1. Schema Generation** (Keep in `VectorGenerator`)

```python
def _generate_columns(self, entity: EntityDefinition) -> str:
    """SpecQL generates vector columns - FraiseQL discovers them"""
    return f"ALTER TABLE {entity.schema}.tv_{entity.name.lower()} ADD COLUMN embedding vector(384);"

def _generate_indexes(self, entity: EntityDefinition) -> str:
    """SpecQL creates HNSW indexes - critical for performance"""
    return f"""
    CREATE INDEX idx_tv_{entity.name.lower()}_embedding_hnsw
    ON {entity.schema}.tv_{entity.name.lower()}
    USING hnsw (embedding vector_cosine_ops)
    WITH (m = 16, ef_construction = 64);
    """
```

**Why keep:**
- SpecQL owns the complete schema generation pipeline
- FraiseQL discovers existing schema, doesn't create it
- HNSW indexes are critical for performance

---

**2. Type Mapping** (Keep in `FraiseQLAnnotator`)

```python
def _map_to_fraiseql_type(self, field_def: FieldDefinition) -> str:
    """Map SpecQL types to FraiseQL GraphQL types"""
    type_map = {
        "text": "String",
        "integer": "Int",
        "decimal": "Float",
        "boolean": "Boolean",
        "date": "Date",
        "timestamp": "DateTime",
        "json": "JSON",
        "email": "Email",      # Custom scalar
        "phone": "Phone",      # Custom scalar
        "vector": "[Float!]",  # Vector type
    }
    base_type = type_map.get(field_def.type_name, "String")
    return f"{base_type}!" if not field_def.nullable else base_type
```

**Why keep:**
- SpecQL has rich semantic types (email, phone, currency, etc.)
- Need to map SpecQL types â†’ FraiseQL GraphQL types
- Custom scalar type support

---

**3. Pattern-Specific Domain Logic** (Keep in `PatternEmbeddingService`)

```python
def _pattern_to_text(self, pattern: Dict) -> str:
    """
    SpecQL-specific: Convert pattern structure to embeddable text

    Combines pattern metadata in domain-specific way:
    - Pattern name (weight: 0.3)
    - Description (weight: 0.5)
    - Category (weight: 0.2)
    - Parameter names
    """
    parts = [
        f"{pattern['name']}",           # e.g., "Audit Log Pattern"
        f"{pattern['description']}",    # e.g., "Track all entity changes..."
        f"Category: {pattern['category']}", # e.g., "compliance"
        f"Parameters: {', '.join(pattern['parameters'].keys())}"
    ]
    return " | ".join(parts)
```

**Why keep:**
- Domain knowledge specific to SpecQL patterns
- FraiseQL doesn't know how to combine pattern fields
- Business logic for text extraction

---

**4. Backward Compatibility Layer** (Temporary)

```python
# Keep for 2-3 releases, then remove
class EmbeddingService:
    """DEPRECATED: Use FraiseQL 1.5 embedding service instead"""

    def __init__(self, model_name: str = "all-MiniLM-L6-v2"):
        warnings.warn(
            "EmbeddingService is deprecated. Use FraiseQL 1.5 instead. "
            "Will be removed in v2.0.",
            DeprecationWarning
        )
        self.model = SentenceTransformer(model_name)

    # Keep existing methods for backward compat
```

**Why keep (temporarily):**
- Gradual migration path for users
- No breaking changes in minor releases
- Clear deprecation timeline

---

**5. Custom Vector Configuration** (Optional annotations)

```python
def annotate_vector_column(self, entity: EntityDefinition) -> str:
    """Generate annotation ONLY for non-standard configs"""

    # Skip standard configs (let FraiseQL auto-discover)
    if entity.vector_config.is_standard():
        return ""

    # Annotate custom configurations
    return f"""
    COMMENT ON COLUMN {entity.schema}.tv_{entity_lower}.embedding IS
    '@fraiseql:field
    dimensions: {entity.vector_config.dimensions}
    distance_metric: {entity.vector_config.distance_metric}
    operators: {', '.join(entity.vector_config.custom_operators)}';
    """
```

**Why keep:**
- Support for non-standard vector configurations
- Custom distance metrics (Euclidean, Manhattan, etc.)
- Multi-vector scenarios (e.g., separate embeddings for title/content)

---

### âŒ What to Remove

1. âŒ **Custom search function generation** (replaced by FraiseQL GraphQL operators)
2. âŒ **Embedding model loading** (FraiseQL manages models)
3. âŒ **PostgreSQL connection management** (use FraiseQL GraphQL client)
4. âŒ **Manual embedding generation** (FraiseQL auto-generates on INSERT/UPDATE)
5. âŒ **CLI embedding commands** (use `fraiseql embeddings` instead)
6. âŒ **Raw SQL vector queries** (use type-safe GraphQL)

---

## Next Steps

### Immediate Actions (This Week)

1. **Verify FraiseQL 1.5 Capabilities**
   - [ ] Confirm FraiseQL 1.5 supports auto-discovery of pgvector columns
   - [ ] Confirm GraphQL vector operators (cosine_distance, l2_distance, etc.)
   - [ ] Confirm embedding generation service/plugin exists
   - [ ] Confirm trigger-based auto-embedding on INSERT/UPDATE

2. **Prototype Integration**
   - [ ] Set up FraiseQL 1.5 test environment
   - [ ] Configure embedding provider in `fraiseql.yaml`
   - [ ] Test auto-discovery with existing SpecQL schema
   - [ ] Benchmark performance vs custom functions

3. **Create Migration Plan**
   - [ ] Review this document with team
   - [ ] Prioritize phases based on user impact
   - [ ] Create detailed implementation tickets
   - [ ] Set timeline for deprecation

### Short-Term (Next Month)

4. **Phase 1: Integration**
   - [ ] Complete FraiseQL 1.5 integration testing
   - [ ] Document integration patterns
   - [ ] Create example projects

5. **Phase 2: Deprecation**
   - [ ] Add deprecation warnings to code
   - [ ] Write migration guide
   - [ ] Update documentation
   - [ ] Create video tutorials

### Medium-Term (Next Quarter)

6. **Phase 3: Migration**
   - [ ] Migrate pattern library to FraiseQL API
   - [ ] Make custom functions opt-in only
   - [ ] Simplify VectorGenerator
   - [ ] Update all tests

7. **Phase 4: Cleanup**
   - [ ] Remove deprecated code (after grace period)
   - [ ] Archive old CLI commands
   - [ ] Final documentation update

### Long-Term (Next 6 Months)

8. **Phase 5: Optimization**
   - [ ] Explore multi-vector search
   - [ ] Implement hybrid search (vector + full-text)
   - [ ] Leverage embedding model versioning
   - [ ] Advanced FraiseQL features

---

## Success Metrics

### Quantitative

- **Code Reduction**: Target 70% reduction (543 â†’ 160 lines)
- **Test Coverage**: Maintain >95% coverage throughout migration
- **Performance**: FraiseQL queries â‰¥ custom function performance
- **Migration Rate**: 80% of users migrated within 2 releases

### Qualitative

- **Developer Experience**: Simplified API (GraphQL vs SQL)
- **Type Safety**: IDE autocomplete for vector queries
- **Maintainability**: Less code to debug and update
- **Standardization**: Consistent API across all entities

---

## Risks and Mitigations

### Risk 1: FraiseQL 1.5 Not Feature-Complete

**Risk:** FraiseQL 1.5 doesn't support all assumed features (auto-discovery, embedding service, etc.)

**Mitigation:**
- Verify all capabilities before starting migration
- Create fallback plan: keep SpecQL implementation if FraiseQL gaps exist
- Contribute to FraiseQL if features are missing

### Risk 2: Performance Regression

**Risk:** FraiseQL vector queries slower than custom SQL functions

**Mitigation:**
- Benchmark thoroughly in Phase 1
- Work with FraiseQL team to optimize if needed
- Keep custom functions as opt-in fallback

### Risk 3: Breaking Changes for Users

**Risk:** Users depend on custom search functions, removing them breaks workflows

**Mitigation:**
- Phased deprecation (3+ releases with warnings)
- Comprehensive migration guide
- Make custom functions opt-in during transition
- Provide automated migration tools

### Risk 4: FraiseQL API Changes

**Risk:** FraiseQL 1.5 API changes during our migration

**Mitigation:**
- Pin FraiseQL version: `fraiseql>=1.5.0,<2.0.0`
- Monitor FraiseQL release notes
- Maintain adapter layer to isolate FraiseQL API changes

---

## Appendix

### A. Example Migration

**Before (SpecQL custom functions):**

```yaml
# entities/document.yaml
entity: Document
schema: content
features:
  - semantic_search
```

```sql
-- Generated by SpecQL
ALTER TABLE content.tv_document ADD COLUMN embedding vector(384);
CREATE INDEX ... USING hnsw (embedding vector_cosine_ops);

CREATE FUNCTION search_document_by_embedding(...)
RETURNS TABLE(...) AS $$ ... $$;
```

```python
# Application code
from src.infrastructure.services.embedding_service import EmbeddingService

service = EmbeddingService()
query_embedding = service.generate_embedding("search query")

results = db.execute("""
    SELECT * FROM search_document_by_embedding(%s::vector, 10, 0.7)
""", (query_embedding,))
```

**After (FraiseQL 1.5):**

```yaml
# entities/document.yaml (unchanged!)
entity: Document
schema: content
features:
  - semantic_search

# Optional: disable custom functions
vector_config:
  generate_custom_functions: false  # Default in v2.0
```

```sql
-- Generated by SpecQL (simpler!)
ALTER TABLE content.tv_document ADD COLUMN embedding vector(384);
CREATE INDEX ... USING hnsw (embedding vector_cosine_ops);

-- No custom search function needed!
-- FraiseQL auto-discovers and provides GraphQL operators
```

```python
# Application code (type-safe GraphQL!)
from fraiseql import FraiseQLClient

client = FraiseQLClient("http://localhost:4000/graphql")

results = client.query("""
    query FindSimilarDocuments($query: String!) {
      documents(
        where: {
          embedding: {
            cosineDistance: { text: $query, threshold: 0.7 }
          }
        }
        limit: 10
      ) {
        id
        title
        content
        similarity
      }
    }
""", {"query": "search query"})
```

### B. FraiseQL Configuration Reference

```yaml
# config/fraiseql.yaml

server:
  host: "0.0.0.0"
  port: 4000
  debug: true

database:
  url: ${DATABASE_URL}
  schema: specql_registry

graphql:
  playground: true
  introspection: true
  depth_limit: 10
  complexity_limit: 1000

# NEW: Embedding configuration
embeddings:
  # Provider: sentence_transformers, openai, cohere, etc.
  provider: sentence_transformers

  # Model configuration
  model: all-MiniLM-L6-v2
  dimensions: 384

  # Auto-generate embeddings on INSERT/UPDATE
  auto_generate: true

  # Batch configuration
  batch_size: 32
  batch_timeout_ms: 100

  # Per-entity configuration
  entities:
    - name: Document
      fields: [title, content]
      combine_strategy: weighted
      weights:
        title: 0.3
        content: 0.7

    - name: DomainPattern
      fields: [name, description, category]
      combine_strategy: concat
      separator: " | "

# Schema auto-discovery
schema:
  auto_discover: true

  # NEW: Vector column discovery
  vector_discovery:
    enabled: true
    auto_create_operators: true  # Expose GraphQL operators
    supported_metrics:
      - cosine_distance
      - l2_distance
      - inner_product
```

### C. GraphQL Vector Operator Reference

```graphql
# FraiseQL 1.5 Auto-Generated Types

type Document {
  id: ID!
  title: String!
  content: String!
  embedding: [Float!]  # Auto-discovered from vector(384)

  # Virtual field (only in query results)
  similarity: Float  # Calculated during vector search
}

input DocumentWhereInput {
  # Standard filters
  title: StringFilterInput
  content: StringFilterInput

  # Vector filters (auto-generated)
  embedding: VectorFilterInput

  # Combine filters
  AND: [DocumentWhereInput!]
  OR: [DocumentWhereInput!]
  NOT: DocumentWhereInput
}

input VectorFilterInput {
  # Distance operators
  cosineDistance: VectorDistanceInput
  l2Distance: VectorDistanceInput
  innerProduct: VectorDistanceInput
}

input VectorDistanceInput {
  # Option 1: Provide text (FraiseQL generates embedding)
  text: String

  # Option 2: Provide pre-computed vector
  vector: [Float!]

  # Threshold filter
  threshold: Float
}

# Example queries:

query SearchByText {
  documents(
    where: {
      embedding: {
        cosineDistance: { text: "machine learning tutorial", threshold: 0.6 }
      }
    }
    limit: 10
  ) {
    id
    title
    similarity  # Auto-calculated
  }
}

query SearchByVector {
  documents(
    where: {
      embedding: {
        cosineDistance: { vector: [0.1, 0.2, ...], threshold: 0.7 }
      }
    }
  ) {
    id
    title
    similarity
  }
}

query HybridSearch {
  documents(
    where: {
      OR: [
        { embedding: { cosineDistance: { text: "AI", threshold: 0.6 } } }
        { searchVector: { matches: "artificial intelligence" } }
      ]
    }
  ) {
    id
    title
    _relevance  # Combined score
  }
}
```

---

## Conclusion

FraiseQL 1.5's embedding and vector search capabilities present a significant opportunity to **simplify SpecQL's implementation by ~70%** while **improving functionality and developer experience**.

**Key Takeaways:**

1. **Reduce Maintenance**: Remove 513 lines of vector/embedding infrastructure
2. **Improve DX**: Type-safe GraphQL queries vs raw SQL
3. **Standardize**: Single API (FraiseQL) for all vector operations
4. **Future-Proof**: Leverage FraiseQL updates automatically

**Recommended Next Step:** Verify FraiseQL 1.5 capabilities match this plan's assumptions, then proceed with Phase 1 integration testing.

---

**Document Version**: 1.0
**Last Updated**: 2025-11-14
**Owner**: SpecQL Core Team
**Status**: Awaiting FraiseQL 1.5 capability verification
