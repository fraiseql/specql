# tv_ Table FraiseQL Annotations

## Overview

Team D implements automatic FraiseQL annotation generation for `tv_` (table view) tables. These annotations enable FraiseQL v1.3.4+ to automatically introspect CQRS read-optimized tables and generate GraphQL types from their structure.

## Purpose

The `tv_` tables are denormalized, read-optimized views that combine entity data with related entities in JSONB format. FraiseQL annotations tell the GraphQL engine:

1. **Table Metadata**: How to treat the table (materialized view, refresh strategy)
2. **Internal Columns**: Which columns should NOT be exposed in GraphQL (pk_*, fk_*, refreshed_at)
3. **Filter Columns**: Which columns are optimized for WHERE clauses
4. **Data Structure**: How to extract GraphQL types from JSONB data

## Generated Annotations

### Table-Level Annotations

```sql
COMMENT ON TABLE library.tv_review IS
  '@fraiseql:table source=materialized,refresh=explicit,primary=true,description=Read-optimized Review with denormalized relations';
```

**Parameters:**
- `source=materialized`: This is a materialized view, not a regular table
- `refresh=explicit`: Refreshed via explicit function calls (not automatic)
- `primary=true`: This is the primary GraphQL type (not the tb_* table)
- `description`: Human-readable description

### Internal Column Annotations

Internal columns are marked with `internal=true` to prevent GraphQL exposure:

```sql
-- Primary key (not exposed in GraphQL)
COMMENT ON COLUMN library.tv_review.pk_review IS
  '@fraiseql:field internal=true,description=Internal primary key';

-- Foreign keys (for JOINs only)
COMMENT ON COLUMN library.tv_review.fk_user IS
  '@fraiseql:field internal=true,description=Internal FK for User';

-- Refresh timestamp
COMMENT ON COLUMN library.tv_review.refreshed_at IS
  '@fraiseql:field internal=true,description=Last refresh timestamp';
```

### Filter Column Annotations

Filter columns are annotated for efficient WHERE clause generation:

```sql
-- Tenant isolation
COMMENT ON COLUMN library.tv_review.tenant_id IS
  '@fraiseql:filter type=UUID,index=btree,performance=optimized,description=Multi-tenant filter';

-- Foreign key filters
COMMENT ON COLUMN library.tv_review.user_id IS
  '@fraiseql:filter type=UUID,relation=User,index=btree,performance=optimized,description=Filter by User';

-- Extra filters (promoted scalars)
COMMENT ON COLUMN library.tv_review.rating IS
  '@fraiseql:filter type=Int,index=btree,performance=optimized,description=Filter by rating';
```

### JSONB Data Column Annotation

The `data` column contains denormalized entity data:

```sql
COMMENT ON COLUMN library.tv_review.data IS
  '@fraiseql:jsonb expand=true,description=Denormalized Review data with nested relations';
```

**Parameters:**
- `expand=true`: Introspect JSONB structure and extract GraphQL types
- `description`: Human-readable description

## Integration with Schema Orchestrator

Annotations are automatically generated by the `SchemaOrchestrator.generate_table_views()` method:

```python
from src.generators.schema_orchestrator import SchemaOrchestrator

orchestrator = SchemaOrchestrator()
sql = orchestrator.generate_table_views([entity])

# Returns: CREATE TABLE + indexes + refresh function + FraiseQL annotations
```

## Example: Complete tv_review Table

```sql
-- Table View: library.tv_review
CREATE TABLE library.tv_review (
    pk_review INTEGER PRIMARY KEY,
    id UUID NOT NULL UNIQUE,
    tenant_id UUID NOT NULL,
    fk_user INTEGER,
    fk_book INTEGER,
    user_id UUID,
    book_id UUID,
    rating INTEGER,
    created_at TIMESTAMPTZ,
    data JSONB NOT NULL,
    refreshed_at TIMESTAMPTZ DEFAULT now()
);

-- Indexes...
-- Refresh function...

-- FraiseQL Annotations: library.tv_review
COMMENT ON TABLE library.tv_review IS
  '@fraiseql:table source=materialized,refresh=explicit,primary=true,description=Read-optimized Review with denormalized relations';

COMMENT ON COLUMN library.tv_review.pk_review IS
  '@fraiseql:field internal=true,description=Internal primary key';

COMMENT ON COLUMN library.tv_review.fk_user IS
  '@fraiseql:field internal=true,description=Internal FK for User';

COMMENT ON COLUMN library.tv_review.fk_book IS
  '@fraiseql:field internal=true,description=Internal FK for Book';

COMMENT ON COLUMN library.tv_review.refreshed_at IS
  '@fraiseql:field internal=true,description=Last refresh timestamp';

COMMENT ON COLUMN library.tv_review.tenant_id IS
  '@fraiseql:filter type=UUID,index=btree,performance=optimized,description=Multi-tenant filter';

COMMENT ON COLUMN library.tv_review.user_id IS
  '@fraiseql:filter type=UUID,relation=User,index=btree,performance=optimized,description=Filter by User';

COMMENT ON COLUMN library.tv_review.book_id IS
  '@fraiseql:filter type=UUID,relation=Book,index=btree,performance=optimized,description=Filter by Book';

COMMENT ON COLUMN library.tv_review.rating IS
  '@fraiseql:filter type=Int,index=btree,performance=optimized,description=Filter by rating';

COMMENT ON COLUMN library.tv_review.created_at IS
  '@fraiseql:filter type=DateTime,index=btree,performance=optimized,description=Filter by created_at';

COMMENT ON COLUMN library.tv_review.data IS
  '@fraiseql:jsonb expand=true,description=Denormalized Review data with nested relations';
```

## GraphQL Type Generation

With these annotations, FraiseQL automatically generates:

```graphql
type Review {
  id: UUID!
  tenantId: UUID!
  userId: UUID!
  bookId: UUID!
  rating: Int
  createdAt: DateTime
  data: ReviewData!
}

type ReviewData {
  content: String
  User: UserData
  Book: BookData
}

type UserData {
  name: String
  email: String
  avatarUrl: String
}

type BookData {
  title: String
  isbn: String
  publishedYear: Int
  genre: String
}
```

## Testing

Comprehensive test coverage includes:

- **Unit Tests**: `tests/unit/fraiseql/test_table_view_annotator.py`
- **E2E Tests**: `tests/integration/fraiseql/test_tv_annotations_e2e.py`
- **Test Fixture**: `entities/examples/review_with_table_views.yaml`

Run tests:
```bash
uv run pytest tests/unit/fraiseql/test_table_view_annotator.py -v
uv run pytest tests/integration/fraiseql/test_tv_annotations_e2e.py -v
```

## Benefits

1. **Zero Configuration**: FraiseQL works out-of-the-box with SpecQL entities
2. **Type Safety**: Automatic GraphQL type generation from JSONB structure
3. **Performance**: Optimized filter columns with proper indexing hints
4. **Security**: Internal columns automatically hidden from GraphQL API
5. **Maintainability**: Annotations generated from entity definitions, not manual