# Translation Table Generator Implementation Plan

**Feature**: Automatic i18n Translation Table Generation
**Status**: Planning
**Effort**: 8-12 hours
**Priority**: HIGH - Unblocks 20+ PrintOptim catalog entities
**Methodology**: Phased TDD Approach

---

## ðŸ“‹ Executive Summary

Implement automatic generation of `tl_*` translation tables from SpecQL entity definitions with `translations` configuration. This enables multilingual support for catalog entities (manufacturers, countries, product categories, etc.) by auto-generating normalized translation tables with locale-specific content **using a Hybrid Trinity Pattern** (INTEGER PK + UUID, no identifier field).

### Current State
- âœ… AST support exists (`TranslationConfig` in `core/ast_models.py:304-310`)
- âœ… YAML syntax works (see `stdlib/org/organizational_unit.yaml:70-73`)
- âŒ No generator implementation

### Target State
```yaml
# Input: entities/catalog/manufacturer.yaml
entity: Manufacturer
schema: catalog
translations:
  enabled: true
  fields: [name, description]

# Auto-generates:
# 1. catalog.tb_manufacturer (main table with full Trinity)
# 2. catalog.tl_manufacturer (translation table with Hybrid Trinity) â† NEW
#    - pk_manufacturer_translation INTEGER (performance)
#    - id UUID (API access)
#    - NO identifier field
# 3. Translation field helpers: get_manufacturer_name(pk, locale) â† NEW
```

**Design Philosophy**: Translation tables are detail records, not top-level entities. The composite (parent + locale) already provides uniqueness. No identifier needed (stored or virtual).

---

## ðŸŽ¯ Success Criteria

### Quantitative
- âœ… Generate valid translation table DDL with **Hybrid Trinity pattern**
- âœ… Support 1-10 translatable fields per entity
- âœ… Include **2 identity fields** (pk_* INTEGER, id UUID - no identifier)
- âœ… Audit fields (created_at, updated_at, deleted_at)
- âœ… FK constraints to parent + locale
- âœ… Unique constraint (parent + locale)
- âœ… Helper functions for translation field lookup (with locale fallback)
- âœ… 100% test coverage (unit + integration)

### Qualitative
- âœ… Follows SpecQL naming conventions (`tl_*` prefix)
- âœ… Compatible with existing schema orchestration
- âœ… Zero breaking changes to existing features
- âœ… PrintOptim-compatible output

---

## ðŸ—ï¸ Architecture

### Translation Table Pattern (PrintOptim Standard)

```sql
-- Main table: catalog.tb_manufacturer
CREATE TABLE catalog.tb_manufacturer (
    id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    pk_manufacturer UUID DEFAULT gen_random_uuid() NOT NULL UNIQUE,
    identifier TEXT NOT NULL UNIQUE,
    -- Business fields (non-translatable)
    code TEXT,
    website TEXT,
    -- Audit fields
    created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
    ...
);

-- Translation table: catalog.tl_manufacturer â† GENERATED
CREATE TABLE catalog.tl_manufacturer (
    -- Hybrid Trinity Pattern (INTEGER PK + UUID, no identifier)
    pk_manufacturer_translation INTEGER PRIMARY KEY GENERATED ALWAYS AS IDENTITY,
    id UUID UNIQUE NOT NULL DEFAULT gen_random_uuid(),
    -- Note: No identifier field (computed virtually from parent + locale)

    -- Foreign keys
    fk_manufacturer UUID NOT NULL
        REFERENCES catalog.tb_manufacturer(pk_manufacturer)
        ON DELETE CASCADE,
    fk_locale UUID NOT NULL
        REFERENCES common.tb_locale(pk_locale)
        ON DELETE CASCADE,

    -- Translatable fields
    name TEXT NOT NULL,
    description TEXT,

    -- Audit fields
    created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
    created_by UUID,
    updated_at TIMESTAMPTZ NOT NULL DEFAULT now(),
    updated_by UUID,
    deleted_at TIMESTAMPTZ,
    deleted_by UUID,

    -- Unique constraint (one translation per locale)
    CONSTRAINT tl_manufacturer_uniq UNIQUE (fk_manufacturer, fk_locale)
);

-- Helper function: Get translated name
CREATE OR REPLACE FUNCTION catalog.get_manufacturer_name(
    p_manufacturer_pk UUID,
    p_locale_pk UUID DEFAULT NULL
)
RETURNS TEXT AS $$
BEGIN
    RETURN (
        SELECT name
        FROM catalog.tl_manufacturer
        WHERE fk_manufacturer = p_manufacturer_pk
          AND fk_locale = COALESCE(p_locale_pk, catalog.get_default_locale())
        LIMIT 1
    );
END;
$$ LANGUAGE plpgsql STABLE;
```

### Generator Integration Points

```
EntityDefinition (with translations config)
    â†“
SchemaOrchestrator.generate()
    â†“
TableGenerator.generate() â† Main table (tb_*)
    â†“
[NEW] TranslationTableGenerator.generate() â† Translation table (tl_*)
    â†“
[NEW] TranslationHelperGenerator.generate() â† Helper functions
    â†“
Output: SchemaOutput with translation DDL
```

---

## ðŸ“ Design Decisions

### 1. Table Naming Convention
**Decision**: Use `tl_` prefix (not `tb_translation_` or `{entity}_translation`)
**Rationale**: Matches PrintOptim convention, shorter, clearer intent
**Example**: `tl_manufacturer`, `tl_country`, `tl_product_category`

### 2. Trinity Pattern in Translation Tables (Hybrid Approach)
**Decision**: Hybrid Trinity Pattern - INTEGER PK + UUID only (NO identifier field)
**Rationale**: Translation tables are detail records; identifier is redundant with (parent + locale) composite
**Fields**:
- `pk_{entity}_translation` - INTEGER PRIMARY KEY (performance)
- `id` - UUID UNIQUE (API access)
- **NO identifier field** - computed virtually when needed
**Virtual Identifier**: When debugging, compute as `{parent_identifier}.{locale_code}`
**Example**:
- pk: `42` (internal joins)
- id: `550e8400-...` (API access)
- virtual identifier: `manufacturer.acme.en-US` (computed from JOIN, not stored)

### 3. Foreign Key Column Naming
**Decision**: `fk_{entity}` for parent, `fk_locale` for locale
**Rationale**: Matches existing FK conventions, clear semantic meaning
**Example**: `fk_manufacturer`, `fk_locale`

### 4. Translation Table Schema Location
**Decision**: Same schema as parent entity
**Rationale**: Keeps related tables together, simplifies permission management
**Example**: `catalog.tb_manufacturer` â†’ `catalog.tl_manufacturer`

### 5. Identifier Field in Translation Tables
**Decision**: NO identifier field (neither stored nor computed helper)
**Rationale**: Translation tables are detail records; (fk_parent, fk_locale) already provides uniqueness
**Debugging**: Use ad-hoc JOINs when needed (no helper function required)
**Benefits**:
- Simplest possible design
- No redundant storage
- No helper function maintenance
- Better matches PrintOptim pattern (which also lacks identifier)
**Example**: If debugging needed, write query: `SELECT parent.identifier || '.' || locale.code FROM ...`

### 6. Field Removal from Main Table
**Decision**: DO NOT remove translatable fields from main table
**Rationale**: Maintain backward compatibility, allow default/fallback values
**Migration Path**: Optional `--strict-translations` flag to remove (future enhancement)

### 7. Helper Function Pattern
**Decision**: Generate `get_{entity}_{field}(pk, locale)` for each translatable field
**Rationale**: Simplifies queries, encapsulates locale fallback logic
**Example**: `get_manufacturer_name(pk, locale)`, `get_country_label(pk, locale)`

### 8. Locale Fallback Strategy
**Decision**: Helper functions use `COALESCE(p_locale, get_default_locale())`
**Rationale**: Always return a value, graceful degradation for missing translations
**Behavior**: Locale param â†’ Default locale â†’ First available translation

---

## ðŸ§ª PHASE 1: Foundation (RED/GREEN/REFACTOR/QA)

**Objective**: Create `TranslationTableGenerator` class with basic DDL generation

### RED: Write Failing Test (30 min)
```python
# tests/unit/schema/test_translation_table_generator.py
def test_generate_translation_table_basic():
    """Generate basic translation table DDL"""
    entity = EntityDefinition(
        name="Manufacturer",
        schema="catalog",
        fields={
            "code": FieldDefinition(name="code", type="text"),
            "name": FieldDefinition(name="name", type="text"),
        },
        translations=TranslationConfig(
            enabled=True,
            fields=["name"]
        )
    )

    generator = TranslationTableGenerator()
    ddl = generator.generate(entity)

    assert "CREATE TABLE catalog.tl_manufacturer" in ddl
    # Hybrid Trinity pattern (2 fields: pk + id, no identifier)
    assert "pk_manufacturer_translation INTEGER PRIMARY KEY" in ddl
    assert "id UUID UNIQUE NOT NULL" in ddl
    # Should NOT have identifier field
    assert "identifier TEXT" not in ddl
    # Foreign keys
    assert "fk_manufacturer UUID" in ddl
    assert "fk_locale UUID" in ddl
    # Translatable fields
    assert "name TEXT NOT NULL" in ddl
    # Unique constraint
    assert "CONSTRAINT tl_manufacturer_uniq UNIQUE (fk_manufacturer, fk_locale)" in ddl
```

**Expected**: Test fails (class doesn't exist)

### GREEN: Minimal Implementation (1-2h)
```python
# generators/schema/translation_table_generator.py
from core.ast_models import EntityDefinition
from generators.schema.naming_conventions import NamingConventions
from utils.safe_slug import safe_table_name

class TranslationTableGenerator:
    """Generates tl_* translation tables for entities with translations config"""

    def __init__(self, naming: NamingConventions | None = None):
        self.naming = naming or NamingConventions()

    def generate(self, entity: EntityDefinition) -> str:
        """
        Generate translation table DDL

        Returns empty string if translations not enabled
        """
        if not entity.translations or not entity.translations.enabled:
            return ""

        table_name = self._get_translation_table_name(entity)
        parent_table_name = safe_table_name(entity.name)

        ddl_parts = []

        # CREATE TABLE
        ddl_parts.append(f"-- Translation Table: {entity.name}")
        ddl_parts.append(f"CREATE TABLE {entity.schema}.{table_name} (")

        # Hybrid Trinity pattern (2 fields: INTEGER PK + UUID, no identifier)
        ddl_parts.append("    -- Hybrid Trinity Pattern")
        ddl_parts.append(f"    pk_{parent_table_name}_translation INTEGER PRIMARY KEY GENERATED ALWAYS AS IDENTITY,")
        ddl_parts.append("    id UUID UNIQUE NOT NULL DEFAULT gen_random_uuid(),")
        ddl_parts.append("    -- Note: No identifier field (computed virtually)")
        ddl_parts.append("")

        # Foreign keys
        ddl_parts.append("    -- Foreign Keys")
        ddl_parts.append(f"    fk_{parent_table_name} UUID NOT NULL")
        ddl_parts.append(f"        REFERENCES {entity.schema}.tb_{parent_table_name}(pk_{parent_table_name})")
        ddl_parts.append("        ON DELETE CASCADE,")
        ddl_parts.append("    fk_locale UUID NOT NULL")
        ddl_parts.append("        REFERENCES common.tb_locale(pk_locale)")
        ddl_parts.append("        ON DELETE CASCADE,")
        ddl_parts.append("")

        # Translatable fields
        ddl_parts.append("    -- Translatable Fields")
        for field_name in entity.translations.fields:
            field_def = entity.fields.get(field_name)
            if field_def:
                sql_type = self._map_field_type(field_def)
                nullable = "NULL" if field_def.nullable else "NOT NULL"
                ddl_parts.append(f"    {field_name} {sql_type} {nullable},")
        ddl_parts.append("")

        # Audit fields
        ddl_parts.append("    -- Audit Fields")
        ddl_parts.append("    created_at TIMESTAMPTZ NOT NULL DEFAULT now(),")
        ddl_parts.append("    created_by UUID,")
        ddl_parts.append("    updated_at TIMESTAMPTZ NOT NULL DEFAULT now(),")
        ddl_parts.append("    updated_by UUID,")
        ddl_parts.append("    deleted_at TIMESTAMPTZ,")
        ddl_parts.append("    deleted_by UUID,")
        ddl_parts.append("")

        # Unique constraint
        ddl_parts.append("    -- Unique Constraint")
        ddl_parts.append(f"    CONSTRAINT {table_name}_uniq UNIQUE (fk_{parent_table_name}, fk_locale)")

        ddl_parts.append(");")
        ddl_parts.append("")

        # Comments
        ddl_parts.append(f"COMMENT ON TABLE {entity.schema}.{table_name} IS 'Translation table for {entity.name}. Stores locale-specific translatable fields.';")

        return "\n".join(ddl_parts)

    def _get_translation_table_name(self, entity: EntityDefinition) -> str:
        """Get translation table name (tl_*)"""
        if entity.translations and entity.translations.table_name:
            return entity.translations.table_name
        return f"tl_{safe_table_name(entity.name)}"

    def _map_field_type(self, field_def) -> str:
        """Map SpecQL field type to SQL type"""
        # Basic type mapping (expand as needed)
        type_map = {
            "text": "TEXT",
            "integer": "INTEGER",
            "boolean": "BOOLEAN",
            "date": "DATE",
            "timestamp": "TIMESTAMPTZ",
        }
        return type_map.get(field_def.type, "TEXT")
```

**Expected**: Test passes âœ…

### REFACTOR: Clean Code (30 min)
- Extract field type mapping to shared utility
- Add validation (check translatable fields exist in entity)
- Improve error messages
- Add docstrings

### QA: Phase 1 Validation (30 min)
```bash
# Run tests
uv run pytest tests/unit/schema/test_translation_table_generator.py -v

# Check coverage
uv run pytest --cov=generators/schema/translation_table_generator.py

# Lint
uv run ruff check generators/schema/translation_table_generator.py
```

**Expected**: All passing, 100% coverage, no lint errors

---

## ðŸ§ª PHASE 2: Helper Functions (RED/GREEN/REFACTOR/QA)

**Objective**: Generate `get_{entity}_{field}()` helper functions

### RED: Write Failing Test (30 min)
```python
# tests/unit/schema/test_translation_helper_generator.py
def test_generate_translation_helpers():
    """Generate helper functions for translated fields"""
    entity = EntityDefinition(
        name="Manufacturer",
        schema="catalog",
        fields={
            "name": FieldDefinition(name="name", type="text"),
            "description": FieldDefinition(name="description", type="text"),
        },
        translations=TranslationConfig(
            enabled=True,
            fields=["name", "description"]
        )
    )

    generator = TranslationHelperGenerator()
    helpers = generator.generate(entity)

    # Should generate 2 helper functions
    assert "CREATE OR REPLACE FUNCTION catalog.get_manufacturer_name" in helpers
    assert "CREATE OR REPLACE FUNCTION catalog.get_manufacturer_description" in helpers
    assert "p_manufacturer_pk UUID" in helpers
    assert "p_locale_pk UUID DEFAULT NULL" in helpers
    assert "COALESCE(p_locale_pk, catalog.get_default_locale())" in helpers
```

**Expected**: Test fails (class doesn't exist)

### GREEN: Minimal Implementation (1-2h)
```python
# generators/schema/translation_helper_generator.py
from core.ast_models import EntityDefinition
from utils.safe_slug import safe_table_name

class TranslationHelperGenerator:
    """Generates helper functions for translation tables"""

    def generate(self, entity: EntityDefinition) -> str:
        """Generate helper functions for all translatable fields"""
        if not entity.translations or not entity.translations.enabled:
            return ""

        helpers = []

        for field_name in entity.translations.fields:
            helpers.append(self._generate_field_helper(entity, field_name))

        return "\n\n".join(helpers)

    def _generate_field_helper(self, entity: EntityDefinition, field_name: str) -> str:
        """Generate helper function for a single translatable field"""
        table_name = safe_table_name(entity.name)
        translation_table = f"tl_{table_name}"

        # Get field SQL type
        field_def = entity.fields[field_name]
        return_type = self._map_field_type(field_def)

        function_sql = f"""
-- Helper function: Get translated {field_name}
CREATE OR REPLACE FUNCTION {entity.schema}.get_{table_name}_{field_name}(
    p_{table_name}_pk UUID,
    p_locale_pk UUID DEFAULT NULL
)
RETURNS {return_type} AS $$
BEGIN
    RETURN (
        SELECT {field_name}
        FROM {entity.schema}.{translation_table}
        WHERE fk_{table_name} = p_{table_name}_pk
          AND fk_locale = COALESCE(p_locale_pk, {entity.schema}.get_default_locale())
          AND deleted_at IS NULL
        LIMIT 1
    );
END;
$$ LANGUAGE plpgsql STABLE;

COMMENT ON FUNCTION {entity.schema}.get_{table_name}_{field_name}(UUID, UUID) IS
    'Get translated {field_name} for {entity.name}. Falls back to default locale if translation not found.';
""".strip()

        return function_sql

    def _map_field_type(self, field_def) -> str:
        """Map SpecQL field type to SQL return type"""
        type_map = {
            "text": "TEXT",
            "integer": "INTEGER",
            "boolean": "BOOLEAN",
        }
        return type_map.get(field_def.type, "TEXT")
```

**Expected**: Test passes âœ…

### REFACTOR: Clean Code (30 min)
- Share type mapping with TranslationTableGenerator
- Add get_default_locale() prerequisite check
- Support nullable fields (RETURNS TEXT | NULL)

### QA: Phase 2 Validation (30 min)
```bash
uv run pytest tests/unit/schema/test_translation_helper_generator.py -v
uv run pytest --cov=generators/schema/translation_helper_generator.py
```

---

## ðŸ§ª PHASE 3: Schema Orchestration Integration (RED/GREEN/REFACTOR/QA)

**Objective**: Integrate translation generation into SchemaOrchestrator

### RED: Write Failing Test (30 min)
```python
# tests/integration/test_translation_e2e.py
def test_translation_table_e2e():
    """End-to-end test: YAML â†’ DDL with translation tables"""
    yaml_content = """
entity: Manufacturer
schema: catalog
fields:
  code: text
  name: text
  description: text
translations:
  enabled: true
  fields: [name, description]
"""

    entity = parse_specql_yaml(yaml_content)
    orchestrator = SchemaOrchestrator()
    output = orchestrator.generate(entity)

    # Should include main table
    assert "CREATE TABLE catalog.tb_manufacturer" in output.table_sql

    # Should include translation table
    assert "CREATE TABLE catalog.tl_manufacturer" in output.table_sql

    # Should include helper functions
    assert "get_manufacturer_name" in output.helpers_sql
    assert "get_manufacturer_description" in output.helpers_sql
```

**Expected**: Test fails (orchestrator doesn't call translation generators)

### GREEN: Minimal Implementation (1-2h)
```python
# generators/schema_orchestrator.py
class SchemaOrchestrator:
    def __init__(self, ...):
        # ... existing code ...

        # Add translation generators
        self.translation_table_gen = TranslationTableGenerator(naming_conventions)
        self.translation_helper_gen = TranslationHelperGenerator()

    def generate(self, entity: Entity | EntityDefinition) -> SchemaOutput:
        # ... existing code ...

        # Generate translation table (if enabled)
        translation_table_ddl = ""
        translation_helpers_ddl = ""

        if entity_def.translations and entity_def.translations.enabled:
            translation_table_ddl = self.translation_table_gen.generate(entity_def)
            translation_helpers_ddl = self.translation_helper_gen.generate(entity_def)

        # Combine table DDL
        table_sql = table_ddl + "\n\n" + translation_table_ddl

        # Combine helpers
        helpers_sql = trinity_helpers + "\n\n" + translation_helpers_ddl

        return SchemaOutput(
            table_sql=table_sql,
            helpers_sql=helpers_sql,
            mutations=mutations,
            input_types_sql=input_types_sql,
        )
```

**Expected**: Test passes âœ…

### REFACTOR: Clean Code (30 min)
- Extract translation generation to separate method
- Add logging for translation table generation
- Handle edge cases (no translatable fields, missing locale table)

### QA: Phase 3 Validation (1h)
```bash
# Run full integration tests
uv run pytest tests/integration/test_translation_e2e.py -v

# Run full test suite
uv run pytest tests/unit/schema/ tests/integration/ -v

# Smoke test with real YAML
specql generate tests/fixtures/entities/catalog/manufacturer.yaml --output /tmp/test_output/
```

---

## ðŸ§ª PHASE 4: PrintOptim Compatibility (RED/GREEN/REFACTOR/QA)

**Objective**: Ensure output matches PrintOptim conventions exactly

### RED: Write Failing Test (30 min)
```python
# tests/integration/test_printoptim_translation_compatibility.py
def test_translation_table_matches_printoptim_pattern():
    """Verify output matches PrintOptim's existing tl_* tables"""

    # Use actual PrintOptim entity as reference
    entity = EntityDefinition(
        name="Currency",
        schema="catalog",
        fields={
            "code": FieldDefinition(name="code", type="text"),
            "symbol": FieldDefinition(name="symbol", type="text"),
            "label": FieldDefinition(name="label", type="text"),
        },
        translations=TranslationConfig(
            enabled=True,
            fields=["label"]
        )
    )

    orchestrator = SchemaOrchestrator()
    output = orchestrator.generate(entity)

    # Compare with PrintOptim reference
    expected_structure = """
CREATE TABLE catalog.tl_currency (
    id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    pk_currency_translation UUID DEFAULT gen_random_uuid() NOT NULL,
    fk_currency UUID NOT NULL
        REFERENCES catalog.tb_currency(pk_currency)
        ON DELETE CASCADE,
    fk_locale UUID NOT NULL
        REFERENCES common.tb_locale(pk_locale)
        ON DELETE CASCADE,
    label TEXT NOT NULL,
    created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
    ...
    CONSTRAINT tl_currency_uniq UNIQUE (fk_currency, fk_locale)
);
"""

    assert_ddl_equivalent(output.table_sql, expected_structure)
```

**Expected**: Test fails (minor formatting differences)

### GREEN: Fix Formatting (1h)
- Adjust whitespace to match PrintOptim style
- Fix FK constraint formatting
- Add proper comments matching PrintOptim pattern

### REFACTOR: Extract PrintOptim Patterns (30 min)
- Document PrintOptim conventions in code comments
- Create reference comparison utility

### QA: Phase 4 Validation (1h)
```bash
# Compare generated DDL with PrintOptim reference
python scripts/compare_translation_ddl.py \
  --generated /tmp/test_output/tl_currency.sql \
  --reference printoptim_backend/db/0_schema/01_write_side/catalog/tl_currency.sql

# Run PrintOptim compatibility tests
uv run pytest tests/integration/test_printoptim_translation_compatibility.py -v
```

---

## ðŸ§ª PHASE 5: (SKIPPED - No Virtual Identifier Needed)

**Decision**: Virtual identifier helper is not needed
**Rationale**:
- Translation tables are internal detail records
- Debugging can be done with simple JOINs in ad-hoc queries
- Reduces complexity and maintenance burden
- No practical use case identified

**If debugging needed**, use ad-hoc query:
```sql
-- Ad-hoc query for debugging (no helper function needed)
SELECT
    t.pk_manufacturer_translation,
    parent.identifier || '.' || locale.code as debug_identifier,
    t.name
FROM catalog.tl_manufacturer t
JOIN catalog.tb_manufacturer parent ON t.fk_manufacturer = parent.pk_manufacturer
JOIN common.tb_locale locale ON t.fk_locale = locale.pk_locale;
```

---

## ðŸ§ª PHASE 5: Edge Cases & Polish (RED/GREEN/REFACTOR/QA)

**Objective**: Handle edge cases, improve error messages

### RED: Write Edge Case Tests (1h)
```python
# tests/unit/schema/test_translation_edge_cases.py

def test_translation_without_fields():
    """Should handle translations enabled but no fields specified"""
    # Should log warning and skip generation

def test_translation_with_nonexistent_field():
    """Should raise clear error for invalid field names"""
    # Should fail validation early

def test_translation_with_composite_types():
    """Should handle translatable composite types (if supported)"""
    # Future enhancement

def test_multiple_entities_with_translations():
    """Should generate unique translation tables for each entity"""
    # Avoid naming collisions

def test_translation_table_indexes():
    """Should add appropriate indexes (FK columns)"""
    # Performance optimization
```

### GREEN: Implement Edge Case Handling (2h)
- Add validation in parser (check fields exist)
- Add warning logging for empty fields list
- Generate FK indexes automatically
- Handle nullable translatable fields correctly

### REFACTOR: Polish (1h)
- Improve error messages
- Add comprehensive docstrings
- Extract magic strings to constants
- Add type hints

### QA: Phase 5 Validation (1h)
```bash
# Run all translation tests
uv run pytest tests/ -k translation -v

# Coverage report
uv run pytest --cov=generators/schema/translation* --cov-report=html

# Full test suite
make test
```

---

## ðŸ“ File Structure

```
generators/schema/
â”œâ”€â”€ translation_table_generator.py                # Phase 1 (130 lines) â† Hybrid pattern
â”œâ”€â”€ translation_helper_generator.py               # Phase 2 (80 lines)
â””â”€â”€ schema_orchestrator.py                        # Phase 3 (modified)

tests/unit/schema/
â”œâ”€â”€ test_translation_table_generator.py           # Phase 1 (150 lines) â† Hybrid tests
â”œâ”€â”€ test_translation_helper_generator.py          # Phase 2 (100 lines)
â””â”€â”€ test_translation_edge_cases.py                # Phase 5 (120 lines)

tests/integration/
â”œâ”€â”€ test_translation_e2e.py                       # Phase 3 (100 lines) â† Hybrid validation
â””â”€â”€ test_printoptim_translation_compatibility.py  # Phase 4 (80 lines)

docs/
â””â”€â”€ 05_guides/translation-tables.md               # Documentation (optional)
```

**Total New Code**: ~760 lines (generators + tests)

---

## â±ï¸ Effort Breakdown

| Phase | Activity | Time | Cumulative |
|-------|----------|------|------------|
| **1** | Foundation RED | 0.5h | 0.5h |
| **1** | Foundation GREEN | 2h | 2.5h |
| **1** | Foundation REFACTOR | 0.5h | 3h |
| **1** | Foundation QA | 0.5h | 3.5h |
| **2** | Helpers RED | 0.5h | 4h |
| **2** | Helpers GREEN | 2h | 6h |
| **2** | Helpers REFACTOR | 0.5h | 6.5h |
| **2** | Helpers QA | 0.5h | 7h |
| **3** | Integration RED | 0.5h | 7.5h |
| **3** | Integration GREEN | 2h | 9.5h |
| **3** | Integration REFACTOR | 0.5h | 10h |
| **3** | Integration QA | 1h | 11h |
| **4** | PrintOptim RED | 0.5h | 11.5h |
| **4** | PrintOptim GREEN | 1h | 12.5h |
| **4** | PrintOptim REFACTOR | 0.5h | 13h |
| **4** | PrintOptim QA | 1h | 14h |
| **5** | Edge Cases RED | 1h | 15h |
| **5** | Edge Cases RED | 1h | 15h |
| **5** | Edge Cases GREEN | 2h | 17h |
| **5** | Edge Cases REFACTOR | 1h | 18h |
| **5** | Edge Cases QA | 1h | 19h |

**Total**: 19 hours (conservative estimate with buffer)

---

## ðŸš€ Implementation Timeline

### Day 1 (4h)
- âœ… Phase 1: Foundation (3.5h)
- âœ… Phase 2: Helpers (start RED/GREEN, 0.5h)

### Day 2 (4h)
- âœ… Phase 2: Helpers (finish, 3h)
- âœ… Phase 3: Integration (start RED/GREEN, 1h)

### Day 3 (4h)
- âœ… Phase 3: Integration (finish, 3h)
- âœ… Phase 4: PrintOptim (start, 1h)

### Day 4 (4h)
- âœ… Phase 4: PrintOptim (finish, 3h)
- âœ… Phase 5: Edge Cases (start, 1h)

### Day 5 (4h)
- âœ… Phase 5: Edge Cases (finish, 4h)

### Day 6 (Buffer/Documentation)
- âœ… Final validation & documentation
- âœ… Manual testing with sample entities

**Total**: 5 days @ 4h/day = 19 hours (with buffer)

---

## ðŸ§ª Test Strategy

### Unit Tests (70% coverage target)
- `test_translation_table_generator.py` - Table DDL generation
- `test_translation_helper_generator.py` - Helper function generation
- `test_translation_edge_cases.py` - Edge cases & error handling

### Integration Tests (30% coverage target)
- `test_translation_e2e.py` - End-to-end workflow
- `test_printoptim_translation_compatibility.py` - PrintOptim pattern matching

### Manual Testing
```bash
# Test with stdlib entity
specql generate stdlib/i18n/country.yaml --output /tmp/test_output/

# Test with PrintOptim entity (after extraction)
specql generate entities/catalog/manufacturer.yaml --output /tmp/test_output/

# Compare with original PrintOptim DDL
diff /tmp/test_output/10_tables/manufacturer.sql \
     printoptim_backend/db/0_schema/01_write_side/catalog/tl_manufacturer.sql
```

---

## ðŸŽ¯ Success Metrics

### Development Metrics
- âœ… 100% of planned tests passing
- âœ… >90% code coverage on new code
- âœ… 0 linting errors
- âœ… 0 breaking changes to existing tests

### Feature Metrics
- âœ… Generate valid DDL for 20+ PrintOptim catalog entities
- âœ… DDL matches PrintOptim conventions (via diff comparison)
- âœ… Helper functions work with FraiseQL queries
- âœ… Performance: <100ms per translation table generation

---

## ðŸš¨ Risk Mitigation

### Risk 1: Locale Table Dependency
**Problem**: Translation tables depend on `common.tb_locale` existing
**Mitigation**:
- Document prerequisite in error messages
- Add validation check (warn if locale table missing)
- Provide sample locale table in stdlib

### Risk 2: get_default_locale() Function Missing
**Problem**: Helper functions call `get_default_locale()` which may not exist
**Mitigation**:
- Generate this function in common schema (Phase 2 enhancement)
- Or inline fallback logic: `SELECT pk_locale FROM tb_locale WHERE is_default LIMIT 1`

### Risk 3: Naming Collisions
**Problem**: Multiple entities with same name in different schemas
**Mitigation**:
- Translation tables inherit parent schema (no collision possible)
- FK column names include entity name (`fk_manufacturer` vs `fk_country`)

---

## ðŸ“š Documentation Updates

### User-Facing Docs
- **New**: `docs/05_guides/translation-tables.md` - Translation table guide
- **Update**: `docs/06_reference/yaml-syntax.md` - Add `translations` config
- **Update**: `GETTING_STARTED.md` - Add i18n example

### Internal Docs
- **New**: `generators/schema/README.md` - Translation generator architecture
- **Update**: `.claude/CLAUDE.md` - Document translation feature

---

## ðŸ”„ Future Enhancements (Out of Scope)

### V2 Features (Not Included in 8-12h Estimate)
1. **Automatic Field Removal** - Remove translatable fields from main table (`--strict-translations` flag)
2. **Translation Seeding** - Generate INSERT statements for default translations
3. **Translation Validation** - Ensure all entities have translations in all active locales
4. **Composite Type Translation** - Support translating JSONB composite fields
5. **Translation Actions** - Auto-generate `add_translation`, `update_translation` actions
6. **FraiseQL Metadata** - Add translation hints to GraphQL schema
7. **Translation Helper Views** - Generate materialized views joining tb_* + tl_*

---

## âœ… Definition of Done

### Code Complete
- âœ… All 5 phases implemented
- âœ… All tests passing (unit + integration)
- âœ… Code coverage >90%
- âœ… No linting errors
- âœ… Code reviewed

### Feature Complete
- âœ… Generates valid translation table DDL
- âœ… Generates helper functions
- âœ… Integrates with SchemaOrchestrator
- âœ… Matches PrintOptim conventions
- âœ… Handles edge cases gracefully

### Documentation Complete
- âœ… User guide written
- âœ… Code documented (docstrings)
- âœ… Examples provided (stdlib entities)
- âœ… Migration notes updated

### Validation Complete
- âœ… Manual testing passed (5 entities)
- âœ… PrintOptim DDL comparison passed
- âœ… Performance benchmarks met (<100ms)
- âœ… No regressions in existing features

---

## ðŸŽ¯ Next Steps

1. **Review Plan** - Get stakeholder approval (30 min)
2. **Set Up Branch** - Create `feature/translation-table-generator` branch
3. **Start Phase 1** - Begin TDD cycle (Day 1)
4. **Daily Standups** - Report progress, blockers
5. **Merge** - PR review + merge to main (after Phase 5 QA)

---

**Last Updated**: 2025-11-21
**Status**: Ready for Implementation
**Estimated Completion**: 5 days @ 4h/day = 20 hours
**Priority**: HIGH - Unblocks PrintOptim migration
