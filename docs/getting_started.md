# Getting Started with SpecQL

Welcome to SpecQL! This guide will help you get up and running with the universal business logic compiler in just 30 minutes.

## What is SpecQL?

SpecQL is a universal business logic compiler that transforms simple YAML specifications into production-ready code for multiple languages:

- **PostgreSQL** functions and triggers
- **Python Django** models and business logic
- **SQLAlchemy** models and queries

With SpecQL, you can write business logic once and deploy it everywhere.

## Prerequisites

Before you begin, ensure you have:

- **Python 3.9+** installed
- **PostgreSQL** (for testing generated code)
- **Git** for cloning the repository

## Installation

### Option 1: Install from PyPI (Recommended)

```bash
pip install specql
```

### Option 2: Install from Source

```bash
git clone https://github.com/your-org/specql.git
cd specql
pip install -e .
```

## Your First Entity

Let's create a simple Contact entity for a CRM system.

### 1. Create Your First YAML File

Create a file called `contact.yaml`:

```yaml
entity: Contact
namespace: crm
description: "Customer contact information"

fields:
  first_name:
    type: text
    required: true
    description: "Contact's first name"

  last_name:
    type: text
    required: true
    description: "Contact's last name"

  email:
    type: text
    required: true
    unique: true
    description: "Primary email address"

  phone:
    type: text
    description: "Phone number"

actions:
  - name: create_contact
    type: insert
    description: "Create a new contact"
    parameters:
      first_name: text
      last_name: text
      email: text
      phone: text
    steps:
      - type: insert
        table: tb_contact
        data:
          first_name: "{{ first_name }}"
          last_name: "{{ last_name }}"
          email: "{{ email }}"
          phone: "{{ phone }}"

  - name: update_contact
    type: update
    description: "Update contact information"
    parameters:
      contact_id: uuid
      first_name: text
      last_name: text
      email: text
      phone: text
    steps:
      - type: update
        table: tb_contact
        where: "id = {{ contact_id }}"
        data:
          first_name: "{{ first_name }}"
          last_name: "{{ last_name }}"
          email: "{{ email }}"
          phone: "{{ phone }}"
```

### 2. Generate PostgreSQL Schema

```bash
specql generate contact.yaml --target postgresql --output contact.sql
```

This creates `contact.sql` with:

```sql
-- Generated by SpecQL v1.0.0
-- Entity: Contact (crm)
-- Generated: 2025-11-12

CREATE TABLE crm.tb_contact (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    first_name TEXT NOT NULL,
    last_name TEXT NOT NULL,
    email TEXT NOT NULL UNIQUE,
    phone TEXT,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE OR REPLACE FUNCTION crm.create_contact(
    p_first_name TEXT,
    p_last_name TEXT,
    p_email TEXT,
    p_phone TEXT DEFAULT NULL
)
RETURNS crm.tb_contact AS $$
DECLARE
    v_result crm.tb_contact;
BEGIN
    INSERT INTO crm.tb_contact (
        first_name, last_name, email, phone
    ) VALUES (
        p_first_name, p_last_name, p_email, p_phone
    )
    RETURNING * INTO v_result;

    RETURN v_result;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION crm.update_contact(
    p_contact_id UUID,
    p_first_name TEXT,
    p_last_name TEXT,
    p_email TEXT,
    p_phone TEXT DEFAULT NULL
)
RETURNS crm.tb_contact AS $$
DECLARE
    v_result crm.tb_contact;
BEGIN
    UPDATE crm.tb_contact SET
        first_name = p_first_name,
        last_name = p_last_name,
        email = p_email,
        phone = p_phone,
        updated_at = NOW()
    WHERE id = p_contact_id
    RETURNING * INTO v_result;

    RETURN v_result;
END;
$$ LANGUAGE plpgsql;
```

### 3. Generate Python Django Code

```bash
specql generate contact.yaml --target python_django --output contact_django.py
```

This creates Django model code:

```python
# Generated by SpecQL v1.0.0
# Entity: Contact (crm)
# Generated: 2025-11-12

from django.db import models
from django.utils import timezone

class Contact(models.Model):
    id = models.UUIDField(primary_key=True, default=models.uuid.uuid4, editable=False)
    first_name = models.TextField()
    last_name = models.TextField()
    email = models.TextField(unique=True)
    phone = models.TextField(blank=True, null=True)
    created_at = models.DateTimeField(default=timezone.now)
    updated_at = models.DateTimeField(default=timezone.now)

    class Meta:
        db_table = 'crm.tb_contact'
        app_label = 'crm'

    def create_contact(self, first_name, last_name, email, phone=None):
        """Create a new contact"""
        contact = Contact.objects.create(
            first_name=first_name,
            last_name=last_name,
            email=email,
            phone=phone
        )
        return contact

    def update_contact(self, contact_id, first_name, last_name, email, phone=None):
        """Update contact information"""
        contact = Contact.objects.get(id=contact_id)
        contact.first_name = first_name
        contact.last_name = last_name
        contact.email = email
        contact.phone = phone
        contact.updated_at = timezone.now()
        contact.save()
        return contact
```

### 4. Test Your Generated Code

Create a test database and run the generated SQL:

```bash
# Create test database
createdb specql_test

# Run the generated SQL
psql specql_test < contact.sql

# Test the functions
psql specql_test -c "
SELECT * FROM crm.create_contact(
    'John', 'Doe', 'john.doe@example.com', '+1-555-0123'
);
"
```

## Using Domain Patterns

SpecQL includes pre-built domain patterns to accelerate development. Let's enhance our contact with state management:

```yaml
entity: Contact
namespace: crm
description: "Customer contact with lead qualification"

patterns:
  - state_machine:
      states: [prospect, qualified, customer, lost]
      initial_state: prospect
  - audit_trail:
      track_versions: true

fields:
  first_name: text
  last_name: text
  email: text
  phone: text

actions:
  - name: qualify_lead
    type: transition
    description: "Move contact from prospect to qualified"
    from_state: prospect
    to_state: qualified
    steps:
      - type: update
        table: tb_contact
        data:
          state: "'qualified'"
          qualified_at: "NOW()"
```

Generate the enhanced version:

```bash
specql generate contact_enhanced.yaml --target postgresql --output contact_enhanced.sql
```

The generated code now includes:
- State machine fields and validation
- Audit trail (created_at, created_by, updated_at, updated_by)
- Version tracking
- State transition functions

## Multi-Language Generation

Generate code for all supported languages at once:

```bash
# Generate everything
specql generate contact.yaml --all-targets --output-dir ./generated/

# This creates:
# ./generated/postgresql/contact.sql
# ./generated/python_django/contact.py
# ./generated/python_sqlalchemy/contact.py
```

## Next Steps

Now that you have the basics:

1. **Explore Patterns**: Check out [Domain Patterns](../reference/domain_patterns.md) for pre-built solutions
2. **Use Templates**: Start with [Entity Templates](../reference/entity_templates.md) for common use cases
3. **Learn State Machines**: See [State Machines Tutorial](../tutorials/03-state-machines.md)
4. **Generate Tests**: Use [Testing Tutorial](../tutorials/04-testing.md)

## Getting Help

- **Documentation**: Full reference at [docs.specql.dev](https://docs.specql.dev)
- **Examples**: Browse [example applications](../examples/)
- **CLI Help**: Run `specql --help` or `specql generate --help`
- **Community**: Join our [Discord server](https://discord.gg/specql)

## Quick Reference

### Common Commands

```bash
# Generate PostgreSQL only
specql generate entity.yaml --target postgresql

# Generate all languages
specql generate entity.yaml --all-targets

# Validate YAML syntax
specql validate entity.yaml

# List available patterns
specql patterns list

# Show pattern details
specql patterns show state_machine
```

### YAML Structure

```yaml
entity: EntityName          # Required: Entity name
namespace: app              # Optional: Schema/app namespace
description: "..."         # Optional: Human description

patterns:                   # Optional: Domain patterns
  - state_machine
  - audit_trail

fields:                     # Required: Entity fields
  field_name:
    type: text|integer|uuid|timestamp|boolean|json
    required: true|false
    unique: true|false
    description: "..."

actions:                    # Optional: Business logic actions
  - name: action_name
    type: insert|update|select|delete|transition
    parameters: {...}
    steps: [...]
```

Happy coding with SpecQL! ðŸš€