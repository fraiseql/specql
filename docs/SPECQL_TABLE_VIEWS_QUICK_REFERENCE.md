# SpecQL Table Views (tv_) - Quick Reference

## What Are Table Views?

**tv_ tables** are denormalized, read-optimized tables with precomputed JSONB structures. They enable fast queries on normalized data by composing related entities into a single JSONB payload.

---

## Quick Example

### Input YAML
```yaml
entity: Contact
schema: tenant
fields:
  name: text
  email: email
  organization: ref(Organization)
  created_at: timestamp

table_views:
  mode: auto
  include_relations:
    - entity_name: Organization
      fields: [name, code]
  extra_filter_columns:
    - email
    - created_at
```

### Generated SQL
```sql
-- Write-side normalized table
CREATE TABLE tenant.tb_contact (
    pk_contact INTEGER PRIMARY KEY,
    id UUID UNIQUE,
    name TEXT,
    email EMAIL,
    fk_organization INTEGER,
    created_at TIMESTAMPTZ
);

-- Read-side denormalized table
CREATE TABLE tenant.tv_contact (
    pk_contact INTEGER PRIMARY KEY,
    id UUID UNIQUE,
    tenant_id UUID,
    fk_organization INTEGER,
    organization_id UUID,      -- Promoted for filtering
    email TEXT,                -- Promoted for filtering
    created_at TIMESTAMPTZ,    -- Promoted for filtering
    data JSONB NOT NULL        -- {id, name, email, organization: {...}}
);

-- Refresh function (auto-generated)
CREATE OR REPLACE FUNCTION tenant.refresh_tv_contact(...)
RETURNS void AS $$
BEGIN
    INSERT INTO tenant.tv_contact
    SELECT ..., jsonb_build_object(
        'id', c.id,
        'name', c.name,
        'email', c.email,
        'organization', jsonb_build_object(
            'id', tv_org.data->>'id',
            'name', tv_org.data->>'name',
            'code', tv_org.data->>'code'
        )
    ) AS data
    FROM tenant.tb_contact c
    INNER JOIN catalog.tv_organization tv_org 
        ON tv_org.pk_organization = c.fk_organization;
END;
```

---

## Configuration Options

### Mode

```yaml
table_views:
  mode: auto      # Generate if entity has foreign keys (DEFAULT)
  mode: force     # Always generate (even without FKs)
  mode: disable   # Don't generate
```

### Include Relations

```yaml
table_views:
  include_relations:
    # Simple: include specified fields
    - entity_name: Organization
      fields: [name, code]
    
    # Nested: include relations within relations
    - entity_name: Product
      fields: [name, sku, price]
      include_relations:
        - entity_name: Category
          fields: [name]
        - entity_name: Manufacturer
          fields: [name, country]
```

### Extra Filter Columns

```yaml
table_views:
  extra_filter_columns:
    # Simple column
    - email
    - created_at
    
    # Complex: nested extraction
    - organization_name:
        source: organization.name
        type: text
        index: gin_trgm
```

---

## How It Works

### Three-Layer Architecture

```
Layer 1: tb_contact (normalized, write-optimized)
    ↓ (during mutation)
Layer 2: tv_contact (denormalized, read-optimized with JSONB)
    ↓ (FraiseQL introspects)
Layer 3: GraphQL (auto-generated by FraiseQL)
```

### Composition Strategy

SpecQL composes JSONB from **tv_ tables**, not tb_ tables:

```sql
-- When tv_contact refreshes:
INSERT INTO tenant.tv_contact (
    ..., data
)
SELECT
    ...,
    jsonb_build_object(
        'organization', tv_org.data  -- From tv_organization, not tb_organization
    )
FROM tenant.tb_contact c
INNER JOIN catalog.tv_organization tv_org ON ...;
```

**Why?** Ensures consistency - if tv_organization updates, tv_contact reflects those changes automatically.

---

## Using in Mutations

### Action with Table View Refresh

```yaml
actions:
  - name: update_email
    steps:
      - validate: email LIKE '%@%'
      - update: Contact SET email = $email
      - refresh_table_view:
          scope: self              # Only this contact
          propagate: []            # No cascading needed
```

### Refresh Scopes

| Scope | Effect |
|-------|--------|
| `self` | Refresh only this entity's tv_ |
| `related` | Refresh this + all entities that reference it |
| `propagate: [Entity1, Entity2]` | Refresh this + explicit list |
| `batch` (strategy) | Deferred refresh (bulk operations) |

---

## Two-Tier Filtering

### Tier 1: Direct Columns (B-tree, ~0.1ms)

```sql
-- FAST: Uses index
SELECT * FROM tenant.tv_contact WHERE email = 'user@example.com';
SELECT * FROM tenant.tv_contact WHERE created_at > NOW() - INTERVAL '7 days';
```

Auto-inferred:
- `tenant_id` (multi-tenancy)
- `{entity}_id` (FK filtering)
- `path` (hierarchical)

User-specified:
- Listed in `extra_filter_columns`

### Tier 2: JSONB Fields (GIN, ~50-100ms)

```sql
-- SLOWER: JSONB query
SELECT * FROM tenant.tv_contact 
WHERE data->>'name' ILIKE '%John%';

-- Even slower: nested path
SELECT * FROM tenant.tv_contact 
WHERE data->'organization'->>'code' = 'ORG123';
```

All JSONB fields are queryable but slower.

---

## Performance Impact

| Operation | Impact | Mitigation |
|-----------|--------|-----------|
| Write to tb_ | Normal | N/A |
| Refresh tv_ | Moderate CPU/IO | Don't refresh unnecessarily |
| Query by pk/FK | Very fast | B-tree index (auto) |
| Query by extra_filter_columns | Very fast | B-tree index (auto) |
| Query JSONB nested fields | Moderate | GIN index on data (auto) |

**Storage**: ~2x (tb_ is normalized, tv_ is denormalized)

---

## Common Patterns

### Pattern 1: Simple Denormalization

```yaml
entity: OrderLine
schema: sales
fields:
  order: ref(Order)
  product: ref(Product)
  quantity: integer

table_views:
  mode: auto
  # Default: include all fields from Order and Product
```

### Pattern 2: Selective Inclusion

```yaml
entity: Invoice
schema: accounting
fields:
  customer: ref(Customer)
  order: ref(Order)
  amount: decimal

table_views:
  mode: auto
  include_relations:
    # Only expose customer name and code, not full entity
    - entity_name: Customer
      fields: [name, code]
    # Don't expose order details
```

### Pattern 3: Force Without FKs

```yaml
entity: AuditLog
schema: core
fields:
  message: text
  metadata: json
  created_at: timestamp

table_views:
  mode: force  # Generate even without FKs
  extra_filter_columns:
    - created_at
```

### Pattern 4: Hierarchical

```yaml
entity: Location
schema: management
hierarchical: true
fields:
  name: text
  parent: ref(Location)

table_views:
  mode: auto
  # Auto-generates: path LTREE column
  include_relations:
    - entity_name: Location
      fields: [name]  # Parent location name
```

---

## GraphQL Integration

FraiseQL auto-discovers tv_ structure:

```sql
COMMENT ON TABLE tenant.tv_contact IS
  '@fraiseql:table source=materialized,refresh=explicit,primary=true';

COMMENT ON COLUMN tenant.tv_contact.data IS
  '@fraiseql:jsonb expand=true,description=Denormalized contact with organization';
```

Generated GraphQL (auto):

```graphql
type Contact {
  id: UUID!
  email: String!
  createdAt: DateTime!
  organization: ContactOrganization!
}

type ContactOrganization {
  id: UUID!
  name: String!
  code: String!
}

type Query {
  # Filtered by direct columns (FAST)
  contactsByEmail(email: String!): [Contact!]!
  contactsSince(createdAt: DateTime!): [Contact!]!
  
  # Filtered by FK (FAST)
  contactsByOrganization(organizationId: UUID!): [Contact!]!
  
  # Filtered by JSONB (SLOWER)
  contactsByOrgName(name: String!): [Contact!]!
}
```

---

## Files to Know

| File | Purpose |
|------|---------|
| `src/core/ast_models.py` | TableViewConfig, IncludeRelation definitions |
| `src/generators/schema/table_view_generator.py` | tv_ DDL generation |
| `src/generators/fraiseql/table_view_annotator.py` | FraiseQL annotation generation |
| `tests/unit/schema/test_table_view_generation.py` | Unit tests |
| `tests/integration/fraiseql/test_tv_annotations_e2e.py` | E2E tests |
| `entities/examples/review_with_table_views.yaml` | Working example |

---

## When to Use table_views

### Use (mode: auto/force)
- Entity has foreign keys
- Queries frequently filter by FK
- GraphQL needs related entity data
- Read queries much more common than writes

### Don't Use (mode: disable)
- Write-heavy table (SessionToken, AuditLog writes)
- No foreign keys + no hot-path queries
- Large JSONB would bloat storage

---

## Troubleshooting

### Issue: "tv_ not generated"
**Solution**: Check mode - default is `auto` which requires FKs. Use `mode: force` if no FKs.

### Issue: "Stale data in JSONB"
**Solution**: Ensure `refresh_table_view` step is in mutation. Must be explicit.

### Issue: "Queries still slow"
**Solution**: Check `extra_filter_columns` - if querying by unmapped column, add it there.

### Issue: "Storage bloat"
**Solution**: Use selective `include_relations` to limit JSONB size. Or use `mode: disable`.

---

## Summary Checklist

- [ ] Understand: tb_ (write) vs tv_ (read) distinction
- [ ] Know: Composition from tv_, not tb_ (for consistency)
- [ ] Use: include_relations for selective field inclusion
- [ ] Use: extra_filter_columns for hot-path optimization
- [ ] Know: Two-tier filtering (B-tree vs GIN)
- [ ] Know: FraiseQL auto-discovers from tv_ JSONB
- [ ] Remember: Must refresh tv_ explicitly in mutations
- [ ] Consider: Storage cost (~2x) vs query performance

---

**Status**: Ready for use in PrintOptim entities
**Example**: `specql/entities/examples/review_with_table_views.yaml`
