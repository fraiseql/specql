# Migration Patterns

> **Status**: ðŸš§ Documentation in Progress
>
> This page provides common migration patterns. Comprehensive documentation coming soon!

## Overview

This guide documents common patterns and strategies for migrating existing codebases and databases to SpecQL, covering typical scenarios you'll encounter when adopting SpecQL in existing projects.

## Coming Soon

Full documentation will cover:
- [ ] Incremental migration strategies
- [ ] Strangler fig pattern for gradual adoption
- [ ] Database schema migration patterns
- [ ] ORM to SpecQL migration
- [ ] API migration patterns
- [ ] Testing during migration
- [ ] Rollback strategies

## Common Migration Patterns

### Pattern 1: Greenfield Start
**When**: New project or new module in existing system

**Strategy**: Start with SpecQL from day one
```yaml
# Define your entities in SpecQL
entity: Customer
schema: sales
fields:
  name: text!
  email: email!
```

**Benefits**:
- No migration complexity
- Clean architecture from start
- Full SpecQL benefits immediately

---

### Pattern 2: Reverse Engineering Existing Schema
**When**: You have an existing database schema to migrate

**Strategy**: Use reverse engineering to generate SpecQL
```bash
# Generate SpecQL from existing SQL
specql reverse --source sql --path ./database/ --output entities/

# Review and refine generated YAML
# Then regenerate with improvements
specql generate entities/*.yaml
```

**Benefits**:
- Automated initial conversion
- Preserves existing schema structure
- Can incrementally improve generated YAML

**See**: [SQL Reverse Engineering](../reverse-engineering/sql.md)

---

### Pattern 3: Strangler Fig (Gradual Migration)
**When**: Large existing codebase, need gradual migration

**Strategy**: Run both systems side-by-side, gradually migrate
```
Phase 1: New features in SpecQL
â”œâ”€â”€ Keep existing code untouched
â”œâ”€â”€ New tables use SpecQL
â””â”€â”€ New APIs use SpecQL-generated functions

Phase 2: Migrate read paths
â”œâ”€â”€ Existing tables mapped to SpecQL entities
â”œâ”€â”€ Read queries use SpecQL
â””â”€â”€ Writes still use legacy code

Phase 3: Migrate write paths
â”œâ”€â”€ Actions replace legacy business logic
â”œâ”€â”€ Transactions through SpecQL
â””â”€â”€ Legacy code deprecated

Phase 4: Complete migration
â”œâ”€â”€ All tables managed by SpecQL
â”œâ”€â”€ Legacy code removed
â””â”€â”€ Full SpecQL benefits
```

**Timeline**: 3-12 months depending on codebase size

---

### Pattern 4: ORM to SpecQL Migration
**When**: Replacing Django, TypeORM, Prisma, etc.

**Strategy**: Map ORM models to SpecQL entities

**Django Example**:
```python
# Before: Django model
class Customer(models.Model):
    name = models.CharField(max_length=200)
    email = models.EmailField()
    created_at = models.DateTimeField(auto_now_add=True)
```

```yaml
# After: SpecQL entity
entity: Customer
schema: sales
fields:
  name: text!
  email: email!
# created_at auto-generated by SpecQL
```

**See**: [Python/Django Migration](../reverse-engineering/python.md)

---

### Pattern 5: Microservice Boundary Migration
**When**: Migrating specific microservices to SpecQL

**Strategy**: Migrate service-by-service
```
1. Choose lowest-dependency service
2. Reverse engineer its database
3. Generate SpecQL entities
4. Replace service implementation
5. Deploy new version
6. Move to next service
```

**Benefits**:
- Isolated risk per service
- Can roll back individual services
- Gradual team learning curve

---

### Pattern 6: Test-Driven Migration
**When**: High-risk migration, need confidence

**Strategy**: Write tests first, then migrate
```bash
# 1. Extract current behavior as tests
npm run test:extract-current-behavior

# 2. Reverse engineer to SpecQL
specql reverse --source sql --path ./schema/

# 3. Generate SpecQL schema
specql generate entities/*.yaml

# 4. Run tests against new schema
npm run test  # Should pass!

# 5. Refine YAML based on test failures
# Repeat until all tests pass
```

---

## Migration Checklist

### Pre-Migration
- [ ] Document existing schema and business logic
- [ ] Identify data dependencies and foreign keys
- [ ] Set up testing infrastructure
- [ ] Create backup and rollback plan
- [ ] Estimate migration timeline

### During Migration
- [ ] Use reverse engineering tools
- [ ] Validate generated YAML against existing schema
- [ ] Test data integrity
- [ ] Verify business logic correctness
- [ ] Monitor performance

### Post-Migration
- [ ] Remove legacy code
- [ ] Update documentation
- [ ] Train team on SpecQL patterns
- [ ] Monitor production behavior
- [ ] Optimize generated schema

## Migration Tools

### Reverse Engineering
```bash
# From SQL
specql reverse --source sql --path ./schema/ --output entities/

# From Python/Django
specql reverse --source python --path ./models/ --output entities/

# From Prisma
specql reverse --source prisma --path ./schema.prisma --output entities/
```

### Validation
```bash
# Validate generated YAML
specql validate entities/*.yaml

# Compare schemas (old vs new)
specql diff --old ./legacy/schema.sql --new entities/*.yaml
```

### Testing
```bash
# Generate test fixtures
specql test generate-fixtures entities/*.yaml

# Run migration tests
npm run test:migration
```

## Common Challenges

### Challenge 1: Complex Foreign Keys
**Problem**: Many circular dependencies

**Solution**: Use SpecQL's automatic FK resolution
```yaml
# SpecQL handles circular refs automatically
entity: Order
fields:
  customer: ref(Customer)

entity: Customer
fields:
  last_order: ref(Order)  # OK - circular ref
```

### Challenge 2: Legacy Naming Conventions
**Problem**: Existing tables don't follow trinity pattern

**Solution**: Use reverse engineering mapping
```bash
# Map legacy names to SpecQL conventions
specql reverse --source sql \
  --map-table "customers->Customer" \
  --map-pk "customer_id->pk_customer"
```

### Challenge 3: Complex Business Logic
**Problem**: Stored procedures with complex logic

**Solution**: Break into SpecQL actions incrementally
```yaml
# Migrate one procedure at a time
actions:
  - name: process_order
    steps:
      - validate: stock_available > 0
      - update: Inventory SET stock = stock - quantity
      - insert: Order { customer: $customer, items: $items }
```

## Related Documentation

- [SQL Reverse Engineering](../reverse-engineering/sql.md) - SQL migration
- [Python Reverse Engineering](../reverse-engineering/python.md) - Django/Python migration
- [Migration Overview](../index.md) - Migration guide home
- [Testing Guide](../../07_advanced/testing.md) - Testing strategies

## Questions?

If you need migration help:
- Check [Reverse Engineering docs](../reverse-engineering/sql.md)
- See [Migration Overview](../index.md) for strategies
- Open an issue describing your migration scenario
- Join community discussions for migration advice

---

*Last Updated*: 2025-11-20
