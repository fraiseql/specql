# The Trinity Pattern: Three Identifiers for Optimal Performance

> **Why SpecQL uses three IDs per entity and when to use each one**

## Overview

Every SpecQL entity automatically gets **three identifiers** instead of one. This isn't redundant—each serves a different purpose in your system architecture.

## The Three Identifiers

### 1. Primary Key (`pk_*`) - Database Performance

```sql
pk_contact INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY
```

**Purpose**: Database joins, indexes, and foreign key relationships
**Type**: INTEGER (auto-incrementing)
**Use When**: Internal database operations, foreign keys, performance-critical queries

**Example**:
```sql
-- Foreign key reference (fast joins)
fk_organization INTEGER REFERENCES crm.tb_organization(pk_organization);

-- Index for performance
CREATE INDEX idx_contact_org ON crm.tb_contact(fk_organization);
```

### 2. ID (`id`) - API Stability

```sql
id UUID DEFAULT gen_random_uuid() NOT NULL
```

**Purpose**: Public API identifiers that never change
**Type**: UUID (globally unique)
**Use When**: API endpoints, frontend code, external integrations

**Example**:
```typescript
// Frontend API call (stable identifier)
const contact = await api.getContact("550e8400-e29b-41d4-a716-446655440000");

// GraphQL mutation
mutation UpdateContact($id: UUID!, $input: UpdateContactInput!) {
  updateContact(id: $id, input: $input) {
    id
    firstName
    lastName
  }
}
```

### 3. Identifier (`identifier`) - Human Readability

```sql
identifier TEXT NOT NULL
```

**Purpose**: Human-friendly names for URLs, displays, and debugging
**Type**: TEXT (custom format)
**Use When**: User interfaces, URLs, logging, customer support

**Example**:
```sql
-- URL-friendly identifier
/contact/john-doe-123

-- Display in UI
"Contact: john.doe@example.com"

-- Support debugging
"Processing contact identifier: contact_123"
```

## Why Three Identifiers?

Different parts of your system have different requirements:

| Concern | Solution | Identifier Used |
|---------|----------|-----------------|
| **Database Performance** | Integer joins are fastest | `pk_*` |
| **API Stability** | UUIDs never leak sequence info | `id` |
| **Human Experience** | Readable names in URLs/UI | `identifier` |

## Real-World Example

```sql
-- Trinity pattern in action
CREATE TABLE crm.tb_contact (
    -- Database performance (joins, indexes)
    pk_contact INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,

    -- API stability (frontend/backend communication)
    id UUID DEFAULT gen_random_uuid() NOT NULL,

    -- Human readability (URLs, support, debugging)
    identifier TEXT NOT NULL,

    -- Business data
    email TEXT NOT NULL,
    first_name TEXT NOT NULL,
    last_name TEXT NOT NULL,

    -- Foreign keys use integers for performance
    fk_organization INTEGER,

    -- Audit fields
    created_at TIMESTAMPTZ DEFAULT now(),
    -- ... etc
);
```

## Helper Functions

SpecQL generates helper functions for ID conversion:

```sql
-- Get pk from id (UUID → INTEGER)
CREATE FUNCTION crm.contact_pk(id UUID) RETURNS INTEGER;

-- Get id (UUID) from pk (INTEGER → UUID)
CREATE FUNCTION crm.contact_id(pk INTEGER) RETURNS UUID;

-- Get identifier from id (UUID → TEXT)
CREATE FUNCTION crm.contact_identifier(id UUID) RETURNS TEXT;
```

**Usage**:
```sql
-- API receives UUID, need to query by pk
SELECT * FROM crm.contact WHERE pk_contact = crm.contact_pk($1);

-- Database returns pk, API needs UUID
SELECT crm.contact_id(pk_contact) as id FROM crm.contact;
```

## When to Use Each Identifier

### Use `pk_*` (Primary Key) For:
- Foreign key relationships
- Database joins and indexes
- Internal business logic
- Performance-critical queries

### Use `id` (UUID) For:
- REST API endpoints (`/api/contacts/{id}`)
- GraphQL queries/mutations
- Frontend state management
- External API integrations
- Anywhere exposed to clients

### Use `identifier` For:
- URL slugs (`/contacts/john-doe`)
- Display names in UI
- Logging and debugging
- Customer support references
- Human-readable exports

## Migration from Single ID Systems

**Traditional Approach** (problematic):
```sql
-- Single ID approach
CREATE TABLE contacts (
    id SERIAL PRIMARY KEY,  -- Used for everything!
    email TEXT,
    -- ...
);
```

**Problems**:
- IDs are sequential (security risk)
- Foreign keys are large (performance impact)
- No human-readable identifiers
- Hard to change later

**SpecQL Trinity Approach** (optimal):
```sql
-- Three IDs, each optimized for its use case
CREATE TABLE crm.tb_contact (
    pk_contact INTEGER PRIMARY KEY,  -- Joins
    id UUID NOT NULL,                -- APIs
    identifier TEXT NOT NULL,        -- Humans
    -- ...
);
```

## Best Practices

### API Design
```typescript
// ✅ Good: Use UUIDs in APIs
interface Contact {
  id: string;        // UUID for API stability
  identifier: string; // Human-readable display
  // No pk_* exposed
}
```

### Database Queries
```sql
-- ✅ Good: Use pk for joins
SELECT c.*, o.name as organization_name
FROM crm.contact c
JOIN crm.organization o ON o.pk_organization = c.fk_organization
WHERE c.pk_contact = $1;
```

### URL Design
```typescript
// ✅ Good: Use identifiers in URLs
const contactUrl = `/contacts/${contact.identifier}`;
// Result: /contacts/john-doe-123
```

## Performance Benefits

| Operation | Single ID | Trinity Pattern | Improvement |
|-----------|-----------|-----------------|-------------|
| Foreign Key Join | 8 bytes (BIGINT) | 4 bytes (INTEGER) | 50% smaller |
| Index Size | Larger | Smaller | Faster queries |
| API Security | Sequential IDs | Random UUIDs | No enumeration |
| Human Usability | Numeric IDs | Readable names | Better UX |

## Summary

The Trinity Pattern gives you the best of all worlds:
- **Performance**: Integer primary keys for database efficiency
- **Stability**: UUIDs for API reliability
- **Usability**: Human-readable identifiers for great UX

SpecQL handles all the complexity automatically—you just define your business fields.

## Next Steps

- [Define your first entity](../01_getting-started/first-entity.md)
- [Create relationships between entities](../05_guides/relationships.md)
- [Set up multi-tenancy](../05_guides/multi-tenancy.md)

---

**Questions?** The Trinity Pattern is fundamental to SpecQL's architecture. It might seem complex at first, but it eliminates many real-world problems with traditional ID schemes.</content>
</xai:function_call