# Team E: CLI & Documentation - Authentication Context Implementation

**Extracted from**: `auth_context_naming.md`
**Priority**: üü° MEDIUM (Documentation)
**Timeline**: Week 3, Day 3

---

## üéØ Mission

Update documentation and examples to reflect `auth_tenant_id` / `auth_user_id` naming convention.

---

## üìã Changes Required

### 1. Example Entities
Update all example YAML ‚Üí SQL outputs to show `auth_*` naming

### 2. User Documentation
Document that generated functions receive authentication context automatically

### 3. CLI Help Text
Update any CLI messages that reference function parameters

---

## üìù Documentation to Create/Update

### File: `docs/guides/authentication.md` (NEW)

```markdown
# Authentication Context

All generated PostgreSQL functions automatically receive authentication context parameters.

## Standard Parameters

Every generated function includes:

```sql
CREATE FUNCTION schema.action_name(
    -- Business parameters (from GraphQL input)
    p_entity_id UUID,
    p_email TEXT,
    -- etc.

    -- Authentication context (auto-injected by framework)
    auth_tenant_id TEXT DEFAULT NULL,
    auth_user_id UUID DEFAULT NULL
)
```

## What Are These Parameters?

### `auth_tenant_id` (TEXT)
- **Source**: Extracted from authentication token (JWT, API key, etc.)
- **Purpose**: Multi-tenant isolation - ensures users only access their tenant's data
- **Example**: `'tenant-abc-123'`

### `auth_user_id` (UUID)
- **Source**: Extracted from authentication token
- **Purpose**: Audit trail - tracks who performed actions
- **Example**: `'550e8400-e29b-41d4-a716-446655440000'`

## How It Works

### 1. Client Makes GraphQL Request

```graphql
mutation {
  qualifyLead(contactId: "uuid-here") {
    success
  }
}
```

**Note**: Client does NOT provide `auth_tenant_id` or `auth_user_id` - these come from authentication!

### 2. FraiseQL Resolver Extracts Auth Context

```javascript
// FraiseQL auto-generated resolver
async function qualifyLead(parent, args, context) {
  // Extract from JWT claims
  const { tenantId, userId } = context.auth;

  // Call database function with auth context
  return db.query(
    'SELECT crm.qualify_lead($1, $2, $3)',
    [args.contactId, tenantId, userId]
  );
}
```

### 3. Database Function Uses Auth Context

```sql
CREATE FUNCTION crm.qualify_lead(
    p_contact_id UUID,
    auth_tenant_id TEXT,
    auth_user_id UUID
)
RETURNS jsonb AS $$
BEGIN
    -- Tenant isolation
    IF auth_tenant_id IS NOT NULL THEN
        PERFORM check_tenant_access(p_contact_id, auth_tenant_id);
    END IF;

    -- Business logic...
    UPDATE crm.tb_contact
    SET status = 'qualified',
        updated_by = auth_user_id,  -- Audit trail
        updated_at = now()
    WHERE ...;

    RETURN jsonb_build_object('success', true);
END;
$$ LANGUAGE plpgsql;
```

## Authentication Methods Supported

The `auth_*` naming is method-agnostic and works with:
- ‚úÖ **JWT tokens** (most common)
- ‚úÖ **API keys**
- ‚úÖ **OAuth tokens**
- ‚úÖ **Session-based auth**
- ‚úÖ **mTLS client certificates**

The GraphQL resolver is responsible for extracting tenant/user IDs from the authentication method and passing them to database functions.

## Security: Why Clients Can't Set These

Authentication context parameters are **NEVER exposed in GraphQL input schemas**:

```graphql
# GraphQL schema (generated by FraiseQL)
input QualifyLeadInput {
  contactId: UUID!
  # auth_tenant_id NOT here - would be a security vulnerability!
  # auth_user_id NOT here - would allow impersonation!
}
```

**Why**: If clients could set these values, they could:
- ‚ùå Access other tenants' data (set `auth_tenant_id` to another tenant)
- ‚ùå Impersonate other users (set `auth_user_id` to admin)
- ‚ùå Poison audit trails (pretend to be someone else)

**Solution**: These values come from **server-verified authentication tokens**, not client input.

## For SpecQL Users

When you write SpecQL:

```yaml
actions:
  - name: qualify_lead
    steps:
      - validate: status = 'lead'
      - update: Contact SET status = 'qualified'
```

**You don't need to think about authentication** - the framework handles it:
- ‚úÖ Adds `auth_tenant_id` / `auth_user_id` parameters automatically
- ‚úÖ Uses them for tenant isolation and audit trails
- ‚úÖ Ensures they're injected securely (not client-controlled)

## FAQ

### Q: Can I disable auth context for a specific function?
A: Not recommended. All functions should validate tenant access. If your function truly doesn't need auth context (e.g., public read-only), the parameters will be NULL and can be ignored.

### Q: What if my auth system uses different claim names?
A: Configure your GraphQL resolver to map your claims to `tenantId` / `userId`. The database functions expect these standard names.

### Q: Can I add custom context parameters?
A: Yes! Extend the framework by adding new context params (e.g., `auth_session_id`, `auth_ip_address`) and update the metadata generator to include them in `context_params`.

### Q: What if `auth_user_id` is NULL?
A: Functions should validate required auth context. For example:
```sql
IF auth_user_id IS NULL THEN
    RAISE EXCEPTION 'authentication_required';
END IF;
```

---

## See Also
- [FraiseQL Integration](./fraiseql_integration.md)
- [Security Best Practices](./security.md)
- [Multi-Tenant Isolation](./multi_tenancy.md)
```

---

### File: `docs/guides/function_reference.md` (UPDATE)

Update function signature examples:

```markdown
# Function Reference

## Standard Function Signature

All generated functions follow this pattern:

```sql
CREATE FUNCTION {schema}.{action_name}(
    -- Business parameters (from SpecQL action)
    p_{param1} TYPE,
    p_{param2} TYPE,

    -- Authentication context (auto-injected)
    auth_tenant_id TEXT DEFAULT NULL,
    auth_user_id UUID DEFAULT NULL
)
RETURNS jsonb AS $$
DECLARE
    -- Variables
BEGIN
    -- Tenant isolation
    IF auth_tenant_id IS NOT NULL THEN
        PERFORM check_tenant_access(..., auth_tenant_id);
    END IF;

    -- Business logic

    -- Audit trail
    UPDATE ... SET updated_by = auth_user_id, ...;

    RETURN jsonb_build_object('success', true);
END;
$$ LANGUAGE plpgsql;
```

## Parameters

### Business Parameters (`p_*`)
- Come from GraphQL mutation input
- Defined in your SpecQL action
- Client-provided values

### Authentication Context (`auth_*`)
- **NOT** from GraphQL input (security!)
- Injected by FraiseQL resolver from JWT/API key
- Server-verified, trusted values

See [Authentication Context](./authentication.md) for details.
```

---

### File: `entities/examples/contact.yaml` (UPDATE COMMENTS)

```yaml
# entities/examples/contact.yaml
entity: Contact
schema: crm

fields:
  email: text
  company: ref(Company)
  status: enum(lead, qualified, customer)

actions:
  - name: qualify_lead
    steps:
      - validate: status = 'lead'
      - update: Contact SET status = 'qualified'

# Generated SQL includes:
# CREATE FUNCTION crm.qualify_lead(
#     p_contact_id UUID,
#     auth_tenant_id TEXT DEFAULT NULL,  -- Auto-injected from JWT
#     auth_user_id UUID DEFAULT NULL     -- Auto-injected from JWT
# )
# RETURNS jsonb AS $$
# BEGIN
#     -- Tenant check
#     IF auth_tenant_id IS NOT NULL THEN
#         PERFORM crm.check_tenant_access(p_contact_id, auth_tenant_id);
#     END IF;
#
#     -- Validation
#     IF (SELECT status FROM crm.tb_contact WHERE id = p_contact_id) != 'lead' THEN
#         RAISE EXCEPTION 'validation_failed';
#     END IF;
#
#     -- Update with audit trail
#     UPDATE crm.tb_contact
#     SET status = 'qualified',
#         updated_by = auth_user_id,  -- From JWT
#         updated_at = now()
#     WHERE id = p_contact_id;
#
#     RETURN jsonb_build_object('success', true);
# END;
# $$ LANGUAGE plpgsql;
```

---

### File: `src/cli/generate.py` (UPDATE HELP TEXT)

```python
# src/cli/generate.py

def generate_command():
    """
    Generate PostgreSQL migration from SpecQL entity definition.

    Output includes:
    - Table with Trinity pattern (pk_*, id, identifier)
    - Action functions with authentication context (auth_tenant_id, auth_user_id)
    - FraiseQL metadata for GraphQL auto-generation
    """
    # ... implementation

def show_generation_summary(entity, sql_lines):
    """Show summary of generated SQL"""
    print(f"‚úì Generated {sql_lines} lines of SQL for {entity.name}")
    print(f"  - Table: {entity.schema}.tb_{entity.name.lower()}")
    print(f"  - Actions: {len(entity.actions)} functions")
    print(f"  - Authentication: Includes auth_tenant_id/auth_user_id context")
    print(f"  - FraiseQL: Metadata annotations for GraphQL")
```

---

## üìÅ Files to Create/Modify

```
docs/guides/
‚îú‚îÄ‚îÄ authentication.md           # NEW: Comprehensive auth context guide
‚îî‚îÄ‚îÄ function_reference.md       # UPDATE: Function signature examples

entities/examples/
‚îú‚îÄ‚îÄ contact.yaml               # UPDATE: Add comments showing generated SQL
‚îî‚îÄ‚îÄ machine_item.yaml          # UPDATE: Add comments showing generated SQL

src/cli/
‚îî‚îÄ‚îÄ generate.py                # UPDATE: Help text and output messages

README.md                       # UPDATE: Mention auth context in features
```

---

## ‚úÖ Acceptance Criteria

- [ ] `docs/guides/authentication.md` created with comprehensive guide
- [ ] `docs/guides/function_reference.md` updated with `auth_*` examples
- [ ] Example YAML files have comments showing generated SQL with `auth_*`
- [ ] CLI help text mentions authentication context
- [ ] README.md mentions secure auth context handling
- [ ] No references to old `input_*` naming in documentation

---

## üéØ Documentation Principles

### 1. Security-First
Explain **why** auth context isn't in GraphQL input (security vulnerability)

### 2. User-Friendly
SpecQL users don't need to think about auth - it's automatic

### 3. Clear Examples
Show complete flow: GraphQL ‚Üí Resolver ‚Üí PostgreSQL

### 4. Future-Proof
Mention auth method agnostic (JWT, API keys, OAuth, etc.)

---

## üìä Documentation Structure

```
Authentication Documentation
‚îú‚îÄ‚îÄ What: auth_tenant_id / auth_user_id
‚îú‚îÄ‚îÄ Why: Security, audit trails, multi-tenancy
‚îú‚îÄ‚îÄ How: JWT ‚Üí Resolver ‚Üí PostgreSQL
‚îú‚îÄ‚îÄ Security: Why clients can't set these
‚îú‚îÄ‚îÄ FAQ: Common questions
‚îî‚îÄ‚îÄ See Also: Related docs
```

---

## üîÑ Review Checklist

Before finalizing documentation:

- [ ] All code examples use `auth_*` (not `input_*`)
- [ ] Security implications clearly explained
- [ ] Flow diagrams show complete pipeline
- [ ] Examples are copy-pasteable and accurate
- [ ] FAQ addresses common concerns
- [ ] Links to FraiseQL integration docs
- [ ] Mentions future auth method support

---

**Timeline**: Implement by end of Week 3, Day 3
**Dependency**: After Teams B, C, D complete implementation
**Purpose**: Help users understand secure authentication handling
