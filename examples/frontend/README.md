# Frontend Code Generation Examples

This directory contains examples of the frontend code generated by the SpecQL frontend generators.

## Generated Files

When you run the frontend generators, they create the following files:

### `mutation-impacts.json`
Contains metadata about mutation impacts for frontend cache management.

```json
{
  "version": "1.0.0",
  "description": "Mutation impact metadata for frontend cache management",
  "mutations": {
    "Contact.create_contact": {
      "entity": "Contact",
      "action": "create_contact",
      "operationType": "CREATE",
      "impacts": {
        "hasPrimaryImpact": true,
        "affectedEntities": ["Contact"]
      }
    }
  }
}
```

### `types.ts`
TypeScript type definitions for entities and GraphQL operations.

```typescript
// Entity interfaces
export interface Contact {
  id: UUID;
  first_name: string;
  last_name: string;
  email?: string;
  created_at: DateTime;
}

// Mutation input/output types
export interface CreateContactInput {
  first_name: string;
  last_name: string;
  email?: string;
}

export interface CreateContactSuccess {
  contact: Contact;
  message: string;
}

export type CreateContactResult = CreateContactSuccess | CreateContactError;
```

### `hooks.ts`
Apollo Client React hooks for GraphQL operations.

```typescript
// Query hooks
export const useGetContact = (id: string) => {
  return useQuery<Contact>(GET_CONTACT_QUERY, {
    variables: { id },
    skip: !id,
  });
};

// Mutation hooks
export const useCreateContact = () => {
  return useMutation<
    { createContact: MutationResult<CreateContactResult> },
    CreateContactInput
  >(CREATE_CONTACT_MUTATION, {
    update: (cache, { data }) => {
      // Automatic cache updates
    },
  });
};
```

### `job-monitoring-types.ts` (NEW)
TypeScript types for job monitoring and execution tracking.

```typescript
// Job execution status and types
export enum JobStatus {
  PENDING = 'pending',
  RUNNING = 'running',
  COMPLETED = 'completed',
  FAILED = 'failed',
  CANCELLED = 'cancelled',
}

export enum ExecutionType {
  HTTP = 'http',
  SHELL = 'shell',
  DOCKER = 'docker',
  SERVERLESS = 'serverless',
}

// Job record interface
export interface JobRecord {
  id: UUID;
  status: JobStatus;
  execution_type: ExecutionType;
  service_name: string;
  operation: string;
  // ... additional fields
}

// Resource usage and security types
export interface ResourceUsage {
  cpu_usage_percent?: number;
  memory_mb?: number;
  duration_seconds?: number;
  // ... additional metrics
}

export interface SecurityContext {
  tenant_id_ref?: string;
  policy: {
    allowed_commands?: string[];
    resource_limits?: object;
  };
}
```

### `job-monitoring-hooks.ts` (NEW)
Apollo Client React hooks for job monitoring.

```typescript
// Job status monitoring
export const useJobStatus = (jobId: string) => {
  return useQuery<{ job: JobRecord }>(GET_JOB_STATUS_QUERY, {
    variables: { id: jobId },
    pollInterval: 2000, // Poll for status updates
  });
};

// Jobs by execution type
export const useJobsByExecutionType = (
  executionType: ExecutionType,
  filter?: JobFilter,
  pagination?: JobPaginationInput
) => {
  return useQuery<{ jobsByExecutionType: JobQueryResult }>(
    GET_JOBS_BY_EXECUTION_TYPE_QUERY,
    { variables: { executionType, filter, pagination } }
  );
};

// Job monitoring dashboard
export const useJobMonitoringDashboard = (
  tenantId?: string,
  since?: string,
  limit: number = 20
) => {
  return useQuery<{ jobMonitoringDashboard: JobMonitoringDashboard }>(
    GET_JOB_MONITORING_DASHBOARD_QUERY,
    {
      variables: { tenantId, since, limit },
      pollInterval: 30000, // Refresh every 30 seconds
    }
  );
};

// Job management mutations
export const useCancelJob = () => {
  return useMutation(CANCEL_JOB_MUTATION, {
    onCompleted: (data) => {
      if (data.cancelJob.success) {
        console.log('Job cancelled successfully');
      }
    },
  });
};
```

### `job-monitoring-components.tsx` (NEW)
Example React components for job monitoring UI.

```typescript
// Job status monitor component
export const JobStatusMonitor: React.FC<{ jobId: string }> = ({ jobId }) => {
  const { data, loading } = useJobStatus(jobId);

  if (loading) return <div>Loading...</div>;

  return (
    <div className="job-monitor">
      <JobStatusBadge status={data?.job.status} />
      <ExecutionTypeBadge executionType={data?.job.execution_type} />
      {/* Additional job details */}
    </div>
  );
};

// Job monitoring dashboard
export const JobMonitoringDashboard: React.FC = () => {
  const { data } = useJobMonitoringDashboard();

  return (
    <div className="dashboard">
      {/* Statistics cards */}
      {/* Execution type breakdown */}
      {/* Recent jobs list */}
      {/* Performance metrics */}
    </div>
  );
};
```

### `mutations.md`
Comprehensive API documentation for all mutations.

## Usage

### CLI Integration

Generate frontend code alongside SQL migrations:

```bash
# Generate SQL + frontend code (includes job monitoring)
python -m src.cli.generate entities entities/examples/*.yaml \
  --output-dir db/schema \
  --output-frontend frontend/generated \
  --with-impacts \
  --with-job-monitoring

# This creates:
# - db/schema/10_tables/contact.sql (SQL migrations)
# - frontend/generated/mutation-impacts.json
# - frontend/generated/types.ts
# - frontend/generated/hooks.ts
# - frontend/generated/mutations.md
# - frontend/generated/job-monitoring-types.ts (NEW)
# - frontend/generated/job-monitoring-hooks.ts (NEW)
```

### Programmatic Usage

```python
from src.generators.frontend import (
    MutationImpactsGenerator,
    TypeScriptTypesGenerator,
    ApolloHooksGenerator,
    MutationDocsGenerator,
    JobMonitoringTypesGenerator,
    JobMonitoringHooksGenerator,
)
from pathlib import Path

# Load your entities
entities = [...]  # Your parsed Entity objects

output_dir = Path("frontend/generated")

# Generate all frontend code
MutationImpactsGenerator(output_dir).generate_impacts(entities)
TypeScriptTypesGenerator(output_dir).generate_types(entities)
ApolloHooksGenerator(output_dir).generate_hooks(entities)
MutationDocsGenerator(output_dir).generate_docs(entities)

# Generate job monitoring code (NEW)
JobMonitoringTypesGenerator(output_dir).generate_types()
JobMonitoringHooksGenerator(output_dir).generate_hooks()
```

## Integration with Frontend Applications

### React/Apollo Setup

1. **Install dependencies:**
```bash
npm install @apollo/client graphql
```

2. **Configure Apollo Client:**
```typescript
import { ApolloClient, InMemoryCache } from '@apollo/client';

const client = new ApolloClient({
  uri: 'http://localhost:4000/graphql',
  cache: new InMemoryCache(),
});
```

3. **Use generated hooks in components:**
```typescript
import { useCreateContact, useGetContacts } from './generated/hooks';
import type { CreateContactInput } from './generated/types';

function ContactForm() {
  const [createContact, { loading, error }] = useCreateContact();
  const { data: contactsData } = useGetContacts();

  const handleSubmit = async (input: CreateContactInput) => {
    const result = await createContact({
      variables: { input },
    });

    if (result.data?.createContact.success) {
      console.log('Contact created!');
    }
  };

  return (
    <form onSubmit={handleSubmit}>
      {/* Form fields */}
      <button disabled={loading}>
        {loading ? 'Creating...' : 'Create Contact'}
      </button>
    </form>
  );
}
```

### Cache Management

The generated hooks include automatic cache updates:

- **Creates:** Add new items to list caches
- **Updates:** Modify existing items in cache
- **Deletes:** Remove items and clean up references

For advanced cache management, use the `mutation-impacts.json`:

```typescript
import impacts from './mutation-impacts.json';

// Check what entities are affected by a mutation
const mutationImpact = impacts.mutations['Contact.create_contact'];
console.log('Affected entities:', mutationImpact.impacts.affectedEntities);
```

## Job Monitoring Integration

The job monitoring features provide comprehensive tools for tracking and managing asynchronous job execution across different execution types (HTTP, Shell, Docker, Serverless).

### Setting Up Job Monitoring

1. **Generate job monitoring code:**
```typescript
import {
  JobMonitoringTypesGenerator,
  JobMonitoringHooksGenerator,
} from './generators/frontend';

const outputDir = Path('frontend/generated');
JobMonitoringTypesGenerator(outputDir).generate_types();
JobMonitoringHooksGenerator(outputDir).generate_hooks();
```

2. **Import generated types and hooks:**
```typescript
import {
  useJobStatus,
  useJobsByExecutionType,
  useJobMonitoringDashboard,
  JobRecord,
  JobStatus,
  ExecutionType,
} from './generated/job-monitoring-hooks';
import {
  JobStatusBadge,
  ExecutionTypeBadge,
  JobMonitoringDashboard,
} from './generated/job-monitoring-components';
```

### Job Status Monitoring

Monitor individual job execution in real-time:

```typescript
function JobDetailView({ jobId }: { jobId: string }) {
  const { data, loading, error } = useJobStatus(jobId);

  if (loading) return <div>Loading job status...</div>;
  if (error) return <div>Error: {error.message}</div>;

  const job = data?.job;
  if (!job) return <div>Job not found</div>;

  return (
    <div className="job-detail">
      <div className="flex items-center space-x-2 mb-4">
        <JobStatusBadge status={job.status} />
        <ExecutionTypeBadge executionType={job.execution_type} />
        <span className="font-medium">
          {job.service_name}.{job.operation}
        </span>
      </div>

      <div className="grid grid-cols-2 gap-4">
        <div>
          <label className="text-sm font-medium">Started</label>
          <div>{job.started_at ? new Date(job.started_at).toLocaleString() : 'Not started'}</div>
        </div>
        <div>
          <label className="text-sm font-medium">Duration</label>
          <div>
            {job.started_at && job.completed_at
              ? `${Math.round((new Date(job.completed_at).getTime() - new Date(job.started_at).getTime()) / 1000)}s`
              : job.started_at
                ? `${Math.round((Date.now() - new Date(job.started_at).getTime()) / 1000)}s (running)`
                : 'N/A'
            }
          </div>
        </div>
      </div>

      {job.error_message && (
        <div className="mt-4 p-3 bg-red-50 border border-red-200 rounded">
          <h4 className="text-red-800 font-medium">Error</h4>
          <p className="text-red-700 text-sm">{job.error_message}</p>
        </div>
      )}

      {job.resource_usage && (
        <div className="mt-4">
          <h4 className="font-medium mb-2">Resource Usage</h4>
          <div className="grid grid-cols-3 gap-4 text-sm">
            {job.resource_usage.cpu_usage_percent && (
              <div>CPU: {job.resource_usage.cpu_usage_percent.toFixed(1)}%</div>
            )}
            {job.resource_usage.memory_mb && (
              <div>Memory: {job.resource_usage.memory_mb}MB</div>
            )}
            {job.resource_usage.duration_seconds && (
              <div>Duration: {job.resource_usage.duration_seconds.toFixed(1)}s</div>
            )}
          </div>
        </div>
      )}
    </div>
  );
}
```

### Job Monitoring Dashboard

Create comprehensive dashboards for job monitoring:

```typescript
function App() {
  return (
    <div className="app">
      <header className="bg-white shadow">
        <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
          <h1 className="text-2xl font-bold text-gray-900 py-4">
            Job Monitoring Dashboard
          </h1>
        </div>
      </header>

      <main className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8">
        <JobMonitoringDashboard />
      </main>
    </div>
  );
}
```

### Execution Type Filtering

Filter and monitor jobs by execution type:

```typescript
function ExecutionTypeMonitor() {
  const [selectedType, setSelectedType] = useState<ExecutionType>(ExecutionType.HTTP);

  const { data, loading } = useJobsByExecutionType(selectedType, {}, { limit: 50 });

  return (
    <div className="execution-monitor">
      <div className="mb-4">
        <label className="block text-sm font-medium mb-2">Execution Type</label>
        <select
          value={selectedType}
          onChange={(e) => setSelectedType(e.target.value as ExecutionType)}
          className="border border-gray-300 rounded px-3 py-2"
        >
          {Object.values(ExecutionType).map((type) => (
            <option key={type} value={type}>
              {EXECUTION_TYPE_METADATA[type].displayName}
            </option>
          ))}
        </select>
      </div>

      {loading ? (
        <div>Loading jobs...</div>
      ) : (
        <div className="space-y-2">
          {data?.jobsByExecutionType.jobs.map((job) => (
            <div key={job.id} className="flex items-center justify-between p-3 bg-gray-50 rounded">
              <div className="flex items-center space-x-3">
                <JobStatusBadge status={job.status} />
                <div>
                  <div className="font-medium">{job.identifier}</div>
                  <div className="text-sm text-gray-600">
                    {job.service_name}.{job.operation}
                  </div>
                </div>
              </div>
              <div className="text-sm text-gray-500">
                {new Date(job.created_at).toLocaleString()}
              </div>
            </div>
          ))}
        </div>
      )}
    </div>
  );
}
```

### Job Management Actions

Handle job lifecycle operations:

```typescript
function JobActions({ jobId }: { jobId: string }) {
  const [cancelJob, { loading: cancelling }] = useCancelJob();
  const [retryJob, { loading: retrying }] = useRetryJob();

  const handleCancel = async () => {
    if (window.confirm('Cancel this job?')) {
      await cancelJob({
        variables: {
          input: { id: jobId, reason: 'User cancelled' }
        }
      });
    }
  };

  const handleRetry = async () => {
    if (window.confirm('Retry this job?')) {
      await retryJob({
        variables: { id: jobId }
      });
    }
  };

  return (
    <div className="flex space-x-2">
      <button
        onClick={handleCancel}
        disabled={cancelling}
        className="px-3 py-1 bg-red-600 text-white rounded hover:bg-red-700 disabled:opacity-50"
      >
        {cancelling ? 'Cancelling...' : 'Cancel Job'}
      </button>

      <button
        onClick={handleRetry}
        disabled={retrying}
        className="px-3 py-1 bg-blue-600 text-white rounded hover:bg-blue-700 disabled:opacity-50"
      >
        {retrying ? 'Retrying...' : 'Retry Job'}
      </button>
    </div>
  );
}
```

## File Structure

```
frontend/
├── generated/           # Auto-generated files
│   ├── mutation-impacts.json
│   ├── types.ts
│   ├── hooks.ts
│   ├── mutations.md
│   ├── job-monitoring-types.ts      # NEW: Job monitoring types
│   ├── job-monitoring-hooks.ts      # NEW: Job monitoring hooks
│   └── job-monitoring-components.tsx # NEW: Example UI components
├── components/          # Your components
│   ├── ContactForm.tsx
│   └── JobMonitor.tsx   # NEW: Your job monitoring components
└── lib/
    ├── apollo.ts        # Apollo client setup
    └── job-monitoring.ts # NEW: Job monitoring utilities
```

## Best Practices

1. **Regenerate after schema changes:** Always regenerate frontend code when you modify entity definitions.

2. **Type safety:** Use the generated TypeScript types throughout your application for full type safety.

3. **Cache awareness:** Leverage the automatic cache updates provided by the generated hooks.

4. **Error handling:** Check mutation results and handle errors appropriately.

5. **Documentation:** Use the generated `mutations.md` as API documentation for your frontend team.

6. **Job monitoring integration:** Use the job monitoring hooks for real-time status tracking of asynchronous operations.

7. **Execution type awareness:** Design UI components that adapt to different execution types (HTTP, Shell, Docker, Serverless).

8. **Resource monitoring:** Display resource usage information to help users understand job performance and costs.

9. **Real-time updates:** Use polling or subscriptions for job status updates based on your performance requirements.

10. **Error boundaries:** Implement error boundaries around job monitoring components to handle GraphQL errors gracefully.

## Troubleshooting

### Import Errors
If you get import errors, ensure the generated files are in your TypeScript path:

```json
// tsconfig.json
{
  "compilerOptions": {
    "baseUrl": ".",
    "paths": {
      "@generated/*": ["frontend/generated/*"]
    }
  }
}
```

### Cache Issues
If cache updates aren't working as expected, check the mutation impacts configuration and ensure your GraphQL server follows the expected patterns.

### Type Mismatches
If generated types don't match your GraphQL schema, ensure your SpecQL entity definitions are accurate and up-to-date.