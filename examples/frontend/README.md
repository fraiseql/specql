# Frontend Code Generation Examples

This directory contains examples of the frontend code generated by the SpecQL frontend generators.

## Generated Files

When you run the frontend generators, they create the following files:

### `mutation-impacts.json`
Contains metadata about mutation impacts for frontend cache management.

```json
{
  "version": "1.0.0",
  "description": "Mutation impact metadata for frontend cache management",
  "mutations": {
    "Contact.create_contact": {
      "entity": "Contact",
      "action": "create_contact",
      "operationType": "CREATE",
      "impacts": {
        "hasPrimaryImpact": true,
        "affectedEntities": ["Contact"]
      }
    }
  }
}
```

### `types.ts`
TypeScript type definitions for entities and GraphQL operations.

```typescript
// Entity interfaces
export interface Contact {
  id: UUID;
  first_name: string;
  last_name: string;
  email?: string;
  created_at: DateTime;
}

// Mutation input/output types
export interface CreateContactInput {
  first_name: string;
  last_name: string;
  email?: string;
}

export interface CreateContactSuccess {
  contact: Contact;
  message: string;
}

export type CreateContactResult = CreateContactSuccess | CreateContactError;
```

### `hooks.ts`
Apollo Client React hooks for GraphQL operations.

```typescript
// Query hooks
export const useGetContact = (id: string) => {
  return useQuery<Contact>(GET_CONTACT_QUERY, {
    variables: { id },
    skip: !id,
  });
};

// Mutation hooks
export const useCreateContact = () => {
  return useMutation<
    { createContact: MutationResult<CreateContactResult> },
    CreateContactInput
  >(CREATE_CONTACT_MUTATION, {
    update: (cache, { data }) => {
      // Automatic cache updates
    },
  });
};
```

### `mutations.md`
Comprehensive API documentation for all mutations.

## Usage

### CLI Integration

Generate frontend code alongside SQL migrations:

```bash
# Generate SQL + frontend code
python -m src.cli.generate entities entities/examples/*.yaml \
  --output-dir db/schema \
  --output-frontend frontend/generated \
  --with-impacts

# This creates:
# - db/schema/10_tables/contact.sql (SQL migrations)
# - frontend/generated/mutation-impacts.json
# - frontend/generated/types.ts
# - frontend/generated/hooks.ts
# - frontend/generated/mutations.md
```

### Programmatic Usage

```python
from src.generators.frontend import (
    MutationImpactsGenerator,
    TypeScriptTypesGenerator,
    ApolloHooksGenerator,
    MutationDocsGenerator,
)
from pathlib import Path

# Load your entities
entities = [...]  # Your parsed Entity objects

output_dir = Path("frontend/generated")

# Generate all frontend code
MutationImpactsGenerator(output_dir).generate_impacts(entities)
TypeScriptTypesGenerator(output_dir).generate_types(entities)
ApolloHooksGenerator(output_dir).generate_hooks(entities)
MutationDocsGenerator(output_dir).generate_docs(entities)
```

## Integration with Frontend Applications

### React/Apollo Setup

1. **Install dependencies:**
```bash
npm install @apollo/client graphql
```

2. **Configure Apollo Client:**
```typescript
import { ApolloClient, InMemoryCache } from '@apollo/client';

const client = new ApolloClient({
  uri: 'http://localhost:4000/graphql',
  cache: new InMemoryCache(),
});
```

3. **Use generated hooks in components:**
```typescript
import { useCreateContact, useGetContacts } from './generated/hooks';
import type { CreateContactInput } from './generated/types';

function ContactForm() {
  const [createContact, { loading, error }] = useCreateContact();
  const { data: contactsData } = useGetContacts();

  const handleSubmit = async (input: CreateContactInput) => {
    const result = await createContact({
      variables: { input },
    });

    if (result.data?.createContact.success) {
      console.log('Contact created!');
    }
  };

  return (
    <form onSubmit={handleSubmit}>
      {/* Form fields */}
      <button disabled={loading}>
        {loading ? 'Creating...' : 'Create Contact'}
      </button>
    </form>
  );
}
```

### Cache Management

The generated hooks include automatic cache updates:

- **Creates:** Add new items to list caches
- **Updates:** Modify existing items in cache
- **Deletes:** Remove items and clean up references

For advanced cache management, use the `mutation-impacts.json`:

```typescript
import impacts from './mutation-impacts.json';

// Check what entities are affected by a mutation
const mutationImpact = impacts.mutations['Contact.create_contact'];
console.log('Affected entities:', mutationImpact.impacts.affectedEntities);
```

## File Structure

```
frontend/
├── generated/           # Auto-generated files
│   ├── mutation-impacts.json
│   ├── types.ts
│   ├── hooks.ts
│   └── mutations.md
├── components/          # Your components
│   └── ContactForm.tsx
└── lib/
    └── apollo.ts       # Apollo client setup
```

## Best Practices

1. **Regenerate after schema changes:** Always regenerate frontend code when you modify entity definitions.

2. **Type safety:** Use the generated TypeScript types throughout your application for full type safety.

3. **Cache awareness:** Leverage the automatic cache updates provided by the generated hooks.

4. **Error handling:** Check mutation results and handle errors appropriately.

5. **Documentation:** Use the generated `mutations.md` as API documentation for your frontend team.

## Troubleshooting

### Import Errors
If you get import errors, ensure the generated files are in your TypeScript path:

```json
// tsconfig.json
{
  "compilerOptions": {
    "baseUrl": ".",
    "paths": {
      "@generated/*": ["frontend/generated/*"]
    }
  }
}
```

### Cache Issues
If cache updates aren't working as expected, check the mutation impacts configuration and ensure your GraphQL server follows the expected patterns.

### Type Mismatches
If generated types don't match your GraphQL schema, ensure your SpecQL entity definitions are accurate and up-to-date.
