-- Benchmark Dataset DDL
-- Generated by BenchmarkDataGenerator

CREATE SCHEMA IF NOT EXISTS benchmark;

CREATE TABLE benchmark.tb_customer (
    pk_customer SERIAL PRIMARY KEY,
    id UUID NOT NULL UNIQUE DEFAULT gen_random_uuid(),
    identifier TEXT NOT NULL UNIQUE,
    field_00 TEXT NOT NULL,
    field_01 TEXT NULL,
    field_02 INTEGER NOT NULL,
    field_03 BOOLEAN NOT NULL,
    field_04 BOOLEAN NOT NULL,
    field_05 BOOLEAN NOT NULL,
    field_06 TIMESTAMP NOT NULL,
    field_07 TEXT NOT NULL,
    field_08 TEXT NOT NULL,
    field_09 TIMESTAMP NOT NULL,
    field_10 JSONB NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    deleted_at TIMESTAMP
);
CREATE INDEX idx_customer_id ON benchmark.tb_customer(id);
CREATE INDEX idx_customer_identifier ON benchmark.tb_customer(identifier);

CREATE OR REPLACE FUNCTION benchmark.create_customer(
    p_field_00 TEXT
) RETURNS INTEGER AS $$
DECLARE
    v_pk_customer INTEGER;
BEGIN
    INSERT INTO benchmark.tb_customer (field_00)
    VALUES (p_field_00)
    RETURNING pk_customer INTO v_pk_customer;

    RETURN v_pk_customer;
END;
$$ LANGUAGE plpgsql;


CREATE OR REPLACE FUNCTION benchmark.update_customer(
    p_pk_customer INTEGER,
    p_field_00 TEXT
) RETURNS VOID AS $$
BEGIN
    UPDATE benchmark.tb_customer
    SET field_00 = p_field_00,
        updated_at = CURRENT_TIMESTAMP
    WHERE pk_customer = p_pk_customer;
END;
$$ LANGUAGE plpgsql;


CREATE OR REPLACE FUNCTION benchmark.delete_customer(
    p_pk_customer INTEGER
) RETURNS VOID AS $$
BEGIN
    UPDATE benchmark.tb_customer
    SET deleted_at = CURRENT_TIMESTAMP
    WHERE pk_customer = p_pk_customer;
END;
$$ LANGUAGE plpgsql;


CREATE TABLE benchmark.tb_order (
    pk_order SERIAL PRIMARY KEY,
    id UUID NOT NULL UNIQUE DEFAULT gen_random_uuid(),
    identifier TEXT NOT NULL UNIQUE,
    pk_customer INTEGER NOT NULL REFERENCES benchmark.tb_customer(pk_customer),
    field_00 NUMERIC(10,2) NOT NULL,
    field_01 BOOLEAN NULL,
    field_02 JSONB NOT NULL,
    field_03 NUMERIC(10,2) NOT NULL,
    field_04 INTEGER NOT NULL,
    field_05 TEXT NOT NULL,
    field_06 NUMERIC(10,2) NOT NULL,
    field_07 TIMESTAMP NOT NULL,
    field_08 INTEGER NOT NULL,
    field_09 INTEGER NOT NULL,
    field_10 TIMESTAMP NOT NULL,
    dedup_key TEXT,
    dedup_hash TEXT,
    is_unique BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    deleted_at TIMESTAMP
);
CREATE INDEX idx_order_id ON benchmark.tb_order(id);
CREATE INDEX idx_order_identifier ON benchmark.tb_order(identifier);
CREATE INDEX idx_order_dedup_hash ON benchmark.tb_order(dedup_hash);

CREATE OR REPLACE FUNCTION benchmark.create_order(
    p_field_00 TEXT
) RETURNS INTEGER AS $$
DECLARE
    v_pk_order INTEGER;
BEGIN
    INSERT INTO benchmark.tb_order (field_00)
    VALUES (p_field_00)
    RETURNING pk_order INTO v_pk_order;

    RETURN v_pk_order;
END;
$$ LANGUAGE plpgsql;


CREATE OR REPLACE FUNCTION benchmark.update_order(
    p_pk_order INTEGER,
    p_field_00 TEXT
) RETURNS VOID AS $$
BEGIN
    UPDATE benchmark.tb_order
    SET field_00 = p_field_00,
        updated_at = CURRENT_TIMESTAMP
    WHERE pk_order = p_pk_order;
END;
$$ LANGUAGE plpgsql;


CREATE TABLE benchmark.tb_product (
    pk_product SERIAL PRIMARY KEY,
    id UUID NOT NULL UNIQUE DEFAULT gen_random_uuid(),
    identifier TEXT NOT NULL UNIQUE,
    field_00 TIMESTAMP NOT NULL,
    field_01 TEXT NULL,
    field_02 NUMERIC(10,2) NOT NULL,
    field_03 NUMERIC(10,2) NULL,
    field_04 INTEGER NOT NULL,
    field_05 TEXT NULL,
    field_06 BOOLEAN NOT NULL,
    field_07 TIMESTAMP NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    deleted_at TIMESTAMP
);
CREATE INDEX idx_product_id ON benchmark.tb_product(id);
CREATE INDEX idx_product_identifier ON benchmark.tb_product(identifier);

CREATE OR REPLACE FUNCTION benchmark.create_product(
    p_field_00 TEXT
) RETURNS INTEGER AS $$
DECLARE
    v_pk_product INTEGER;
BEGIN
    INSERT INTO benchmark.tb_product (field_00)
    VALUES (p_field_00)
    RETURNING pk_product INTO v_pk_product;

    RETURN v_pk_product;
END;
$$ LANGUAGE plpgsql;


CREATE OR REPLACE FUNCTION benchmark.update_product(
    p_pk_product INTEGER,
    p_field_00 TEXT
) RETURNS VOID AS $$
BEGIN
    UPDATE benchmark.tb_product
    SET field_00 = p_field_00,
        updated_at = CURRENT_TIMESTAMP
    WHERE pk_product = p_pk_product;
END;
$$ LANGUAGE plpgsql;


CREATE OR REPLACE FUNCTION benchmark.delete_product(
    p_pk_product INTEGER
) RETURNS VOID AS $$
BEGIN
    UPDATE benchmark.tb_product
    SET deleted_at = CURRENT_TIMESTAMP
    WHERE pk_product = p_pk_product;
END;
$$ LANGUAGE plpgsql;


CREATE TABLE benchmark.tb_invoice (
    pk_invoice SERIAL PRIMARY KEY,
    id UUID NOT NULL UNIQUE DEFAULT gen_random_uuid(),
    identifier TEXT NOT NULL UNIQUE,
    field_00 INTEGER NOT NULL,
    field_01 TIMESTAMP NULL,
    field_02 TIMESTAMP NOT NULL,
    field_03 BOOLEAN NOT NULL,
    field_04 TIMESTAMP NOT NULL,
    field_05 JSONB NULL,
    field_06 NUMERIC(10,2) NOT NULL,
    field_07 JSONB NOT NULL,
    field_08 BOOLEAN NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    deleted_at TIMESTAMP
);
CREATE INDEX idx_invoice_id ON benchmark.tb_invoice(id);
CREATE INDEX idx_invoice_identifier ON benchmark.tb_invoice(identifier);

CREATE OR REPLACE FUNCTION benchmark.create_invoice(
    p_field_00 TEXT
) RETURNS INTEGER AS $$
DECLARE
    v_pk_invoice INTEGER;
BEGIN
    INSERT INTO benchmark.tb_invoice (field_00)
    VALUES (p_field_00)
    RETURNING pk_invoice INTO v_pk_invoice;

    RETURN v_pk_invoice;
END;
$$ LANGUAGE plpgsql;


CREATE OR REPLACE FUNCTION benchmark.update_invoice(
    p_pk_invoice INTEGER,
    p_field_00 TEXT
) RETURNS VOID AS $$
BEGIN
    UPDATE benchmark.tb_invoice
    SET field_00 = p_field_00,
        updated_at = CURRENT_TIMESTAMP
    WHERE pk_invoice = p_pk_invoice;
END;
$$ LANGUAGE plpgsql;


CREATE TABLE benchmark.tb_payment (
    pk_payment SERIAL PRIMARY KEY,
    pk_product INTEGER NOT NULL REFERENCES benchmark.tb_product(pk_product),
    pk_order INTEGER NOT NULL REFERENCES benchmark.tb_order(pk_order),
    field_00 BOOLEAN NULL,
    field_01 INTEGER NULL,
    field_02 TEXT NOT NULL,
    field_03 INTEGER NOT NULL,
    field_04 TEXT NULL,
    field_05 JSONB NULL,
    field_06 TEXT NOT NULL,
    field_07 NUMERIC(10,2) NULL,
    field_08 INTEGER NULL,
    field_09 BOOLEAN NULL,
    dedup_key TEXT,
    dedup_hash TEXT,
    is_unique BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    deleted_at TIMESTAMP
);
CREATE INDEX idx_payment_dedup_hash ON benchmark.tb_payment(dedup_hash);

CREATE OR REPLACE FUNCTION benchmark.create_payment(
    p_field_00 TEXT
) RETURNS INTEGER AS $$
DECLARE
    v_pk_payment INTEGER;
BEGIN
    INSERT INTO benchmark.tb_payment (field_00)
    VALUES (p_field_00)
    RETURNING pk_payment INTO v_pk_payment;

    RETURN v_pk_payment;
END;
$$ LANGUAGE plpgsql;


CREATE TABLE benchmark.tb_shipment (
    pk_shipment SERIAL PRIMARY KEY,
    pk_product INTEGER NOT NULL REFERENCES benchmark.tb_product(pk_product),
    pk_order INTEGER NOT NULL REFERENCES benchmark.tb_order(pk_order),
    field_00 INTEGER NOT NULL,
    field_01 TIMESTAMP NOT NULL,
    field_02 INTEGER NOT NULL,
    field_03 BOOLEAN NULL,
    field_04 TEXT NOT NULL,
    field_05 NUMERIC(10,2) NOT NULL,
    field_06 BOOLEAN NOT NULL,
    field_07 TEXT NOT NULL,
    field_08 JSONB NULL,
    field_09 BOOLEAN NOT NULL,
    field_10 TEXT NULL,
    field_11 INTEGER NOT NULL,
    field_12 INTEGER NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    deleted_at TIMESTAMP
);

CREATE OR REPLACE FUNCTION benchmark.create_shipment(
    p_field_00 TEXT
) RETURNS INTEGER AS $$
DECLARE
    v_pk_shipment INTEGER;
BEGIN
    INSERT INTO benchmark.tb_shipment (field_00)
    VALUES (p_field_00)
    RETURNING pk_shipment INTO v_pk_shipment;

    RETURN v_pk_shipment;
END;
$$ LANGUAGE plpgsql;


CREATE OR REPLACE FUNCTION benchmark.update_shipment(
    p_pk_shipment INTEGER,
    p_field_00 TEXT
) RETURNS VOID AS $$
BEGIN
    UPDATE benchmark.tb_shipment
    SET field_00 = p_field_00,
        updated_at = CURRENT_TIMESTAMP
    WHERE pk_shipment = p_pk_shipment;
END;
$$ LANGUAGE plpgsql;


CREATE OR REPLACE FUNCTION benchmark.delete_shipment(
    p_pk_shipment INTEGER
) RETURNS VOID AS $$
BEGIN
    UPDATE benchmark.tb_shipment
    SET deleted_at = CURRENT_TIMESTAMP
    WHERE pk_shipment = p_pk_shipment;
END;
$$ LANGUAGE plpgsql;


CREATE TABLE benchmark.tb_employee (
    pk_employee SERIAL PRIMARY KEY,
    id UUID NOT NULL UNIQUE DEFAULT gen_random_uuid(),
    identifier TEXT NOT NULL UNIQUE,
    field_00 NUMERIC(10,2) NOT NULL,
    field_01 TEXT NOT NULL,
    field_02 TIMESTAMP NULL,
    field_03 JSONB NOT NULL,
    field_04 TEXT NOT NULL,
    field_05 INTEGER NULL,
    field_06 BOOLEAN NOT NULL,
    field_07 BOOLEAN NOT NULL,
    field_08 INTEGER NOT NULL,
    field_09 BOOLEAN NULL,
    field_10 BOOLEAN NULL,
    field_11 JSONB NOT NULL,
    field_12 TIMESTAMP NOT NULL,
    field_13 BOOLEAN NULL,
    field_14 NUMERIC(10,2) NULL,
    field_15 TEXT NOT NULL,
    field_16 TIMESTAMP NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    deleted_at TIMESTAMP
);
CREATE INDEX idx_employee_id ON benchmark.tb_employee(id);
CREATE INDEX idx_employee_identifier ON benchmark.tb_employee(identifier);

CREATE OR REPLACE FUNCTION benchmark.create_employee(
    p_field_00 TEXT
) RETURNS INTEGER AS $$
DECLARE
    v_pk_employee INTEGER;
BEGIN
    INSERT INTO benchmark.tb_employee (field_00)
    VALUES (p_field_00)
    RETURNING pk_employee INTO v_pk_employee;

    RETURN v_pk_employee;
END;
$$ LANGUAGE plpgsql;


CREATE OR REPLACE FUNCTION benchmark.update_employee(
    p_pk_employee INTEGER,
    p_field_00 TEXT
) RETURNS VOID AS $$
BEGIN
    UPDATE benchmark.tb_employee
    SET field_00 = p_field_00,
        updated_at = CURRENT_TIMESTAMP
    WHERE pk_employee = p_pk_employee;
END;
$$ LANGUAGE plpgsql;


CREATE OR REPLACE FUNCTION benchmark.delete_employee(
    p_pk_employee INTEGER
) RETURNS VOID AS $$
BEGIN
    UPDATE benchmark.tb_employee
    SET deleted_at = CURRENT_TIMESTAMP
    WHERE pk_employee = p_pk_employee;
END;
$$ LANGUAGE plpgsql;


CREATE TABLE benchmark.tb_department (
    pk_department SERIAL PRIMARY KEY,
    id UUID NOT NULL UNIQUE DEFAULT gen_random_uuid(),
    identifier TEXT NOT NULL UNIQUE,
    pk_payment INTEGER NOT NULL REFERENCES benchmark.tb_payment(pk_payment),
    pk_employee INTEGER NOT NULL REFERENCES benchmark.tb_employee(pk_employee),
    field_00 NUMERIC(10,2) NULL,
    field_01 TIMESTAMP NOT NULL,
    field_02 TIMESTAMP NULL,
    field_03 TIMESTAMP NULL,
    field_04 INTEGER NULL,
    field_05 TEXT NOT NULL,
    field_06 INTEGER NOT NULL,
    field_07 TIMESTAMP NULL,
    field_08 TIMESTAMP NULL,
    field_09 TEXT NOT NULL,
    field_10 TIMESTAMP NOT NULL,
    field_11 NUMERIC(10,2) NOT NULL,
    field_12 INTEGER NOT NULL,
    field_13 NUMERIC(10,2) NULL,
    field_14 BOOLEAN NULL,
    field_15 JSONB NULL,
    field_16 NUMERIC(10,2) NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    deleted_at TIMESTAMP
);
CREATE INDEX idx_department_id ON benchmark.tb_department(id);
CREATE INDEX idx_department_identifier ON benchmark.tb_department(identifier);

CREATE OR REPLACE FUNCTION benchmark.create_department(
    p_field_00 TEXT
) RETURNS INTEGER AS $$
DECLARE
    v_pk_department INTEGER;
BEGIN
    INSERT INTO benchmark.tb_department (field_00)
    VALUES (p_field_00)
    RETURNING pk_department INTO v_pk_department;

    RETURN v_pk_department;
END;
$$ LANGUAGE plpgsql;


CREATE OR REPLACE FUNCTION benchmark.update_department(
    p_pk_department INTEGER,
    p_field_00 TEXT
) RETURNS VOID AS $$
BEGIN
    UPDATE benchmark.tb_department
    SET field_00 = p_field_00,
        updated_at = CURRENT_TIMESTAMP
    WHERE pk_department = p_pk_department;
END;
$$ LANGUAGE plpgsql;


CREATE OR REPLACE FUNCTION benchmark.delete_department(
    p_pk_department INTEGER
) RETURNS VOID AS $$
BEGIN
    UPDATE benchmark.tb_department
    SET deleted_at = CURRENT_TIMESTAMP
    WHERE pk_department = p_pk_department;
END;
$$ LANGUAGE plpgsql;


CREATE TABLE benchmark.tb_project (
    pk_project SERIAL PRIMARY KEY,
    id UUID NOT NULL UNIQUE DEFAULT gen_random_uuid(),
    identifier TEXT NOT NULL UNIQUE,
    pk_employee INTEGER NOT NULL REFERENCES benchmark.tb_employee(pk_employee),
    field_00 TEXT NULL,
    field_01 TIMESTAMP NOT NULL,
    field_02 TEXT NULL,
    field_03 INTEGER NOT NULL,
    field_04 INTEGER NOT NULL,
    field_05 TEXT NOT NULL,
    field_06 NUMERIC(10,2) NULL,
    field_07 BOOLEAN NOT NULL,
    field_08 JSONB NOT NULL,
    field_09 JSONB NOT NULL,
    field_10 JSONB NOT NULL,
    field_11 NUMERIC(10,2) NOT NULL,
    field_12 TEXT NOT NULL,
    field_13 INTEGER NULL,
    field_14 TEXT NOT NULL,
    field_15 INTEGER NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    deleted_at TIMESTAMP
);
CREATE INDEX idx_project_id ON benchmark.tb_project(id);
CREATE INDEX idx_project_identifier ON benchmark.tb_project(identifier);

CREATE OR REPLACE FUNCTION benchmark.create_project(
    p_field_00 TEXT
) RETURNS INTEGER AS $$
DECLARE
    v_pk_project INTEGER;
BEGIN
    INSERT INTO benchmark.tb_project (field_00)
    VALUES (p_field_00)
    RETURNING pk_project INTO v_pk_project;

    RETURN v_pk_project;
END;
$$ LANGUAGE plpgsql;


CREATE OR REPLACE FUNCTION benchmark.update_project(
    p_pk_project INTEGER,
    p_field_00 TEXT
) RETURNS VOID AS $$
BEGIN
    UPDATE benchmark.tb_project
    SET field_00 = p_field_00,
        updated_at = CURRENT_TIMESTAMP
    WHERE pk_project = p_pk_project;
END;
$$ LANGUAGE plpgsql;


CREATE TABLE benchmark.tb_task (
    pk_task SERIAL PRIMARY KEY,
    id UUID NOT NULL UNIQUE DEFAULT gen_random_uuid(),
    identifier TEXT NOT NULL UNIQUE,
    pk_department INTEGER NOT NULL REFERENCES benchmark.tb_department(pk_department),
    field_00 TIMESTAMP NULL,
    field_01 NUMERIC(10,2) NULL,
    field_02 JSONB NOT NULL,
    field_03 TIMESTAMP NOT NULL,
    field_04 TEXT NULL,
    field_05 BOOLEAN NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    deleted_at TIMESTAMP
);
CREATE INDEX idx_task_id ON benchmark.tb_task(id);
CREATE INDEX idx_task_identifier ON benchmark.tb_task(identifier);

CREATE OR REPLACE FUNCTION benchmark.create_task(
    p_field_00 TEXT
) RETURNS INTEGER AS $$
DECLARE
    v_pk_task INTEGER;
BEGIN
    INSERT INTO benchmark.tb_task (field_00)
    VALUES (p_field_00)
    RETURNING pk_task INTO v_pk_task;

    RETURN v_pk_task;
END;
$$ LANGUAGE plpgsql;

