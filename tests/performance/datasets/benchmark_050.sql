-- Benchmark Dataset DDL
-- Generated by BenchmarkDataGenerator

CREATE SCHEMA IF NOT EXISTS benchmark;

CREATE TABLE benchmark.tb_customer (
    pk_customer SERIAL PRIMARY KEY,
    id UUID NOT NULL UNIQUE DEFAULT gen_random_uuid(),
    identifier TEXT NOT NULL UNIQUE,
    field_00 JSONB NULL,
    field_01 BOOLEAN NULL,
    field_02 NUMERIC(10,2) NULL,
    field_03 NUMERIC(10,2) NOT NULL,
    field_04 TIMESTAMP NULL,
    field_05 INTEGER NULL,
    field_06 JSONB NULL,
    field_07 INTEGER NULL,
    field_08 BOOLEAN NOT NULL,
    field_09 BOOLEAN NOT NULL,
    field_10 INTEGER NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    deleted_at TIMESTAMP
);
CREATE INDEX idx_customer_id ON benchmark.tb_customer(id);
CREATE INDEX idx_customer_identifier ON benchmark.tb_customer(identifier);

CREATE OR REPLACE FUNCTION benchmark.create_customer(
    p_field_00 TEXT
) RETURNS INTEGER AS $$
DECLARE
    v_pk_customer INTEGER;
BEGIN
    INSERT INTO benchmark.tb_customer (field_00)
    VALUES (p_field_00)
    RETURNING pk_customer INTO v_pk_customer;

    RETURN v_pk_customer;
END;
$$ LANGUAGE plpgsql;


CREATE OR REPLACE FUNCTION benchmark.update_customer(
    p_pk_customer INTEGER,
    p_field_00 TEXT
) RETURNS VOID AS $$
BEGIN
    UPDATE benchmark.tb_customer
    SET field_00 = p_field_00,
        updated_at = CURRENT_TIMESTAMP
    WHERE pk_customer = p_pk_customer;
END;
$$ LANGUAGE plpgsql;


CREATE OR REPLACE FUNCTION benchmark.delete_customer(
    p_pk_customer INTEGER
) RETURNS VOID AS $$
BEGIN
    UPDATE benchmark.tb_customer
    SET deleted_at = CURRENT_TIMESTAMP
    WHERE pk_customer = p_pk_customer;
END;
$$ LANGUAGE plpgsql;


CREATE TABLE benchmark.tb_order (
    pk_order SERIAL PRIMARY KEY,
    id UUID NOT NULL UNIQUE DEFAULT gen_random_uuid(),
    identifier TEXT NOT NULL UNIQUE,
    pk_customer INTEGER NOT NULL REFERENCES benchmark.tb_customer(pk_customer),
    field_00 BOOLEAN NOT NULL,
    field_01 TIMESTAMP NOT NULL,
    field_02 TEXT NOT NULL,
    field_03 TIMESTAMP NOT NULL,
    field_04 TEXT NOT NULL,
    field_05 NUMERIC(10,2) NOT NULL,
    field_06 BOOLEAN NOT NULL,
    field_07 JSONB NOT NULL,
    field_08 TIMESTAMP NOT NULL,
    field_09 BOOLEAN NULL,
    field_10 BOOLEAN NOT NULL,
    dedup_key TEXT,
    dedup_hash TEXT,
    is_unique BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    deleted_at TIMESTAMP
);
CREATE INDEX idx_order_id ON benchmark.tb_order(id);
CREATE INDEX idx_order_identifier ON benchmark.tb_order(identifier);
CREATE INDEX idx_order_dedup_hash ON benchmark.tb_order(dedup_hash);

CREATE OR REPLACE FUNCTION benchmark.create_order(
    p_field_00 TEXT
) RETURNS INTEGER AS $$
DECLARE
    v_pk_order INTEGER;
BEGIN
    INSERT INTO benchmark.tb_order (field_00)
    VALUES (p_field_00)
    RETURNING pk_order INTO v_pk_order;

    RETURN v_pk_order;
END;
$$ LANGUAGE plpgsql;


CREATE OR REPLACE FUNCTION benchmark.update_order(
    p_pk_order INTEGER,
    p_field_00 TEXT
) RETURNS VOID AS $$
BEGIN
    UPDATE benchmark.tb_order
    SET field_00 = p_field_00,
        updated_at = CURRENT_TIMESTAMP
    WHERE pk_order = p_pk_order;
END;
$$ LANGUAGE plpgsql;


CREATE TABLE benchmark.tb_product (
    pk_product SERIAL PRIMARY KEY,
    id UUID NOT NULL UNIQUE DEFAULT gen_random_uuid(),
    identifier TEXT NOT NULL UNIQUE,
    pk_order INTEGER NOT NULL REFERENCES benchmark.tb_order(pk_order),
    pk_customer INTEGER NOT NULL REFERENCES benchmark.tb_customer(pk_customer),
    field_00 BOOLEAN NOT NULL,
    field_01 JSONB NOT NULL,
    field_02 JSONB NULL,
    field_03 BOOLEAN NOT NULL,
    field_04 TIMESTAMP NOT NULL,
    field_05 BOOLEAN NOT NULL,
    field_06 JSONB NULL,
    field_07 JSONB NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    deleted_at TIMESTAMP
);
CREATE INDEX idx_product_id ON benchmark.tb_product(id);
CREATE INDEX idx_product_identifier ON benchmark.tb_product(identifier);

CREATE OR REPLACE FUNCTION benchmark.create_product(
    p_field_00 TEXT
) RETURNS INTEGER AS $$
DECLARE
    v_pk_product INTEGER;
BEGIN
    INSERT INTO benchmark.tb_product (field_00)
    VALUES (p_field_00)
    RETURNING pk_product INTO v_pk_product;

    RETURN v_pk_product;
END;
$$ LANGUAGE plpgsql;


CREATE OR REPLACE FUNCTION benchmark.update_product(
    p_pk_product INTEGER,
    p_field_00 TEXT
) RETURNS VOID AS $$
BEGIN
    UPDATE benchmark.tb_product
    SET field_00 = p_field_00,
        updated_at = CURRENT_TIMESTAMP
    WHERE pk_product = p_pk_product;
END;
$$ LANGUAGE plpgsql;


CREATE OR REPLACE FUNCTION benchmark.delete_product(
    p_pk_product INTEGER
) RETURNS VOID AS $$
BEGIN
    UPDATE benchmark.tb_product
    SET deleted_at = CURRENT_TIMESTAMP
    WHERE pk_product = p_pk_product;
END;
$$ LANGUAGE plpgsql;


CREATE TABLE benchmark.tb_invoice (
    pk_invoice SERIAL PRIMARY KEY,
    id UUID NOT NULL UNIQUE DEFAULT gen_random_uuid(),
    identifier TEXT NOT NULL UNIQUE,
    pk_product INTEGER NOT NULL REFERENCES benchmark.tb_product(pk_product),
    pk_order INTEGER NOT NULL REFERENCES benchmark.tb_order(pk_order),
    field_00 BOOLEAN NULL,
    field_01 NUMERIC(10,2) NOT NULL,
    field_02 INTEGER NOT NULL,
    field_03 NUMERIC(10,2) NOT NULL,
    field_04 BOOLEAN NULL,
    field_05 BOOLEAN NULL,
    field_06 TEXT NOT NULL,
    field_07 JSONB NOT NULL,
    field_08 NUMERIC(10,2) NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    deleted_at TIMESTAMP
);
CREATE INDEX idx_invoice_id ON benchmark.tb_invoice(id);
CREATE INDEX idx_invoice_identifier ON benchmark.tb_invoice(identifier);

CREATE OR REPLACE FUNCTION benchmark.create_invoice(
    p_field_00 TEXT
) RETURNS INTEGER AS $$
DECLARE
    v_pk_invoice INTEGER;
BEGIN
    INSERT INTO benchmark.tb_invoice (field_00)
    VALUES (p_field_00)
    RETURNING pk_invoice INTO v_pk_invoice;

    RETURN v_pk_invoice;
END;
$$ LANGUAGE plpgsql;


CREATE OR REPLACE FUNCTION benchmark.update_invoice(
    p_pk_invoice INTEGER,
    p_field_00 TEXT
) RETURNS VOID AS $$
BEGIN
    UPDATE benchmark.tb_invoice
    SET field_00 = p_field_00,
        updated_at = CURRENT_TIMESTAMP
    WHERE pk_invoice = p_pk_invoice;
END;
$$ LANGUAGE plpgsql;


CREATE TABLE benchmark.tb_payment (
    pk_payment SERIAL PRIMARY KEY,
    pk_order INTEGER NOT NULL REFERENCES benchmark.tb_order(pk_order),
    field_00 TEXT NOT NULL,
    field_01 JSONB NULL,
    field_02 TEXT NOT NULL,
    field_03 INTEGER NOT NULL,
    field_04 TIMESTAMP NULL,
    field_05 INTEGER NOT NULL,
    field_06 TEXT NOT NULL,
    field_07 INTEGER NOT NULL,
    field_08 NUMERIC(10,2) NOT NULL,
    field_09 INTEGER NOT NULL,
    dedup_key TEXT,
    dedup_hash TEXT,
    is_unique BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    deleted_at TIMESTAMP
);
CREATE INDEX idx_payment_dedup_hash ON benchmark.tb_payment(dedup_hash);

CREATE OR REPLACE FUNCTION benchmark.create_payment(
    p_field_00 TEXT
) RETURNS INTEGER AS $$
DECLARE
    v_pk_payment INTEGER;
BEGIN
    INSERT INTO benchmark.tb_payment (field_00)
    VALUES (p_field_00)
    RETURNING pk_payment INTO v_pk_payment;

    RETURN v_pk_payment;
END;
$$ LANGUAGE plpgsql;


CREATE TABLE benchmark.tb_shipment (
    pk_shipment SERIAL PRIMARY KEY,
    pk_payment INTEGER NOT NULL REFERENCES benchmark.tb_payment(pk_payment),
    field_00 JSONB NOT NULL,
    field_01 INTEGER NOT NULL,
    field_02 TEXT NOT NULL,
    field_03 NUMERIC(10,2) NOT NULL,
    field_04 BOOLEAN NOT NULL,
    field_05 JSONB NULL,
    field_06 TIMESTAMP NOT NULL,
    field_07 JSONB NULL,
    field_08 JSONB NOT NULL,
    field_09 JSONB NOT NULL,
    field_10 TEXT NOT NULL,
    field_11 TIMESTAMP NOT NULL,
    field_12 NUMERIC(10,2) NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    deleted_at TIMESTAMP
);

CREATE OR REPLACE FUNCTION benchmark.create_shipment(
    p_field_00 TEXT
) RETURNS INTEGER AS $$
DECLARE
    v_pk_shipment INTEGER;
BEGIN
    INSERT INTO benchmark.tb_shipment (field_00)
    VALUES (p_field_00)
    RETURNING pk_shipment INTO v_pk_shipment;

    RETURN v_pk_shipment;
END;
$$ LANGUAGE plpgsql;


CREATE OR REPLACE FUNCTION benchmark.update_shipment(
    p_pk_shipment INTEGER,
    p_field_00 TEXT
) RETURNS VOID AS $$
BEGIN
    UPDATE benchmark.tb_shipment
    SET field_00 = p_field_00,
        updated_at = CURRENT_TIMESTAMP
    WHERE pk_shipment = p_pk_shipment;
END;
$$ LANGUAGE plpgsql;


CREATE OR REPLACE FUNCTION benchmark.delete_shipment(
    p_pk_shipment INTEGER
) RETURNS VOID AS $$
BEGIN
    UPDATE benchmark.tb_shipment
    SET deleted_at = CURRENT_TIMESTAMP
    WHERE pk_shipment = p_pk_shipment;
END;
$$ LANGUAGE plpgsql;


CREATE TABLE benchmark.tb_employee (
    pk_employee SERIAL PRIMARY KEY,
    id UUID NOT NULL UNIQUE DEFAULT gen_random_uuid(),
    identifier TEXT NOT NULL UNIQUE,
    pk_shipment INTEGER NOT NULL REFERENCES benchmark.tb_shipment(pk_shipment),
    field_00 JSONB NOT NULL,
    field_01 TIMESTAMP NOT NULL,
    field_02 TEXT NOT NULL,
    field_03 BOOLEAN NULL,
    field_04 NUMERIC(10,2) NOT NULL,
    field_05 BOOLEAN NOT NULL,
    field_06 BOOLEAN NULL,
    field_07 TIMESTAMP NOT NULL,
    field_08 NUMERIC(10,2) NOT NULL,
    field_09 TIMESTAMP NOT NULL,
    field_10 BOOLEAN NOT NULL,
    field_11 JSONB NOT NULL,
    field_12 NUMERIC(10,2) NOT NULL,
    field_13 TEXT NULL,
    field_14 BOOLEAN NULL,
    field_15 BOOLEAN NOT NULL,
    field_16 JSONB NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    deleted_at TIMESTAMP
);
CREATE INDEX idx_employee_id ON benchmark.tb_employee(id);
CREATE INDEX idx_employee_identifier ON benchmark.tb_employee(identifier);

CREATE OR REPLACE FUNCTION benchmark.create_employee(
    p_field_00 TEXT
) RETURNS INTEGER AS $$
DECLARE
    v_pk_employee INTEGER;
BEGIN
    INSERT INTO benchmark.tb_employee (field_00)
    VALUES (p_field_00)
    RETURNING pk_employee INTO v_pk_employee;

    RETURN v_pk_employee;
END;
$$ LANGUAGE plpgsql;


CREATE OR REPLACE FUNCTION benchmark.update_employee(
    p_pk_employee INTEGER,
    p_field_00 TEXT
) RETURNS VOID AS $$
BEGIN
    UPDATE benchmark.tb_employee
    SET field_00 = p_field_00,
        updated_at = CURRENT_TIMESTAMP
    WHERE pk_employee = p_pk_employee;
END;
$$ LANGUAGE plpgsql;


CREATE OR REPLACE FUNCTION benchmark.delete_employee(
    p_pk_employee INTEGER
) RETURNS VOID AS $$
BEGIN
    UPDATE benchmark.tb_employee
    SET deleted_at = CURRENT_TIMESTAMP
    WHERE pk_employee = p_pk_employee;
END;
$$ LANGUAGE plpgsql;


CREATE TABLE benchmark.tb_department (
    pk_department SERIAL PRIMARY KEY,
    id UUID NOT NULL UNIQUE DEFAULT gen_random_uuid(),
    identifier TEXT NOT NULL UNIQUE,
    field_00 TEXT NOT NULL,
    field_01 NUMERIC(10,2) NULL,
    field_02 INTEGER NOT NULL,
    field_03 NUMERIC(10,2) NOT NULL,
    field_04 TIMESTAMP NOT NULL,
    field_05 NUMERIC(10,2) NOT NULL,
    field_06 TIMESTAMP NOT NULL,
    field_07 TEXT NULL,
    field_08 BOOLEAN NOT NULL,
    field_09 INTEGER NOT NULL,
    field_10 JSONB NOT NULL,
    field_11 BOOLEAN NOT NULL,
    field_12 TEXT NULL,
    field_13 BOOLEAN NOT NULL,
    field_14 NUMERIC(10,2) NOT NULL,
    field_15 NUMERIC(10,2) NOT NULL,
    field_16 TIMESTAMP NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    deleted_at TIMESTAMP
);
CREATE INDEX idx_department_id ON benchmark.tb_department(id);
CREATE INDEX idx_department_identifier ON benchmark.tb_department(identifier);

CREATE OR REPLACE FUNCTION benchmark.create_department(
    p_field_00 TEXT
) RETURNS INTEGER AS $$
DECLARE
    v_pk_department INTEGER;
BEGIN
    INSERT INTO benchmark.tb_department (field_00)
    VALUES (p_field_00)
    RETURNING pk_department INTO v_pk_department;

    RETURN v_pk_department;
END;
$$ LANGUAGE plpgsql;


CREATE OR REPLACE FUNCTION benchmark.update_department(
    p_pk_department INTEGER,
    p_field_00 TEXT
) RETURNS VOID AS $$
BEGIN
    UPDATE benchmark.tb_department
    SET field_00 = p_field_00,
        updated_at = CURRENT_TIMESTAMP
    WHERE pk_department = p_pk_department;
END;
$$ LANGUAGE plpgsql;


CREATE OR REPLACE FUNCTION benchmark.delete_department(
    p_pk_department INTEGER
) RETURNS VOID AS $$
BEGIN
    UPDATE benchmark.tb_department
    SET deleted_at = CURRENT_TIMESTAMP
    WHERE pk_department = p_pk_department;
END;
$$ LANGUAGE plpgsql;


CREATE TABLE benchmark.tb_project (
    pk_project SERIAL PRIMARY KEY,
    id UUID NOT NULL UNIQUE DEFAULT gen_random_uuid(),
    identifier TEXT NOT NULL UNIQUE,
    pk_payment INTEGER NOT NULL REFERENCES benchmark.tb_payment(pk_payment),
    pk_product INTEGER NOT NULL REFERENCES benchmark.tb_product(pk_product),
    field_00 JSONB NOT NULL,
    field_01 NUMERIC(10,2) NOT NULL,
    field_02 NUMERIC(10,2) NOT NULL,
    field_03 INTEGER NULL,
    field_04 INTEGER NOT NULL,
    field_05 JSONB NOT NULL,
    field_06 JSONB NULL,
    field_07 INTEGER NOT NULL,
    field_08 NUMERIC(10,2) NOT NULL,
    field_09 TIMESTAMP NOT NULL,
    field_10 TEXT NOT NULL,
    field_11 NUMERIC(10,2) NULL,
    field_12 INTEGER NOT NULL,
    field_13 JSONB NOT NULL,
    field_14 NUMERIC(10,2) NULL,
    field_15 TEXT NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    deleted_at TIMESTAMP
);
CREATE INDEX idx_project_id ON benchmark.tb_project(id);
CREATE INDEX idx_project_identifier ON benchmark.tb_project(identifier);

CREATE OR REPLACE FUNCTION benchmark.create_project(
    p_field_00 TEXT
) RETURNS INTEGER AS $$
DECLARE
    v_pk_project INTEGER;
BEGIN
    INSERT INTO benchmark.tb_project (field_00)
    VALUES (p_field_00)
    RETURNING pk_project INTO v_pk_project;

    RETURN v_pk_project;
END;
$$ LANGUAGE plpgsql;


CREATE OR REPLACE FUNCTION benchmark.update_project(
    p_pk_project INTEGER,
    p_field_00 TEXT
) RETURNS VOID AS $$
BEGIN
    UPDATE benchmark.tb_project
    SET field_00 = p_field_00,
        updated_at = CURRENT_TIMESTAMP
    WHERE pk_project = p_pk_project;
END;
$$ LANGUAGE plpgsql;


CREATE TABLE benchmark.tb_task (
    pk_task SERIAL PRIMARY KEY,
    id UUID NOT NULL UNIQUE DEFAULT gen_random_uuid(),
    identifier TEXT NOT NULL UNIQUE,
    field_00 JSONB NOT NULL,
    field_01 JSONB NOT NULL,
    field_02 BOOLEAN NULL,
    field_03 TEXT NOT NULL,
    field_04 BOOLEAN NOT NULL,
    field_05 NUMERIC(10,2) NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    deleted_at TIMESTAMP
);
CREATE INDEX idx_task_id ON benchmark.tb_task(id);
CREATE INDEX idx_task_identifier ON benchmark.tb_task(identifier);

CREATE OR REPLACE FUNCTION benchmark.create_task(
    p_field_00 TEXT
) RETURNS INTEGER AS $$
DECLARE
    v_pk_task INTEGER;
BEGIN
    INSERT INTO benchmark.tb_task (field_00)
    VALUES (p_field_00)
    RETURNING pk_task INTO v_pk_task;

    RETURN v_pk_task;
END;
$$ LANGUAGE plpgsql;


CREATE TABLE benchmark.tb_contact (
    pk_contact SERIAL PRIMARY KEY,
    id UUID NOT NULL UNIQUE DEFAULT gen_random_uuid(),
    identifier TEXT NOT NULL UNIQUE,
    pk_order INTEGER NOT NULL REFERENCES benchmark.tb_order(pk_order),
    pk_shipment INTEGER NOT NULL REFERENCES benchmark.tb_shipment(pk_shipment),
    field_00 TEXT NULL,
    field_01 BOOLEAN NULL,
    field_02 TEXT NOT NULL,
    field_03 TEXT NOT NULL,
    field_04 JSONB NULL,
    field_05 INTEGER NOT NULL,
    field_06 NUMERIC(10,2) NULL,
    field_07 INTEGER NULL,
    field_08 BOOLEAN NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    deleted_at TIMESTAMP
);
CREATE INDEX idx_contact_id ON benchmark.tb_contact(id);
CREATE INDEX idx_contact_identifier ON benchmark.tb_contact(identifier);

CREATE OR REPLACE FUNCTION benchmark.create_contact(
    p_field_00 TEXT
) RETURNS INTEGER AS $$
DECLARE
    v_pk_contact INTEGER;
BEGIN
    INSERT INTO benchmark.tb_contact (field_00)
    VALUES (p_field_00)
    RETURNING pk_contact INTO v_pk_contact;

    RETURN v_pk_contact;
END;
$$ LANGUAGE plpgsql;


CREATE OR REPLACE FUNCTION benchmark.update_contact(
    p_pk_contact INTEGER,
    p_field_00 TEXT
) RETURNS VOID AS $$
BEGIN
    UPDATE benchmark.tb_contact
    SET field_00 = p_field_00,
        updated_at = CURRENT_TIMESTAMP
    WHERE pk_contact = p_pk_contact;
END;
$$ LANGUAGE plpgsql;


CREATE OR REPLACE FUNCTION benchmark.delete_contact(
    p_pk_contact INTEGER
) RETURNS VOID AS $$
BEGIN
    UPDATE benchmark.tb_contact
    SET deleted_at = CURRENT_TIMESTAMP
    WHERE pk_contact = p_pk_contact;
END;
$$ LANGUAGE plpgsql;


CREATE TABLE benchmark.tb_company (
    pk_company SERIAL PRIMARY KEY,
    id UUID NOT NULL UNIQUE DEFAULT gen_random_uuid(),
    identifier TEXT NOT NULL UNIQUE,
    field_00 TIMESTAMP NULL,
    field_01 TIMESTAMP NOT NULL,
    field_02 BOOLEAN NULL,
    field_03 TIMESTAMP NOT NULL,
    field_04 NUMERIC(10,2) NOT NULL,
    field_05 TEXT NOT NULL,
    field_06 JSONB NULL,
    field_07 INTEGER NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    deleted_at TIMESTAMP
);
CREATE INDEX idx_company_id ON benchmark.tb_company(id);
CREATE INDEX idx_company_identifier ON benchmark.tb_company(identifier);

CREATE OR REPLACE FUNCTION benchmark.create_company(
    p_field_00 TEXT
) RETURNS INTEGER AS $$
DECLARE
    v_pk_company INTEGER;
BEGIN
    INSERT INTO benchmark.tb_company (field_00)
    VALUES (p_field_00)
    RETURNING pk_company INTO v_pk_company;

    RETURN v_pk_company;
END;
$$ LANGUAGE plpgsql;


CREATE OR REPLACE FUNCTION benchmark.update_company(
    p_pk_company INTEGER,
    p_field_00 TEXT
) RETURNS VOID AS $$
BEGIN
    UPDATE benchmark.tb_company
    SET field_00 = p_field_00,
        updated_at = CURRENT_TIMESTAMP
    WHERE pk_company = p_pk_company;
END;
$$ LANGUAGE plpgsql;


CREATE TABLE benchmark.tb_account (
    pk_account SERIAL PRIMARY KEY,
    id UUID NOT NULL UNIQUE DEFAULT gen_random_uuid(),
    identifier TEXT NOT NULL UNIQUE,
    pk_product INTEGER NOT NULL REFERENCES benchmark.tb_product(pk_product),
    field_00 NUMERIC(10,2) NOT NULL,
    field_01 INTEGER NULL,
    field_02 TIMESTAMP NULL,
    field_03 TEXT NOT NULL,
    field_04 JSONB NOT NULL,
    field_05 NUMERIC(10,2) NULL,
    field_06 NUMERIC(10,2) NOT NULL,
    field_07 JSONB NOT NULL,
    field_08 TEXT NOT NULL,
    field_09 NUMERIC(10,2) NOT NULL,
    field_10 JSONB NOT NULL,
    field_11 INTEGER NOT NULL,
    field_12 TIMESTAMP NULL
);
CREATE INDEX idx_account_id ON benchmark.tb_account(id);
CREATE INDEX idx_account_identifier ON benchmark.tb_account(identifier);

CREATE OR REPLACE FUNCTION benchmark.create_account(
    p_field_00 TEXT
) RETURNS INTEGER AS $$
DECLARE
    v_pk_account INTEGER;
BEGIN
    INSERT INTO benchmark.tb_account (field_00)
    VALUES (p_field_00)
    RETURNING pk_account INTO v_pk_account;

    RETURN v_pk_account;
END;
$$ LANGUAGE plpgsql;


CREATE OR REPLACE FUNCTION benchmark.update_account(
    p_pk_account INTEGER,
    p_field_00 TEXT
) RETURNS VOID AS $$
BEGIN
    UPDATE benchmark.tb_account
    SET field_00 = p_field_00,
        updated_at = CURRENT_TIMESTAMP
    WHERE pk_account = p_pk_account;
END;
$$ LANGUAGE plpgsql;


CREATE OR REPLACE FUNCTION benchmark.delete_account(
    p_pk_account INTEGER
) RETURNS VOID AS $$
BEGIN
    UPDATE benchmark.tb_account
    SET deleted_at = CURRENT_TIMESTAMP
    WHERE pk_account = p_pk_account;
END;
$$ LANGUAGE plpgsql;


CREATE TABLE benchmark.tb_transaction (
    pk_transaction SERIAL PRIMARY KEY,
    id UUID NOT NULL UNIQUE DEFAULT gen_random_uuid(),
    identifier TEXT NOT NULL UNIQUE,
    field_00 INTEGER NOT NULL,
    field_01 INTEGER NULL,
    field_02 INTEGER NOT NULL,
    field_03 TIMESTAMP NOT NULL,
    field_04 TIMESTAMP NOT NULL,
    field_05 BOOLEAN NULL,
    field_06 JSONB NOT NULL,
    field_07 BOOLEAN NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    deleted_at TIMESTAMP
);
CREATE INDEX idx_transaction_id ON benchmark.tb_transaction(id);
CREATE INDEX idx_transaction_identifier ON benchmark.tb_transaction(identifier);

CREATE OR REPLACE FUNCTION benchmark.create_transaction(
    p_field_00 TEXT
) RETURNS INTEGER AS $$
DECLARE
    v_pk_transaction INTEGER;
BEGIN
    INSERT INTO benchmark.tb_transaction (field_00)
    VALUES (p_field_00)
    RETURNING pk_transaction INTO v_pk_transaction;

    RETURN v_pk_transaction;
END;
$$ LANGUAGE plpgsql;


CREATE OR REPLACE FUNCTION benchmark.update_transaction(
    p_pk_transaction INTEGER,
    p_field_00 TEXT
) RETURNS VOID AS $$
BEGIN
    UPDATE benchmark.tb_transaction
    SET field_00 = p_field_00,
        updated_at = CURRENT_TIMESTAMP
    WHERE pk_transaction = p_pk_transaction;
END;
$$ LANGUAGE plpgsql;


CREATE OR REPLACE FUNCTION benchmark.delete_transaction(
    p_pk_transaction INTEGER
) RETURNS VOID AS $$
BEGIN
    UPDATE benchmark.tb_transaction
    SET deleted_at = CURRENT_TIMESTAMP
    WHERE pk_transaction = p_pk_transaction;
END;
$$ LANGUAGE plpgsql;


CREATE TABLE benchmark.tb_report (
    pk_report SERIAL PRIMARY KEY,
    id UUID NOT NULL UNIQUE DEFAULT gen_random_uuid(),
    identifier TEXT NOT NULL UNIQUE,
    pk_employee INTEGER NOT NULL REFERENCES benchmark.tb_employee(pk_employee),
    field_00 TIMESTAMP NOT NULL,
    field_01 BOOLEAN NULL,
    field_02 TEXT NOT NULL,
    field_03 JSONB NOT NULL,
    field_04 NUMERIC(10,2) NULL,
    field_05 INTEGER NOT NULL,
    field_06 TIMESTAMP NOT NULL,
    field_07 TEXT NOT NULL,
    field_08 JSONB NOT NULL,
    field_09 TIMESTAMP NULL,
    field_10 INTEGER NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    deleted_at TIMESTAMP
);
CREATE INDEX idx_report_id ON benchmark.tb_report(id);
CREATE INDEX idx_report_identifier ON benchmark.tb_report(identifier);

CREATE OR REPLACE FUNCTION benchmark.create_report(
    p_field_00 TEXT
) RETURNS INTEGER AS $$
DECLARE
    v_pk_report INTEGER;
BEGIN
    INSERT INTO benchmark.tb_report (field_00)
    VALUES (p_field_00)
    RETURNING pk_report INTO v_pk_report;

    RETURN v_pk_report;
END;
$$ LANGUAGE plpgsql;


CREATE OR REPLACE FUNCTION benchmark.update_report(
    p_pk_report INTEGER,
    p_field_00 TEXT
) RETURNS VOID AS $$
BEGIN
    UPDATE benchmark.tb_report
    SET field_00 = p_field_00,
        updated_at = CURRENT_TIMESTAMP
    WHERE pk_report = p_pk_report;
END;
$$ LANGUAGE plpgsql;


CREATE OR REPLACE FUNCTION benchmark.delete_report(
    p_pk_report INTEGER
) RETURNS VOID AS $$
BEGIN
    UPDATE benchmark.tb_report
    SET deleted_at = CURRENT_TIMESTAMP
    WHERE pk_report = p_pk_report;
END;
$$ LANGUAGE plpgsql;


CREATE TABLE benchmark.tb_document (
    pk_document SERIAL PRIMARY KEY,
    id UUID NOT NULL UNIQUE DEFAULT gen_random_uuid(),
    identifier TEXT NOT NULL UNIQUE,
    field_00 JSONB NOT NULL,
    field_01 NUMERIC(10,2) NULL,
    field_02 TIMESTAMP NOT NULL,
    field_03 BOOLEAN NOT NULL,
    field_04 BOOLEAN NOT NULL,
    field_05 NUMERIC(10,2) NOT NULL,
    field_06 TEXT NOT NULL,
    field_07 NUMERIC(10,2) NOT NULL,
    field_08 BOOLEAN NULL,
    field_09 BOOLEAN NOT NULL,
    field_10 TIMESTAMP NULL,
    field_11 TEXT NOT NULL,
    field_12 NUMERIC(10,2) NULL,
    field_13 BOOLEAN NOT NULL,
    dedup_key TEXT,
    dedup_hash TEXT,
    is_unique BOOLEAN DEFAULT TRUE
);
CREATE INDEX idx_document_id ON benchmark.tb_document(id);
CREATE INDEX idx_document_identifier ON benchmark.tb_document(identifier);
CREATE INDEX idx_document_dedup_hash ON benchmark.tb_document(dedup_hash);

CREATE OR REPLACE FUNCTION benchmark.create_document(
    p_field_00 TEXT
) RETURNS INTEGER AS $$
DECLARE
    v_pk_document INTEGER;
BEGIN
    INSERT INTO benchmark.tb_document (field_00)
    VALUES (p_field_00)
    RETURNING pk_document INTO v_pk_document;

    RETURN v_pk_document;
END;
$$ LANGUAGE plpgsql;


CREATE OR REPLACE FUNCTION benchmark.update_document(
    p_pk_document INTEGER,
    p_field_00 TEXT
) RETURNS VOID AS $$
BEGIN
    UPDATE benchmark.tb_document
    SET field_00 = p_field_00,
        updated_at = CURRENT_TIMESTAMP
    WHERE pk_document = p_pk_document;
END;
$$ LANGUAGE plpgsql;


CREATE OR REPLACE FUNCTION benchmark.delete_document(
    p_pk_document INTEGER
) RETURNS VOID AS $$
BEGIN
    UPDATE benchmark.tb_document
    SET deleted_at = CURRENT_TIMESTAMP
    WHERE pk_document = p_pk_document;
END;
$$ LANGUAGE plpgsql;


CREATE TABLE benchmark.tb_message (
    pk_message SERIAL PRIMARY KEY,
    id UUID NOT NULL UNIQUE DEFAULT gen_random_uuid(),
    identifier TEXT NOT NULL UNIQUE,
    pk_order INTEGER NOT NULL REFERENCES benchmark.tb_order(pk_order),
    pk_transaction INTEGER NOT NULL REFERENCES benchmark.tb_transaction(pk_transaction),
    field_00 TEXT NOT NULL,
    field_01 TIMESTAMP NOT NULL,
    field_02 TEXT NULL,
    field_03 NUMERIC(10,2) NOT NULL,
    field_04 BOOLEAN NOT NULL,
    field_05 TEXT NULL,
    field_06 TIMESTAMP NULL,
    field_07 NUMERIC(10,2) NOT NULL,
    field_08 JSONB NOT NULL,
    field_09 TEXT NOT NULL,
    field_10 TIMESTAMP NOT NULL,
    field_11 JSONB NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    deleted_at TIMESTAMP
);
CREATE INDEX idx_message_id ON benchmark.tb_message(id);
CREATE INDEX idx_message_identifier ON benchmark.tb_message(identifier);

CREATE OR REPLACE FUNCTION benchmark.create_message(
    p_field_00 TEXT
) RETURNS INTEGER AS $$
DECLARE
    v_pk_message INTEGER;
BEGIN
    INSERT INTO benchmark.tb_message (field_00)
    VALUES (p_field_00)
    RETURNING pk_message INTO v_pk_message;

    RETURN v_pk_message;
END;
$$ LANGUAGE plpgsql;


CREATE OR REPLACE FUNCTION benchmark.update_message(
    p_pk_message INTEGER,
    p_field_00 TEXT
) RETURNS VOID AS $$
BEGIN
    UPDATE benchmark.tb_message
    SET field_00 = p_field_00,
        updated_at = CURRENT_TIMESTAMP
    WHERE pk_message = p_pk_message;
END;
$$ LANGUAGE plpgsql;


CREATE OR REPLACE FUNCTION benchmark.delete_message(
    p_pk_message INTEGER
) RETURNS VOID AS $$
BEGIN
    UPDATE benchmark.tb_message
    SET deleted_at = CURRENT_TIMESTAMP
    WHERE pk_message = p_pk_message;
END;
$$ LANGUAGE plpgsql;


CREATE TABLE benchmark.tb_notification (
    pk_notification SERIAL PRIMARY KEY,
    id UUID NOT NULL UNIQUE DEFAULT gen_random_uuid(),
    identifier TEXT NOT NULL UNIQUE,
    pk_company INTEGER NOT NULL REFERENCES benchmark.tb_company(pk_company),
    field_00 TIMESTAMP NULL,
    field_01 BOOLEAN NULL,
    field_02 TEXT NOT NULL,
    field_03 TEXT NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    deleted_at TIMESTAMP
);
CREATE INDEX idx_notification_id ON benchmark.tb_notification(id);
CREATE INDEX idx_notification_identifier ON benchmark.tb_notification(identifier);

CREATE OR REPLACE FUNCTION benchmark.create_notification(
    p_field_00 TEXT
) RETURNS INTEGER AS $$
DECLARE
    v_pk_notification INTEGER;
BEGIN
    INSERT INTO benchmark.tb_notification (field_00)
    VALUES (p_field_00)
    RETURNING pk_notification INTO v_pk_notification;

    RETURN v_pk_notification;
END;
$$ LANGUAGE plpgsql;


CREATE OR REPLACE FUNCTION benchmark.update_notification(
    p_pk_notification INTEGER,
    p_field_00 TEXT
) RETURNS VOID AS $$
BEGIN
    UPDATE benchmark.tb_notification
    SET field_00 = p_field_00,
        updated_at = CURRENT_TIMESTAMP
    WHERE pk_notification = p_pk_notification;
END;
$$ LANGUAGE plpgsql;


CREATE OR REPLACE FUNCTION benchmark.delete_notification(
    p_pk_notification INTEGER
) RETURNS VOID AS $$
BEGIN
    UPDATE benchmark.tb_notification
    SET deleted_at = CURRENT_TIMESTAMP
    WHERE pk_notification = p_pk_notification;
END;
$$ LANGUAGE plpgsql;


CREATE TABLE benchmark.tb_user (
    pk_user SERIAL PRIMARY KEY,
    id UUID NOT NULL UNIQUE DEFAULT gen_random_uuid(),
    identifier TEXT NOT NULL UNIQUE,
    pk_customer INTEGER NOT NULL REFERENCES benchmark.tb_customer(pk_customer),
    field_00 INTEGER NOT NULL,
    field_01 JSONB NULL,
    field_02 JSONB NULL,
    field_03 BOOLEAN NOT NULL,
    field_04 INTEGER NOT NULL,
    field_05 INTEGER NOT NULL,
    field_06 TIMESTAMP NOT NULL,
    field_07 INTEGER NOT NULL,
    field_08 NUMERIC(10,2) NOT NULL,
    field_09 BOOLEAN NOT NULL,
    field_10 TIMESTAMP NULL,
    field_11 TEXT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    deleted_at TIMESTAMP
);
CREATE INDEX idx_user_id ON benchmark.tb_user(id);
CREATE INDEX idx_user_identifier ON benchmark.tb_user(identifier);

CREATE OR REPLACE FUNCTION benchmark.create_user(
    p_field_00 TEXT
) RETURNS INTEGER AS $$
DECLARE
    v_pk_user INTEGER;
BEGIN
    INSERT INTO benchmark.tb_user (field_00)
    VALUES (p_field_00)
    RETURNING pk_user INTO v_pk_user;

    RETURN v_pk_user;
END;
$$ LANGUAGE plpgsql;


CREATE OR REPLACE FUNCTION benchmark.update_user(
    p_pk_user INTEGER,
    p_field_00 TEXT
) RETURNS VOID AS $$
BEGIN
    UPDATE benchmark.tb_user
    SET field_00 = p_field_00,
        updated_at = CURRENT_TIMESTAMP
    WHERE pk_user = p_pk_user;
END;
$$ LANGUAGE plpgsql;


CREATE OR REPLACE FUNCTION benchmark.delete_user(
    p_pk_user INTEGER
) RETURNS VOID AS $$
BEGIN
    UPDATE benchmark.tb_user
    SET deleted_at = CURRENT_TIMESTAMP
    WHERE pk_user = p_pk_user;
END;
$$ LANGUAGE plpgsql;


CREATE TABLE benchmark.tb_role (
    pk_role SERIAL PRIMARY KEY,
    id UUID NOT NULL UNIQUE DEFAULT gen_random_uuid(),
    identifier TEXT NOT NULL UNIQUE,
    pk_product INTEGER NOT NULL REFERENCES benchmark.tb_product(pk_product),
    field_00 NUMERIC(10,2) NOT NULL,
    field_01 TIMESTAMP NOT NULL,
    field_02 BOOLEAN NOT NULL,
    field_03 BOOLEAN NOT NULL,
    field_04 NUMERIC(10,2) NOT NULL,
    field_05 TIMESTAMP NOT NULL,
    field_06 NUMERIC(10,2) NOT NULL,
    field_07 JSONB NULL,
    field_08 BOOLEAN NULL,
    field_09 BOOLEAN NULL,
    field_10 JSONB NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    deleted_at TIMESTAMP
);
CREATE INDEX idx_role_id ON benchmark.tb_role(id);
CREATE INDEX idx_role_identifier ON benchmark.tb_role(identifier);

CREATE OR REPLACE FUNCTION benchmark.create_role(
    p_field_00 TEXT
) RETURNS INTEGER AS $$
DECLARE
    v_pk_role INTEGER;
BEGIN
    INSERT INTO benchmark.tb_role (field_00)
    VALUES (p_field_00)
    RETURNING pk_role INTO v_pk_role;

    RETURN v_pk_role;
END;
$$ LANGUAGE plpgsql;


CREATE OR REPLACE FUNCTION benchmark.update_role(
    p_pk_role INTEGER,
    p_field_00 TEXT
) RETURNS VOID AS $$
BEGIN
    UPDATE benchmark.tb_role
    SET field_00 = p_field_00,
        updated_at = CURRENT_TIMESTAMP
    WHERE pk_role = p_pk_role;
END;
$$ LANGUAGE plpgsql;


CREATE OR REPLACE FUNCTION benchmark.delete_role(
    p_pk_role INTEGER
) RETURNS VOID AS $$
BEGIN
    UPDATE benchmark.tb_role
    SET deleted_at = CURRENT_TIMESTAMP
    WHERE pk_role = p_pk_role;
END;
$$ LANGUAGE plpgsql;


CREATE TABLE benchmark.tb_permission (
    pk_permission SERIAL PRIMARY KEY,
    id UUID NOT NULL UNIQUE DEFAULT gen_random_uuid(),
    identifier TEXT NOT NULL UNIQUE,
    pk_account INTEGER NOT NULL REFERENCES benchmark.tb_account(pk_account),
    field_00 BOOLEAN NOT NULL,
    field_01 JSONB NOT NULL,
    field_02 JSONB NOT NULL,
    field_03 BOOLEAN NOT NULL,
    field_04 INTEGER NOT NULL,
    field_05 TIMESTAMP NOT NULL,
    field_06 TEXT NOT NULL,
    field_07 BOOLEAN NULL,
    field_08 BOOLEAN NULL,
    field_09 INTEGER NOT NULL,
    field_10 JSONB NOT NULL,
    field_11 TEXT NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    deleted_at TIMESTAMP
);
CREATE INDEX idx_permission_id ON benchmark.tb_permission(id);
CREATE INDEX idx_permission_identifier ON benchmark.tb_permission(identifier);

CREATE OR REPLACE FUNCTION benchmark.create_permission(
    p_field_00 TEXT
) RETURNS INTEGER AS $$
DECLARE
    v_pk_permission INTEGER;
BEGIN
    INSERT INTO benchmark.tb_permission (field_00)
    VALUES (p_field_00)
    RETURNING pk_permission INTO v_pk_permission;

    RETURN v_pk_permission;
END;
$$ LANGUAGE plpgsql;


CREATE OR REPLACE FUNCTION benchmark.update_permission(
    p_pk_permission INTEGER,
    p_field_00 TEXT
) RETURNS VOID AS $$
BEGIN
    UPDATE benchmark.tb_permission
    SET field_00 = p_field_00,
        updated_at = CURRENT_TIMESTAMP
    WHERE pk_permission = p_pk_permission;
END;
$$ LANGUAGE plpgsql;


CREATE OR REPLACE FUNCTION benchmark.delete_permission(
    p_pk_permission INTEGER
) RETURNS VOID AS $$
BEGIN
    UPDATE benchmark.tb_permission
    SET deleted_at = CURRENT_TIMESTAMP
    WHERE pk_permission = p_pk_permission;
END;
$$ LANGUAGE plpgsql;


CREATE TABLE benchmark.tb_audit (
    pk_audit SERIAL PRIMARY KEY,
    id UUID NOT NULL UNIQUE DEFAULT gen_random_uuid(),
    identifier TEXT NOT NULL UNIQUE,
    field_00 NUMERIC(10,2) NOT NULL,
    field_01 JSONB NOT NULL,
    field_02 TEXT NOT NULL,
    field_03 JSONB NOT NULL,
    field_04 BOOLEAN NOT NULL,
    field_05 JSONB NOT NULL,
    field_06 BOOLEAN NOT NULL,
    dedup_key TEXT,
    dedup_hash TEXT,
    is_unique BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    deleted_at TIMESTAMP
);
CREATE INDEX idx_audit_id ON benchmark.tb_audit(id);
CREATE INDEX idx_audit_identifier ON benchmark.tb_audit(identifier);
CREATE INDEX idx_audit_dedup_hash ON benchmark.tb_audit(dedup_hash);

CREATE OR REPLACE FUNCTION benchmark.create_audit(
    p_field_00 TEXT
) RETURNS INTEGER AS $$
DECLARE
    v_pk_audit INTEGER;
BEGIN
    INSERT INTO benchmark.tb_audit (field_00)
    VALUES (p_field_00)
    RETURNING pk_audit INTO v_pk_audit;

    RETURN v_pk_audit;
END;
$$ LANGUAGE plpgsql;


CREATE OR REPLACE FUNCTION benchmark.update_audit(
    p_pk_audit INTEGER,
    p_field_00 TEXT
) RETURNS VOID AS $$
BEGIN
    UPDATE benchmark.tb_audit
    SET field_00 = p_field_00,
        updated_at = CURRENT_TIMESTAMP
    WHERE pk_audit = p_pk_audit;
END;
$$ LANGUAGE plpgsql;


CREATE OR REPLACE FUNCTION benchmark.delete_audit(
    p_pk_audit INTEGER
) RETURNS VOID AS $$
BEGIN
    UPDATE benchmark.tb_audit
    SET deleted_at = CURRENT_TIMESTAMP
    WHERE pk_audit = p_pk_audit;
END;
$$ LANGUAGE plpgsql;


CREATE TABLE benchmark.tb_log (
    pk_log SERIAL PRIMARY KEY,
    id UUID NOT NULL UNIQUE DEFAULT gen_random_uuid(),
    identifier TEXT NOT NULL UNIQUE,
    pk_user INTEGER NOT NULL REFERENCES benchmark.tb_user(pk_user),
    pk_project INTEGER NOT NULL REFERENCES benchmark.tb_project(pk_project),
    field_00 TEXT NOT NULL,
    field_01 INTEGER NOT NULL,
    field_02 NUMERIC(10,2) NOT NULL,
    field_03 JSONB NULL,
    field_04 TEXT NOT NULL,
    field_05 JSONB NOT NULL,
    field_06 BOOLEAN NULL,
    field_07 NUMERIC(10,2) NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    deleted_at TIMESTAMP
);
CREATE INDEX idx_log_id ON benchmark.tb_log(id);
CREATE INDEX idx_log_identifier ON benchmark.tb_log(identifier);

CREATE OR REPLACE FUNCTION benchmark.create_log(
    p_field_00 TEXT
) RETURNS INTEGER AS $$
DECLARE
    v_pk_log INTEGER;
BEGIN
    INSERT INTO benchmark.tb_log (field_00)
    VALUES (p_field_00)
    RETURNING pk_log INTO v_pk_log;

    RETURN v_pk_log;
END;
$$ LANGUAGE plpgsql;


CREATE OR REPLACE FUNCTION benchmark.update_log(
    p_pk_log INTEGER,
    p_field_00 TEXT
) RETURNS VOID AS $$
BEGIN
    UPDATE benchmark.tb_log
    SET field_00 = p_field_00,
        updated_at = CURRENT_TIMESTAMP
    WHERE pk_log = p_pk_log;
END;
$$ LANGUAGE plpgsql;


CREATE OR REPLACE FUNCTION benchmark.delete_log(
    p_pk_log INTEGER
) RETURNS VOID AS $$
BEGIN
    UPDATE benchmark.tb_log
    SET deleted_at = CURRENT_TIMESTAMP
    WHERE pk_log = p_pk_log;
END;
$$ LANGUAGE plpgsql;


CREATE TABLE benchmark.tb_setting (
    pk_setting SERIAL PRIMARY KEY,
    id UUID NOT NULL UNIQUE DEFAULT gen_random_uuid(),
    identifier TEXT NOT NULL UNIQUE,
    pk_contact INTEGER NOT NULL REFERENCES benchmark.tb_contact(pk_contact),
    field_00 TEXT NOT NULL,
    field_01 TEXT NULL,
    field_02 NUMERIC(10,2) NOT NULL,
    field_03 INTEGER NOT NULL,
    field_04 TIMESTAMP NOT NULL,
    field_05 INTEGER NULL,
    field_06 TEXT NOT NULL,
    field_07 BOOLEAN NOT NULL,
    field_08 INTEGER NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    deleted_at TIMESTAMP
);
CREATE INDEX idx_setting_id ON benchmark.tb_setting(id);
CREATE INDEX idx_setting_identifier ON benchmark.tb_setting(identifier);

CREATE OR REPLACE FUNCTION benchmark.create_setting(
    p_field_00 TEXT
) RETURNS INTEGER AS $$
DECLARE
    v_pk_setting INTEGER;
BEGIN
    INSERT INTO benchmark.tb_setting (field_00)
    VALUES (p_field_00)
    RETURNING pk_setting INTO v_pk_setting;

    RETURN v_pk_setting;
END;
$$ LANGUAGE plpgsql;


CREATE TABLE benchmark.tb_configuration (
    pk_configuration SERIAL PRIMARY KEY,
    id UUID NOT NULL UNIQUE DEFAULT gen_random_uuid(),
    identifier TEXT NOT NULL UNIQUE,
    pk_user INTEGER NOT NULL REFERENCES benchmark.tb_user(pk_user),
    field_00 TIMESTAMP NULL,
    field_01 BOOLEAN NOT NULL,
    field_02 BOOLEAN NULL,
    field_03 TEXT NOT NULL,
    field_04 BOOLEAN NOT NULL,
    field_05 JSONB NOT NULL,
    field_06 TEXT NOT NULL,
    field_07 NUMERIC(10,2) NOT NULL,
    field_08 NUMERIC(10,2) NOT NULL,
    field_09 BOOLEAN NOT NULL,
    field_10 BOOLEAN NOT NULL,
    field_11 INTEGER NOT NULL,
    field_12 BOOLEAN NULL,
    field_13 BOOLEAN NOT NULL,
    field_14 TIMESTAMP NULL,
    field_15 JSONB NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    deleted_at TIMESTAMP
);
CREATE INDEX idx_configuration_id ON benchmark.tb_configuration(id);
CREATE INDEX idx_configuration_identifier ON benchmark.tb_configuration(identifier);

CREATE OR REPLACE FUNCTION benchmark.create_configuration(
    p_field_00 TEXT
) RETURNS INTEGER AS $$
DECLARE
    v_pk_configuration INTEGER;
BEGIN
    INSERT INTO benchmark.tb_configuration (field_00)
    VALUES (p_field_00)
    RETURNING pk_configuration INTO v_pk_configuration;

    RETURN v_pk_configuration;
END;
$$ LANGUAGE plpgsql;


CREATE OR REPLACE FUNCTION benchmark.update_configuration(
    p_pk_configuration INTEGER,
    p_field_00 TEXT
) RETURNS VOID AS $$
BEGIN
    UPDATE benchmark.tb_configuration
    SET field_00 = p_field_00,
        updated_at = CURRENT_TIMESTAMP
    WHERE pk_configuration = p_pk_configuration;
END;
$$ LANGUAGE plpgsql;


CREATE OR REPLACE FUNCTION benchmark.delete_configuration(
    p_pk_configuration INTEGER
) RETURNS VOID AS $$
BEGIN
    UPDATE benchmark.tb_configuration
    SET deleted_at = CURRENT_TIMESTAMP
    WHERE pk_configuration = p_pk_configuration;
END;
$$ LANGUAGE plpgsql;


CREATE TABLE benchmark.tb_entity025 (
    pk_entity025 SERIAL PRIMARY KEY,
    id UUID NOT NULL UNIQUE DEFAULT gen_random_uuid(),
    identifier TEXT NOT NULL UNIQUE,
    pk_message INTEGER NOT NULL REFERENCES benchmark.tb_message(pk_message),
    pk_notification INTEGER NOT NULL REFERENCES benchmark.tb_notification(pk_notification),
    field_00 JSONB NOT NULL,
    field_01 TEXT NOT NULL,
    field_02 JSONB NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    deleted_at TIMESTAMP
);
CREATE INDEX idx_entity025_id ON benchmark.tb_entity025(id);
CREATE INDEX idx_entity025_identifier ON benchmark.tb_entity025(identifier);

CREATE OR REPLACE FUNCTION benchmark.create_entity025(
    p_field_00 TEXT
) RETURNS INTEGER AS $$
DECLARE
    v_pk_entity025 INTEGER;
BEGIN
    INSERT INTO benchmark.tb_entity025 (field_00)
    VALUES (p_field_00)
    RETURNING pk_entity025 INTO v_pk_entity025;

    RETURN v_pk_entity025;
END;
$$ LANGUAGE plpgsql;


CREATE OR REPLACE FUNCTION benchmark.update_entity025(
    p_pk_entity025 INTEGER,
    p_field_00 TEXT
) RETURNS VOID AS $$
BEGIN
    UPDATE benchmark.tb_entity025
    SET field_00 = p_field_00,
        updated_at = CURRENT_TIMESTAMP
    WHERE pk_entity025 = p_pk_entity025;
END;
$$ LANGUAGE plpgsql;


CREATE TABLE benchmark.tb_entity026 (
    pk_entity026 SERIAL PRIMARY KEY,
    id UUID NOT NULL UNIQUE DEFAULT gen_random_uuid(),
    identifier TEXT NOT NULL UNIQUE,
    field_00 TEXT NOT NULL,
    field_01 JSONB NOT NULL,
    field_02 NUMERIC(10,2) NOT NULL,
    field_03 INTEGER NOT NULL,
    field_04 NUMERIC(10,2) NULL,
    field_05 INTEGER NOT NULL,
    field_06 JSONB NOT NULL,
    field_07 JSONB NOT NULL,
    field_08 INTEGER NOT NULL,
    field_09 JSONB NOT NULL,
    field_10 NUMERIC(10,2) NOT NULL,
    field_11 TEXT NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    deleted_at TIMESTAMP
);
CREATE INDEX idx_entity026_id ON benchmark.tb_entity026(id);
CREATE INDEX idx_entity026_identifier ON benchmark.tb_entity026(identifier);

CREATE OR REPLACE FUNCTION benchmark.create_entity026(
    p_field_00 TEXT
) RETURNS INTEGER AS $$
DECLARE
    v_pk_entity026 INTEGER;
BEGIN
    INSERT INTO benchmark.tb_entity026 (field_00)
    VALUES (p_field_00)
    RETURNING pk_entity026 INTO v_pk_entity026;

    RETURN v_pk_entity026;
END;
$$ LANGUAGE plpgsql;


CREATE OR REPLACE FUNCTION benchmark.update_entity026(
    p_pk_entity026 INTEGER,
    p_field_00 TEXT
) RETURNS VOID AS $$
BEGIN
    UPDATE benchmark.tb_entity026
    SET field_00 = p_field_00,
        updated_at = CURRENT_TIMESTAMP
    WHERE pk_entity026 = p_pk_entity026;
END;
$$ LANGUAGE plpgsql;


CREATE OR REPLACE FUNCTION benchmark.delete_entity026(
    p_pk_entity026 INTEGER
) RETURNS VOID AS $$
BEGIN
    UPDATE benchmark.tb_entity026
    SET deleted_at = CURRENT_TIMESTAMP
    WHERE pk_entity026 = p_pk_entity026;
END;
$$ LANGUAGE plpgsql;


CREATE TABLE benchmark.tb_entity027 (
    pk_entity027 SERIAL PRIMARY KEY,
    pk_contact INTEGER NOT NULL REFERENCES benchmark.tb_contact(pk_contact),
    field_00 JSONB NULL,
    field_01 NUMERIC(10,2) NOT NULL,
    field_02 BOOLEAN NULL,
    field_03 INTEGER NOT NULL,
    field_04 NUMERIC(10,2) NOT NULL,
    field_05 NUMERIC(10,2) NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    deleted_at TIMESTAMP
);

CREATE OR REPLACE FUNCTION benchmark.create_entity027(
    p_field_00 TEXT
) RETURNS INTEGER AS $$
DECLARE
    v_pk_entity027 INTEGER;
BEGIN
    INSERT INTO benchmark.tb_entity027 (field_00)
    VALUES (p_field_00)
    RETURNING pk_entity027 INTO v_pk_entity027;

    RETURN v_pk_entity027;
END;
$$ LANGUAGE plpgsql;


CREATE TABLE benchmark.tb_entity028 (
    pk_entity028 SERIAL PRIMARY KEY,
    id UUID NOT NULL UNIQUE DEFAULT gen_random_uuid(),
    identifier TEXT NOT NULL UNIQUE,
    pk_task INTEGER NOT NULL REFERENCES benchmark.tb_task(pk_task),
    field_00 NUMERIC(10,2) NOT NULL,
    field_01 BOOLEAN NOT NULL,
    field_02 NUMERIC(10,2) NOT NULL,
    field_03 NUMERIC(10,2) NOT NULL,
    field_04 BOOLEAN NOT NULL,
    field_05 INTEGER NOT NULL,
    field_06 INTEGER NOT NULL,
    field_07 JSONB NOT NULL,
    field_08 BOOLEAN NOT NULL,
    field_09 TIMESTAMP NOT NULL,
    field_10 BOOLEAN NULL,
    field_11 TIMESTAMP NULL,
    field_12 NUMERIC(10,2) NOT NULL,
    field_13 JSONB NULL,
    field_14 BOOLEAN NOT NULL,
    field_15 NUMERIC(10,2) NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    deleted_at TIMESTAMP
);
CREATE INDEX idx_entity028_id ON benchmark.tb_entity028(id);
CREATE INDEX idx_entity028_identifier ON benchmark.tb_entity028(identifier);

CREATE OR REPLACE FUNCTION benchmark.create_entity028(
    p_field_00 TEXT
) RETURNS INTEGER AS $$
DECLARE
    v_pk_entity028 INTEGER;
BEGIN
    INSERT INTO benchmark.tb_entity028 (field_00)
    VALUES (p_field_00)
    RETURNING pk_entity028 INTO v_pk_entity028;

    RETURN v_pk_entity028;
END;
$$ LANGUAGE plpgsql;


CREATE TABLE benchmark.tb_entity029 (
    pk_entity029 SERIAL PRIMARY KEY,
    id UUID NOT NULL UNIQUE DEFAULT gen_random_uuid(),
    identifier TEXT NOT NULL UNIQUE,
    field_00 INTEGER NOT NULL,
    field_01 TIMESTAMP NOT NULL,
    field_02 TIMESTAMP NOT NULL,
    field_03 TIMESTAMP NULL,
    field_04 TEXT NOT NULL,
    field_05 BOOLEAN NOT NULL,
    field_06 NUMERIC(10,2) NOT NULL,
    field_07 TEXT NULL,
    field_08 TEXT NOT NULL,
    field_09 BOOLEAN NULL,
    field_10 INTEGER NOT NULL,
    field_11 INTEGER NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    deleted_at TIMESTAMP
);
CREATE INDEX idx_entity029_id ON benchmark.tb_entity029(id);
CREATE INDEX idx_entity029_identifier ON benchmark.tb_entity029(identifier);

CREATE OR REPLACE FUNCTION benchmark.create_entity029(
    p_field_00 TEXT
) RETURNS INTEGER AS $$
DECLARE
    v_pk_entity029 INTEGER;
BEGIN
    INSERT INTO benchmark.tb_entity029 (field_00)
    VALUES (p_field_00)
    RETURNING pk_entity029 INTO v_pk_entity029;

    RETURN v_pk_entity029;
END;
$$ LANGUAGE plpgsql;


CREATE OR REPLACE FUNCTION benchmark.update_entity029(
    p_pk_entity029 INTEGER,
    p_field_00 TEXT
) RETURNS VOID AS $$
BEGIN
    UPDATE benchmark.tb_entity029
    SET field_00 = p_field_00,
        updated_at = CURRENT_TIMESTAMP
    WHERE pk_entity029 = p_pk_entity029;
END;
$$ LANGUAGE plpgsql;


CREATE OR REPLACE FUNCTION benchmark.delete_entity029(
    p_pk_entity029 INTEGER
) RETURNS VOID AS $$
BEGIN
    UPDATE benchmark.tb_entity029
    SET deleted_at = CURRENT_TIMESTAMP
    WHERE pk_entity029 = p_pk_entity029;
END;
$$ LANGUAGE plpgsql;


CREATE TABLE benchmark.tb_entity030 (
    pk_entity030 SERIAL PRIMARY KEY,
    id UUID NOT NULL UNIQUE DEFAULT gen_random_uuid(),
    identifier TEXT NOT NULL UNIQUE,
    pk_audit INTEGER NOT NULL REFERENCES benchmark.tb_audit(pk_audit),
    field_00 NUMERIC(10,2) NOT NULL,
    field_01 JSONB NOT NULL,
    field_02 TIMESTAMP NOT NULL,
    field_03 JSONB NOT NULL,
    field_04 BOOLEAN NOT NULL,
    field_05 BOOLEAN NOT NULL,
    field_06 NUMERIC(10,2) NULL,
    field_07 NUMERIC(10,2) NULL,
    field_08 BOOLEAN NOT NULL,
    field_09 NUMERIC(10,2) NULL,
    field_10 JSONB NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    deleted_at TIMESTAMP
);
CREATE INDEX idx_entity030_id ON benchmark.tb_entity030(id);
CREATE INDEX idx_entity030_identifier ON benchmark.tb_entity030(identifier);

CREATE OR REPLACE FUNCTION benchmark.create_entity030(
    p_field_00 TEXT
) RETURNS INTEGER AS $$
DECLARE
    v_pk_entity030 INTEGER;
BEGIN
    INSERT INTO benchmark.tb_entity030 (field_00)
    VALUES (p_field_00)
    RETURNING pk_entity030 INTO v_pk_entity030;

    RETURN v_pk_entity030;
END;
$$ LANGUAGE plpgsql;


CREATE OR REPLACE FUNCTION benchmark.update_entity030(
    p_pk_entity030 INTEGER,
    p_field_00 TEXT
) RETURNS VOID AS $$
BEGIN
    UPDATE benchmark.tb_entity030
    SET field_00 = p_field_00,
        updated_at = CURRENT_TIMESTAMP
    WHERE pk_entity030 = p_pk_entity030;
END;
$$ LANGUAGE plpgsql;


CREATE OR REPLACE FUNCTION benchmark.delete_entity030(
    p_pk_entity030 INTEGER
) RETURNS VOID AS $$
BEGIN
    UPDATE benchmark.tb_entity030
    SET deleted_at = CURRENT_TIMESTAMP
    WHERE pk_entity030 = p_pk_entity030;
END;
$$ LANGUAGE plpgsql;


CREATE TABLE benchmark.tb_entity031 (
    pk_entity031 SERIAL PRIMARY KEY,
    id UUID NOT NULL UNIQUE DEFAULT gen_random_uuid(),
    identifier TEXT NOT NULL UNIQUE,
    field_00 JSONB NOT NULL,
    field_01 BOOLEAN NULL,
    field_02 TEXT NOT NULL,
    field_03 BOOLEAN NULL,
    field_04 INTEGER NOT NULL,
    field_05 TIMESTAMP NOT NULL,
    field_06 TEXT NOT NULL,
    field_07 INTEGER NOT NULL,
    field_08 TIMESTAMP NULL,
    field_09 TIMESTAMP NULL,
    field_10 INTEGER NOT NULL,
    field_11 INTEGER NOT NULL,
    field_12 INTEGER NOT NULL,
    field_13 TIMESTAMP NULL,
    field_14 INTEGER NOT NULL,
    field_15 TIMESTAMP NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    deleted_at TIMESTAMP
);
CREATE INDEX idx_entity031_id ON benchmark.tb_entity031(id);
CREATE INDEX idx_entity031_identifier ON benchmark.tb_entity031(identifier);

CREATE OR REPLACE FUNCTION benchmark.create_entity031(
    p_field_00 TEXT
) RETURNS INTEGER AS $$
DECLARE
    v_pk_entity031 INTEGER;
BEGIN
    INSERT INTO benchmark.tb_entity031 (field_00)
    VALUES (p_field_00)
    RETURNING pk_entity031 INTO v_pk_entity031;

    RETURN v_pk_entity031;
END;
$$ LANGUAGE plpgsql;


CREATE TABLE benchmark.tb_entity032 (
    pk_entity032 SERIAL PRIMARY KEY,
    id UUID NOT NULL UNIQUE DEFAULT gen_random_uuid(),
    identifier TEXT NOT NULL UNIQUE,
    field_00 INTEGER NULL,
    field_01 TEXT NULL,
    field_02 NUMERIC(10,2) NOT NULL,
    field_03 INTEGER NOT NULL,
    field_04 TEXT NULL,
    field_05 TEXT NULL,
    field_06 BOOLEAN NOT NULL,
    field_07 JSONB NULL,
    field_08 BOOLEAN NOT NULL,
    field_09 TIMESTAMP NOT NULL,
    dedup_key TEXT,
    dedup_hash TEXT,
    is_unique BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    deleted_at TIMESTAMP
);
CREATE INDEX idx_entity032_id ON benchmark.tb_entity032(id);
CREATE INDEX idx_entity032_identifier ON benchmark.tb_entity032(identifier);
CREATE INDEX idx_entity032_dedup_hash ON benchmark.tb_entity032(dedup_hash);

CREATE OR REPLACE FUNCTION benchmark.create_entity032(
    p_field_00 TEXT
) RETURNS INTEGER AS $$
DECLARE
    v_pk_entity032 INTEGER;
BEGIN
    INSERT INTO benchmark.tb_entity032 (field_00)
    VALUES (p_field_00)
    RETURNING pk_entity032 INTO v_pk_entity032;

    RETURN v_pk_entity032;
END;
$$ LANGUAGE plpgsql;


CREATE TABLE benchmark.tb_entity033 (
    pk_entity033 SERIAL PRIMARY KEY,
    id UUID NOT NULL UNIQUE DEFAULT gen_random_uuid(),
    identifier TEXT NOT NULL UNIQUE,
    pk_permission INTEGER NOT NULL REFERENCES benchmark.tb_permission(pk_permission),
    pk_entity029 INTEGER NOT NULL REFERENCES benchmark.tb_entity029(pk_entity029),
    field_00 BOOLEAN NOT NULL,
    field_01 TIMESTAMP NULL,
    field_02 JSONB NOT NULL,
    field_03 BOOLEAN NOT NULL,
    field_04 TEXT NULL,
    field_05 BOOLEAN NOT NULL,
    field_06 BOOLEAN NOT NULL,
    field_07 BOOLEAN NOT NULL,
    field_08 BOOLEAN NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    deleted_at TIMESTAMP
);
CREATE INDEX idx_entity033_id ON benchmark.tb_entity033(id);
CREATE INDEX idx_entity033_identifier ON benchmark.tb_entity033(identifier);

CREATE OR REPLACE FUNCTION benchmark.create_entity033(
    p_field_00 TEXT
) RETURNS INTEGER AS $$
DECLARE
    v_pk_entity033 INTEGER;
BEGIN
    INSERT INTO benchmark.tb_entity033 (field_00)
    VALUES (p_field_00)
    RETURNING pk_entity033 INTO v_pk_entity033;

    RETURN v_pk_entity033;
END;
$$ LANGUAGE plpgsql;


CREATE OR REPLACE FUNCTION benchmark.update_entity033(
    p_pk_entity033 INTEGER,
    p_field_00 TEXT
) RETURNS VOID AS $$
BEGIN
    UPDATE benchmark.tb_entity033
    SET field_00 = p_field_00,
        updated_at = CURRENT_TIMESTAMP
    WHERE pk_entity033 = p_pk_entity033;
END;
$$ LANGUAGE plpgsql;


CREATE TABLE benchmark.tb_entity034 (
    pk_entity034 SERIAL PRIMARY KEY,
    id UUID NOT NULL UNIQUE DEFAULT gen_random_uuid(),
    identifier TEXT NOT NULL UNIQUE,
    field_00 TEXT NOT NULL,
    field_01 INTEGER NULL,
    field_02 NUMERIC(10,2) NOT NULL,
    field_03 TIMESTAMP NOT NULL,
    field_04 NUMERIC(10,2) NOT NULL,
    field_05 TIMESTAMP NOT NULL,
    field_06 BOOLEAN NOT NULL,
    field_07 BOOLEAN NULL,
    field_08 JSONB NULL,
    field_09 JSONB NOT NULL,
    field_10 TIMESTAMP NOT NULL,
    field_11 INTEGER NOT NULL,
    field_12 INTEGER NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    deleted_at TIMESTAMP
);
CREATE INDEX idx_entity034_id ON benchmark.tb_entity034(id);
CREATE INDEX idx_entity034_identifier ON benchmark.tb_entity034(identifier);

CREATE OR REPLACE FUNCTION benchmark.create_entity034(
    p_field_00 TEXT
) RETURNS INTEGER AS $$
DECLARE
    v_pk_entity034 INTEGER;
BEGIN
    INSERT INTO benchmark.tb_entity034 (field_00)
    VALUES (p_field_00)
    RETURNING pk_entity034 INTO v_pk_entity034;

    RETURN v_pk_entity034;
END;
$$ LANGUAGE plpgsql;


CREATE TABLE benchmark.tb_entity035 (
    pk_entity035 SERIAL PRIMARY KEY,
    field_00 BOOLEAN NOT NULL,
    field_01 JSONB NULL,
    field_02 BOOLEAN NOT NULL,
    field_03 NUMERIC(10,2) NOT NULL,
    field_04 INTEGER NOT NULL,
    field_05 BOOLEAN NULL,
    field_06 TEXT NULL,
    field_07 TEXT NOT NULL,
    field_08 NUMERIC(10,2) NOT NULL,
    field_09 TIMESTAMP NULL,
    field_10 TIMESTAMP NOT NULL,
    field_11 JSONB NULL,
    field_12 NUMERIC(10,2) NOT NULL,
    field_13 BOOLEAN NOT NULL,
    field_14 JSONB NULL,
    dedup_key TEXT,
    dedup_hash TEXT,
    is_unique BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    deleted_at TIMESTAMP
);
CREATE INDEX idx_entity035_dedup_hash ON benchmark.tb_entity035(dedup_hash);

CREATE OR REPLACE FUNCTION benchmark.create_entity035(
    p_field_00 TEXT
) RETURNS INTEGER AS $$
DECLARE
    v_pk_entity035 INTEGER;
BEGIN
    INSERT INTO benchmark.tb_entity035 (field_00)
    VALUES (p_field_00)
    RETURNING pk_entity035 INTO v_pk_entity035;

    RETURN v_pk_entity035;
END;
$$ LANGUAGE plpgsql;


CREATE OR REPLACE FUNCTION benchmark.update_entity035(
    p_pk_entity035 INTEGER,
    p_field_00 TEXT
) RETURNS VOID AS $$
BEGIN
    UPDATE benchmark.tb_entity035
    SET field_00 = p_field_00,
        updated_at = CURRENT_TIMESTAMP
    WHERE pk_entity035 = p_pk_entity035;
END;
$$ LANGUAGE plpgsql;


CREATE OR REPLACE FUNCTION benchmark.delete_entity035(
    p_pk_entity035 INTEGER
) RETURNS VOID AS $$
BEGIN
    UPDATE benchmark.tb_entity035
    SET deleted_at = CURRENT_TIMESTAMP
    WHERE pk_entity035 = p_pk_entity035;
END;
$$ LANGUAGE plpgsql;


CREATE TABLE benchmark.tb_entity036 (
    pk_entity036 SERIAL PRIMARY KEY,
    pk_audit INTEGER NOT NULL REFERENCES benchmark.tb_audit(pk_audit),
    field_00 NUMERIC(10,2) NOT NULL,
    field_01 NUMERIC(10,2) NULL,
    field_02 TIMESTAMP NULL,
    field_03 JSONB NOT NULL,
    field_04 TEXT NOT NULL,
    field_05 TIMESTAMP NOT NULL,
    field_06 NUMERIC(10,2) NOT NULL,
    field_07 BOOLEAN NOT NULL,
    field_08 TIMESTAMP NOT NULL,
    field_09 JSONB NOT NULL,
    field_10 TIMESTAMP NOT NULL,
    field_11 JSONB NULL,
    field_12 INTEGER NULL,
    field_13 NUMERIC(10,2) NOT NULL,
    field_14 NUMERIC(10,2) NULL,
    field_15 INTEGER NOT NULL,
    field_16 BOOLEAN NULL,
    field_17 JSONB NOT NULL,
    field_18 TEXT NULL,
    field_19 TIMESTAMP NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    deleted_at TIMESTAMP
);

CREATE OR REPLACE FUNCTION benchmark.create_entity036(
    p_field_00 TEXT
) RETURNS INTEGER AS $$
DECLARE
    v_pk_entity036 INTEGER;
BEGIN
    INSERT INTO benchmark.tb_entity036 (field_00)
    VALUES (p_field_00)
    RETURNING pk_entity036 INTO v_pk_entity036;

    RETURN v_pk_entity036;
END;
$$ LANGUAGE plpgsql;


CREATE OR REPLACE FUNCTION benchmark.update_entity036(
    p_pk_entity036 INTEGER,
    p_field_00 TEXT
) RETURNS VOID AS $$
BEGIN
    UPDATE benchmark.tb_entity036
    SET field_00 = p_field_00,
        updated_at = CURRENT_TIMESTAMP
    WHERE pk_entity036 = p_pk_entity036;
END;
$$ LANGUAGE plpgsql;


CREATE TABLE benchmark.tb_entity037 (
    pk_entity037 SERIAL PRIMARY KEY,
    pk_role INTEGER NOT NULL REFERENCES benchmark.tb_role(pk_role),
    pk_report INTEGER NOT NULL REFERENCES benchmark.tb_report(pk_report),
    field_00 BOOLEAN NOT NULL,
    field_01 INTEGER NOT NULL,
    field_02 JSONB NOT NULL,
    field_03 TIMESTAMP NOT NULL,
    field_04 TEXT NULL,
    field_05 TIMESTAMP NULL,
    field_06 TEXT NULL,
    field_07 JSONB NOT NULL,
    field_08 TIMESTAMP NOT NULL,
    field_09 NUMERIC(10,2) NULL,
    dedup_key TEXT,
    dedup_hash TEXT,
    is_unique BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    deleted_at TIMESTAMP
);
CREATE INDEX idx_entity037_dedup_hash ON benchmark.tb_entity037(dedup_hash);

CREATE OR REPLACE FUNCTION benchmark.create_entity037(
    p_field_00 TEXT
) RETURNS INTEGER AS $$
DECLARE
    v_pk_entity037 INTEGER;
BEGIN
    INSERT INTO benchmark.tb_entity037 (field_00)
    VALUES (p_field_00)
    RETURNING pk_entity037 INTO v_pk_entity037;

    RETURN v_pk_entity037;
END;
$$ LANGUAGE plpgsql;


CREATE OR REPLACE FUNCTION benchmark.update_entity037(
    p_pk_entity037 INTEGER,
    p_field_00 TEXT
) RETURNS VOID AS $$
BEGIN
    UPDATE benchmark.tb_entity037
    SET field_00 = p_field_00,
        updated_at = CURRENT_TIMESTAMP
    WHERE pk_entity037 = p_pk_entity037;
END;
$$ LANGUAGE plpgsql;


CREATE OR REPLACE FUNCTION benchmark.delete_entity037(
    p_pk_entity037 INTEGER
) RETURNS VOID AS $$
BEGIN
    UPDATE benchmark.tb_entity037
    SET deleted_at = CURRENT_TIMESTAMP
    WHERE pk_entity037 = p_pk_entity037;
END;
$$ LANGUAGE plpgsql;


CREATE TABLE benchmark.tb_entity038 (
    pk_entity038 SERIAL PRIMARY KEY,
    id UUID NOT NULL UNIQUE DEFAULT gen_random_uuid(),
    identifier TEXT NOT NULL UNIQUE,
    pk_entity030 INTEGER NOT NULL REFERENCES benchmark.tb_entity030(pk_entity030),
    pk_payment INTEGER NOT NULL REFERENCES benchmark.tb_payment(pk_payment),
    field_00 TIMESTAMP NULL,
    field_01 BOOLEAN NULL,
    field_02 JSONB NOT NULL,
    field_03 BOOLEAN NOT NULL,
    field_04 NUMERIC(10,2) NULL,
    field_05 BOOLEAN NOT NULL,
    field_06 TEXT NULL,
    field_07 NUMERIC(10,2) NOT NULL,
    field_08 INTEGER NOT NULL,
    field_09 NUMERIC(10,2) NOT NULL,
    field_10 TEXT NOT NULL,
    field_11 BOOLEAN NULL,
    field_12 BOOLEAN NOT NULL,
    field_13 INTEGER NOT NULL,
    field_14 JSONB NOT NULL,
    field_15 TEXT NOT NULL,
    field_16 JSONB NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    deleted_at TIMESTAMP
);
CREATE INDEX idx_entity038_id ON benchmark.tb_entity038(id);
CREATE INDEX idx_entity038_identifier ON benchmark.tb_entity038(identifier);

CREATE OR REPLACE FUNCTION benchmark.create_entity038(
    p_field_00 TEXT
) RETURNS INTEGER AS $$
DECLARE
    v_pk_entity038 INTEGER;
BEGIN
    INSERT INTO benchmark.tb_entity038 (field_00)
    VALUES (p_field_00)
    RETURNING pk_entity038 INTO v_pk_entity038;

    RETURN v_pk_entity038;
END;
$$ LANGUAGE plpgsql;


CREATE OR REPLACE FUNCTION benchmark.update_entity038(
    p_pk_entity038 INTEGER,
    p_field_00 TEXT
) RETURNS VOID AS $$
BEGIN
    UPDATE benchmark.tb_entity038
    SET field_00 = p_field_00,
        updated_at = CURRENT_TIMESTAMP
    WHERE pk_entity038 = p_pk_entity038;
END;
$$ LANGUAGE plpgsql;


CREATE OR REPLACE FUNCTION benchmark.delete_entity038(
    p_pk_entity038 INTEGER
) RETURNS VOID AS $$
BEGIN
    UPDATE benchmark.tb_entity038
    SET deleted_at = CURRENT_TIMESTAMP
    WHERE pk_entity038 = p_pk_entity038;
END;
$$ LANGUAGE plpgsql;


CREATE TABLE benchmark.tb_entity039 (
    pk_entity039 SERIAL PRIMARY KEY,
    id UUID NOT NULL UNIQUE DEFAULT gen_random_uuid(),
    identifier TEXT NOT NULL UNIQUE,
    field_00 TEXT NOT NULL,
    field_01 TEXT NOT NULL,
    field_02 TIMESTAMP NOT NULL,
    field_03 BOOLEAN NOT NULL,
    field_04 BOOLEAN NULL,
    field_05 BOOLEAN NULL,
    field_06 NUMERIC(10,2) NULL,
    field_07 TIMESTAMP NOT NULL,
    field_08 JSONB NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    deleted_at TIMESTAMP
);
CREATE INDEX idx_entity039_id ON benchmark.tb_entity039(id);
CREATE INDEX idx_entity039_identifier ON benchmark.tb_entity039(identifier);

CREATE OR REPLACE FUNCTION benchmark.create_entity039(
    p_field_00 TEXT
) RETURNS INTEGER AS $$
DECLARE
    v_pk_entity039 INTEGER;
BEGIN
    INSERT INTO benchmark.tb_entity039 (field_00)
    VALUES (p_field_00)
    RETURNING pk_entity039 INTO v_pk_entity039;

    RETURN v_pk_entity039;
END;
$$ LANGUAGE plpgsql;


CREATE OR REPLACE FUNCTION benchmark.update_entity039(
    p_pk_entity039 INTEGER,
    p_field_00 TEXT
) RETURNS VOID AS $$
BEGIN
    UPDATE benchmark.tb_entity039
    SET field_00 = p_field_00,
        updated_at = CURRENT_TIMESTAMP
    WHERE pk_entity039 = p_pk_entity039;
END;
$$ LANGUAGE plpgsql;


CREATE OR REPLACE FUNCTION benchmark.delete_entity039(
    p_pk_entity039 INTEGER
) RETURNS VOID AS $$
BEGIN
    UPDATE benchmark.tb_entity039
    SET deleted_at = CURRENT_TIMESTAMP
    WHERE pk_entity039 = p_pk_entity039;
END;
$$ LANGUAGE plpgsql;


CREATE TABLE benchmark.tb_entity040 (
    pk_entity040 SERIAL PRIMARY KEY,
    id UUID NOT NULL UNIQUE DEFAULT gen_random_uuid(),
    identifier TEXT NOT NULL UNIQUE,
    field_00 TEXT NOT NULL,
    field_01 TEXT NULL,
    field_02 TIMESTAMP NOT NULL,
    field_03 TEXT NOT NULL,
    field_04 NUMERIC(10,2) NOT NULL,
    field_05 INTEGER NOT NULL,
    field_06 INTEGER NULL,
    field_07 JSONB NULL,
    field_08 TIMESTAMP NULL,
    field_09 NUMERIC(10,2) NOT NULL,
    field_10 JSONB NOT NULL,
    field_11 INTEGER NULL,
    field_12 NUMERIC(10,2) NULL,
    field_13 TIMESTAMP NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    deleted_at TIMESTAMP
);
CREATE INDEX idx_entity040_id ON benchmark.tb_entity040(id);
CREATE INDEX idx_entity040_identifier ON benchmark.tb_entity040(identifier);

CREATE OR REPLACE FUNCTION benchmark.create_entity040(
    p_field_00 TEXT
) RETURNS INTEGER AS $$
DECLARE
    v_pk_entity040 INTEGER;
BEGIN
    INSERT INTO benchmark.tb_entity040 (field_00)
    VALUES (p_field_00)
    RETURNING pk_entity040 INTO v_pk_entity040;

    RETURN v_pk_entity040;
END;
$$ LANGUAGE plpgsql;


CREATE OR REPLACE FUNCTION benchmark.update_entity040(
    p_pk_entity040 INTEGER,
    p_field_00 TEXT
) RETURNS VOID AS $$
BEGIN
    UPDATE benchmark.tb_entity040
    SET field_00 = p_field_00,
        updated_at = CURRENT_TIMESTAMP
    WHERE pk_entity040 = p_pk_entity040;
END;
$$ LANGUAGE plpgsql;


CREATE OR REPLACE FUNCTION benchmark.delete_entity040(
    p_pk_entity040 INTEGER
) RETURNS VOID AS $$
BEGIN
    UPDATE benchmark.tb_entity040
    SET deleted_at = CURRENT_TIMESTAMP
    WHERE pk_entity040 = p_pk_entity040;
END;
$$ LANGUAGE plpgsql;


CREATE TABLE benchmark.tb_entity041 (
    pk_entity041 SERIAL PRIMARY KEY,
    id UUID NOT NULL UNIQUE DEFAULT gen_random_uuid(),
    identifier TEXT NOT NULL UNIQUE,
    pk_employee INTEGER NOT NULL REFERENCES benchmark.tb_employee(pk_employee),
    field_00 JSONB NULL,
    field_01 JSONB NOT NULL,
    field_02 TIMESTAMP NOT NULL,
    field_03 BOOLEAN NOT NULL,
    field_04 TIMESTAMP NOT NULL,
    field_05 TIMESTAMP NOT NULL,
    field_06 JSONB NOT NULL,
    field_07 BOOLEAN NULL,
    field_08 BOOLEAN NOT NULL,
    field_09 NUMERIC(10,2) NOT NULL,
    field_10 NUMERIC(10,2) NOT NULL,
    field_11 NUMERIC(10,2) NOT NULL,
    field_12 TEXT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    deleted_at TIMESTAMP
);
CREATE INDEX idx_entity041_id ON benchmark.tb_entity041(id);
CREATE INDEX idx_entity041_identifier ON benchmark.tb_entity041(identifier);

CREATE OR REPLACE FUNCTION benchmark.create_entity041(
    p_field_00 TEXT
) RETURNS INTEGER AS $$
DECLARE
    v_pk_entity041 INTEGER;
BEGIN
    INSERT INTO benchmark.tb_entity041 (field_00)
    VALUES (p_field_00)
    RETURNING pk_entity041 INTO v_pk_entity041;

    RETURN v_pk_entity041;
END;
$$ LANGUAGE plpgsql;


CREATE TABLE benchmark.tb_entity042 (
    pk_entity042 SERIAL PRIMARY KEY,
    id UUID NOT NULL UNIQUE DEFAULT gen_random_uuid(),
    identifier TEXT NOT NULL UNIQUE,
    pk_entity033 INTEGER NOT NULL REFERENCES benchmark.tb_entity033(pk_entity033),
    field_00 NUMERIC(10,2) NULL,
    field_01 TEXT NOT NULL,
    field_02 TIMESTAMP NOT NULL,
    field_03 TIMESTAMP NOT NULL,
    field_04 JSONB NOT NULL,
    field_05 BOOLEAN NOT NULL,
    field_06 TIMESTAMP NOT NULL,
    field_07 NUMERIC(10,2) NOT NULL,
    field_08 TIMESTAMP NULL,
    field_09 TEXT NOT NULL,
    field_10 NUMERIC(10,2) NOT NULL,
    field_11 TEXT NOT NULL,
    field_12 INTEGER NULL,
    field_13 JSONB NOT NULL,
    field_14 BOOLEAN NOT NULL,
    field_15 TIMESTAMP NULL,
    field_16 NUMERIC(10,2) NOT NULL,
    field_17 BOOLEAN NOT NULL
);
CREATE INDEX idx_entity042_id ON benchmark.tb_entity042(id);
CREATE INDEX idx_entity042_identifier ON benchmark.tb_entity042(identifier);

CREATE OR REPLACE FUNCTION benchmark.create_entity042(
    p_field_00 TEXT
) RETURNS INTEGER AS $$
DECLARE
    v_pk_entity042 INTEGER;
BEGIN
    INSERT INTO benchmark.tb_entity042 (field_00)
    VALUES (p_field_00)
    RETURNING pk_entity042 INTO v_pk_entity042;

    RETURN v_pk_entity042;
END;
$$ LANGUAGE plpgsql;


CREATE OR REPLACE FUNCTION benchmark.update_entity042(
    p_pk_entity042 INTEGER,
    p_field_00 TEXT
) RETURNS VOID AS $$
BEGIN
    UPDATE benchmark.tb_entity042
    SET field_00 = p_field_00,
        updated_at = CURRENT_TIMESTAMP
    WHERE pk_entity042 = p_pk_entity042;
END;
$$ LANGUAGE plpgsql;


CREATE OR REPLACE FUNCTION benchmark.delete_entity042(
    p_pk_entity042 INTEGER
) RETURNS VOID AS $$
BEGIN
    UPDATE benchmark.tb_entity042
    SET deleted_at = CURRENT_TIMESTAMP
    WHERE pk_entity042 = p_pk_entity042;
END;
$$ LANGUAGE plpgsql;


CREATE TABLE benchmark.tb_entity043 (
    pk_entity043 SERIAL PRIMARY KEY,
    id UUID NOT NULL UNIQUE DEFAULT gen_random_uuid(),
    identifier TEXT NOT NULL UNIQUE,
    field_00 NUMERIC(10,2) NOT NULL,
    field_01 TEXT NOT NULL,
    field_02 JSONB NOT NULL,
    field_03 NUMERIC(10,2) NULL,
    field_04 JSONB NOT NULL,
    field_05 NUMERIC(10,2) NOT NULL,
    field_06 JSONB NOT NULL,
    field_07 TIMESTAMP NOT NULL,
    field_08 NUMERIC(10,2) NULL,
    field_09 JSONB NULL,
    field_10 NUMERIC(10,2) NOT NULL,
    field_11 JSONB NOT NULL,
    field_12 BOOLEAN NULL,
    field_13 JSONB NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    deleted_at TIMESTAMP
);
CREATE INDEX idx_entity043_id ON benchmark.tb_entity043(id);
CREATE INDEX idx_entity043_identifier ON benchmark.tb_entity043(identifier);

CREATE OR REPLACE FUNCTION benchmark.create_entity043(
    p_field_00 TEXT
) RETURNS INTEGER AS $$
DECLARE
    v_pk_entity043 INTEGER;
BEGIN
    INSERT INTO benchmark.tb_entity043 (field_00)
    VALUES (p_field_00)
    RETURNING pk_entity043 INTO v_pk_entity043;

    RETURN v_pk_entity043;
END;
$$ LANGUAGE plpgsql;


CREATE OR REPLACE FUNCTION benchmark.update_entity043(
    p_pk_entity043 INTEGER,
    p_field_00 TEXT
) RETURNS VOID AS $$
BEGIN
    UPDATE benchmark.tb_entity043
    SET field_00 = p_field_00,
        updated_at = CURRENT_TIMESTAMP
    WHERE pk_entity043 = p_pk_entity043;
END;
$$ LANGUAGE plpgsql;


CREATE OR REPLACE FUNCTION benchmark.delete_entity043(
    p_pk_entity043 INTEGER
) RETURNS VOID AS $$
BEGIN
    UPDATE benchmark.tb_entity043
    SET deleted_at = CURRENT_TIMESTAMP
    WHERE pk_entity043 = p_pk_entity043;
END;
$$ LANGUAGE plpgsql;


CREATE TABLE benchmark.tb_entity044 (
    pk_entity044 SERIAL PRIMARY KEY,
    id UUID NOT NULL UNIQUE DEFAULT gen_random_uuid(),
    identifier TEXT NOT NULL UNIQUE,
    pk_entity033 INTEGER NOT NULL REFERENCES benchmark.tb_entity033(pk_entity033),
    pk_entity035 INTEGER NOT NULL REFERENCES benchmark.tb_entity035(pk_entity035),
    field_00 NUMERIC(10,2) NOT NULL,
    field_01 JSONB NOT NULL,
    field_02 INTEGER NOT NULL,
    field_03 JSONB NOT NULL,
    field_04 TIMESTAMP NULL,
    field_05 JSONB NOT NULL,
    field_06 NUMERIC(10,2) NULL,
    field_07 NUMERIC(10,2) NULL,
    field_08 INTEGER NOT NULL,
    field_09 BOOLEAN NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    deleted_at TIMESTAMP
);
CREATE INDEX idx_entity044_id ON benchmark.tb_entity044(id);
CREATE INDEX idx_entity044_identifier ON benchmark.tb_entity044(identifier);

CREATE OR REPLACE FUNCTION benchmark.create_entity044(
    p_field_00 TEXT
) RETURNS INTEGER AS $$
DECLARE
    v_pk_entity044 INTEGER;
BEGIN
    INSERT INTO benchmark.tb_entity044 (field_00)
    VALUES (p_field_00)
    RETURNING pk_entity044 INTO v_pk_entity044;

    RETURN v_pk_entity044;
END;
$$ LANGUAGE plpgsql;


CREATE OR REPLACE FUNCTION benchmark.update_entity044(
    p_pk_entity044 INTEGER,
    p_field_00 TEXT
) RETURNS VOID AS $$
BEGIN
    UPDATE benchmark.tb_entity044
    SET field_00 = p_field_00,
        updated_at = CURRENT_TIMESTAMP
    WHERE pk_entity044 = p_pk_entity044;
END;
$$ LANGUAGE plpgsql;


CREATE TABLE benchmark.tb_entity045 (
    pk_entity045 SERIAL PRIMARY KEY,
    id UUID NOT NULL UNIQUE DEFAULT gen_random_uuid(),
    identifier TEXT NOT NULL UNIQUE,
    field_00 INTEGER NULL,
    field_01 NUMERIC(10,2) NOT NULL,
    field_02 TEXT NOT NULL,
    field_03 TIMESTAMP NOT NULL,
    field_04 TIMESTAMP NULL,
    field_05 NUMERIC(10,2) NOT NULL,
    field_06 TIMESTAMP NULL,
    field_07 BOOLEAN NULL,
    field_08 INTEGER NOT NULL,
    field_09 TIMESTAMP NOT NULL,
    field_10 INTEGER NOT NULL,
    field_11 TEXT NOT NULL,
    field_12 JSONB NOT NULL,
    field_13 BOOLEAN NOT NULL
);
CREATE INDEX idx_entity045_id ON benchmark.tb_entity045(id);
CREATE INDEX idx_entity045_identifier ON benchmark.tb_entity045(identifier);

CREATE OR REPLACE FUNCTION benchmark.create_entity045(
    p_field_00 TEXT
) RETURNS INTEGER AS $$
DECLARE
    v_pk_entity045 INTEGER;
BEGIN
    INSERT INTO benchmark.tb_entity045 (field_00)
    VALUES (p_field_00)
    RETURNING pk_entity045 INTO v_pk_entity045;

    RETURN v_pk_entity045;
END;
$$ LANGUAGE plpgsql;


CREATE TABLE benchmark.tb_entity046 (
    pk_entity046 SERIAL PRIMARY KEY,
    id UUID NOT NULL UNIQUE DEFAULT gen_random_uuid(),
    identifier TEXT NOT NULL UNIQUE,
    field_00 JSONB NOT NULL,
    field_01 INTEGER NOT NULL,
    field_02 NUMERIC(10,2) NOT NULL,
    field_03 BOOLEAN NOT NULL,
    field_04 INTEGER NOT NULL,
    field_05 TIMESTAMP NOT NULL,
    field_06 BOOLEAN NOT NULL,
    field_07 BOOLEAN NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    deleted_at TIMESTAMP
);
CREATE INDEX idx_entity046_id ON benchmark.tb_entity046(id);
CREATE INDEX idx_entity046_identifier ON benchmark.tb_entity046(identifier);

CREATE OR REPLACE FUNCTION benchmark.create_entity046(
    p_field_00 TEXT
) RETURNS INTEGER AS $$
DECLARE
    v_pk_entity046 INTEGER;
BEGIN
    INSERT INTO benchmark.tb_entity046 (field_00)
    VALUES (p_field_00)
    RETURNING pk_entity046 INTO v_pk_entity046;

    RETURN v_pk_entity046;
END;
$$ LANGUAGE plpgsql;


CREATE OR REPLACE FUNCTION benchmark.update_entity046(
    p_pk_entity046 INTEGER,
    p_field_00 TEXT
) RETURNS VOID AS $$
BEGIN
    UPDATE benchmark.tb_entity046
    SET field_00 = p_field_00,
        updated_at = CURRENT_TIMESTAMP
    WHERE pk_entity046 = p_pk_entity046;
END;
$$ LANGUAGE plpgsql;


CREATE TABLE benchmark.tb_entity047 (
    pk_entity047 SERIAL PRIMARY KEY,
    field_00 BOOLEAN NOT NULL,
    field_01 INTEGER NOT NULL,
    field_02 INTEGER NOT NULL,
    field_03 TEXT NOT NULL,
    field_04 NUMERIC(10,2) NOT NULL,
    field_05 TEXT NOT NULL,
    field_06 TIMESTAMP NOT NULL,
    field_07 NUMERIC(10,2) NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    deleted_at TIMESTAMP
);

CREATE OR REPLACE FUNCTION benchmark.create_entity047(
    p_field_00 TEXT
) RETURNS INTEGER AS $$
DECLARE
    v_pk_entity047 INTEGER;
BEGIN
    INSERT INTO benchmark.tb_entity047 (field_00)
    VALUES (p_field_00)
    RETURNING pk_entity047 INTO v_pk_entity047;

    RETURN v_pk_entity047;
END;
$$ LANGUAGE plpgsql;


CREATE OR REPLACE FUNCTION benchmark.update_entity047(
    p_pk_entity047 INTEGER,
    p_field_00 TEXT
) RETURNS VOID AS $$
BEGIN
    UPDATE benchmark.tb_entity047
    SET field_00 = p_field_00,
        updated_at = CURRENT_TIMESTAMP
    WHERE pk_entity047 = p_pk_entity047;
END;
$$ LANGUAGE plpgsql;


CREATE TABLE benchmark.tb_entity048 (
    pk_entity048 SERIAL PRIMARY KEY,
    id UUID NOT NULL UNIQUE DEFAULT gen_random_uuid(),
    identifier TEXT NOT NULL UNIQUE,
    pk_document INTEGER NOT NULL REFERENCES benchmark.tb_document(pk_document),
    field_00 INTEGER NULL,
    field_01 TIMESTAMP NULL,
    field_02 BOOLEAN NULL,
    field_03 INTEGER NOT NULL,
    field_04 NUMERIC(10,2) NOT NULL,
    field_05 BOOLEAN NULL,
    field_06 TIMESTAMP NOT NULL,
    field_07 BOOLEAN NOT NULL,
    field_08 NUMERIC(10,2) NULL,
    field_09 NUMERIC(10,2) NOT NULL,
    field_10 JSONB NOT NULL,
    field_11 INTEGER NULL,
    field_12 NUMERIC(10,2) NOT NULL,
    field_13 BOOLEAN NOT NULL
);
CREATE INDEX idx_entity048_id ON benchmark.tb_entity048(id);
CREATE INDEX idx_entity048_identifier ON benchmark.tb_entity048(identifier);

CREATE OR REPLACE FUNCTION benchmark.create_entity048(
    p_field_00 TEXT
) RETURNS INTEGER AS $$
DECLARE
    v_pk_entity048 INTEGER;
BEGIN
    INSERT INTO benchmark.tb_entity048 (field_00)
    VALUES (p_field_00)
    RETURNING pk_entity048 INTO v_pk_entity048;

    RETURN v_pk_entity048;
END;
$$ LANGUAGE plpgsql;


CREATE TABLE benchmark.tb_entity049 (
    pk_entity049 SERIAL PRIMARY KEY,
    id UUID NOT NULL UNIQUE DEFAULT gen_random_uuid(),
    identifier TEXT NOT NULL UNIQUE,
    pk_entity031 INTEGER NOT NULL REFERENCES benchmark.tb_entity031(pk_entity031),
    field_00 INTEGER NOT NULL,
    field_01 BOOLEAN NOT NULL,
    field_02 TEXT NOT NULL,
    field_03 TEXT NULL,
    field_04 INTEGER NOT NULL,
    field_05 JSONB NOT NULL,
    field_06 BOOLEAN NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    deleted_at TIMESTAMP
);
CREATE INDEX idx_entity049_id ON benchmark.tb_entity049(id);
CREATE INDEX idx_entity049_identifier ON benchmark.tb_entity049(identifier);

CREATE OR REPLACE FUNCTION benchmark.create_entity049(
    p_field_00 TEXT
) RETURNS INTEGER AS $$
DECLARE
    v_pk_entity049 INTEGER;
BEGIN
    INSERT INTO benchmark.tb_entity049 (field_00)
    VALUES (p_field_00)
    RETURNING pk_entity049 INTO v_pk_entity049;

    RETURN v_pk_entity049;
END;
$$ LANGUAGE plpgsql;


CREATE OR REPLACE FUNCTION benchmark.update_entity049(
    p_pk_entity049 INTEGER,
    p_field_00 TEXT
) RETURNS VOID AS $$
BEGIN
    UPDATE benchmark.tb_entity049
    SET field_00 = p_field_00,
        updated_at = CURRENT_TIMESTAMP
    WHERE pk_entity049 = p_pk_entity049;
END;
$$ LANGUAGE plpgsql;

