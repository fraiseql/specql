-- ============================================================================
-- Test Database Setup Script
-- Run this to initialize the test database with required schemas and types
-- ============================================================================

-- Drop existing schemas (clean slate)
DROP SCHEMA IF EXISTS specql_registry CASCADE;
DROP SCHEMA IF EXISTS app CASCADE;
DROP SCHEMA IF EXISTS crm CASCADE;
DROP SCHEMA IF EXISTS common CASCADE;
DROP SCHEMA IF EXISTS core CASCADE;
DROP SCHEMA IF EXISTS pm CASCADE;
DROP SCHEMA IF EXISTS catalog CASCADE;

-- Create schemas
CREATE SCHEMA specql_registry;
CREATE SCHEMA app;
CREATE SCHEMA crm;
CREATE SCHEMA common;
CREATE SCHEMA core;
CREATE SCHEMA pm;
CREATE SCHEMA catalog;

-- SPECQL Registry Schema
-- PostgreSQL schema for domain, subdomain, and entity registration data

-- Domain table
CREATE TABLE specql_registry.tb_domain (
    pk_domain SERIAL PRIMARY KEY,
    domain_number VARCHAR(10) NOT NULL UNIQUE,
    domain_name VARCHAR(100) NOT NULL,
    description TEXT,
    multi_tenant BOOLEAN NOT NULL DEFAULT FALSE,
    aliases TEXT[] DEFAULT ARRAY[]::TEXT[]
);

-- Subdomain table
CREATE TABLE specql_registry.tb_subdomain (
    pk_subdomain SERIAL PRIMARY KEY,
    fk_domain INTEGER NOT NULL REFERENCES specql_registry.tb_domain(pk_domain) ON DELETE CASCADE,
    subdomain_number VARCHAR(10) NOT NULL,
    subdomain_name VARCHAR(100) NOT NULL,
    description TEXT,
    next_entity_sequence INTEGER NOT NULL DEFAULT 1,
    UNIQUE(fk_domain, subdomain_number)
);

-- Entity registration table
CREATE TABLE specql_registry.tb_entity_registration (
    pk_entity_registration SERIAL PRIMARY KEY,
    fk_subdomain INTEGER NOT NULL REFERENCES specql_registry.tb_subdomain(pk_subdomain) ON DELETE CASCADE,
    entity_name VARCHAR(100) NOT NULL,
    table_code VARCHAR(20) NOT NULL,
    entity_sequence INTEGER NOT NULL,
    UNIQUE(fk_subdomain, entity_name)
);

-- Indexes for performance
CREATE INDEX idx_tb_domain_domain_number ON specql_registry.tb_domain(domain_number);
CREATE INDEX idx_tb_domain_domain_name ON specql_registry.tb_domain(domain_name);
CREATE INDEX idx_tb_subdomain_fk_domain ON specql_registry.tb_subdomain(fk_domain);
CREATE INDEX idx_tb_entity_registration_fk_subdomain ON specql_registry.tb_entity_registration(fk_subdomain);

-- Install extensions (optional - skip if not available)
CREATE EXTENSION IF NOT EXISTS pg_trgm;
CREATE EXTENSION IF NOT EXISTS postgis;

-- Create app.mutation_result type
CREATE TYPE app.mutation_result AS (
    id UUID,
    updated_fields TEXT[],
    status TEXT,
    message TEXT,
    object_data JSONB,
    _meta JSONB
);

COMMENT ON TYPE app.mutation_result IS
'Standard return type for all mutations.

@fraiseql:type
name: MutationResult
description: Result of a mutation operation';

-- Create input types (will be generated by tests as needed)
-- These are just placeholders for tests that need them

-- Create Company table (for FK testing)
CREATE TABLE crm.tb_company (
    pk_company INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    id UUID DEFAULT gen_random_uuid() NOT NULL UNIQUE,
    identifier TEXT,
    tenant_id UUID NOT NULL,
    name TEXT NOT NULL,
    created_at TIMESTAMP DEFAULT now(),
    created_by UUID,
    updated_at TIMESTAMP DEFAULT now(),
    updated_by UUID,
    deleted_at TIMESTAMP
);

CREATE INDEX idx_company_tenant ON crm.tb_company(tenant_id);

-- Trinity helper functions
CREATE OR REPLACE FUNCTION crm.company_pk(company_identifier TEXT, p_tenant_id UUID)
RETURNS INTEGER AS $$
    SELECT pk_company
    FROM crm.tb_company
    WHERE identifier = company_identifier
      AND tenant_id = p_tenant_id
      AND deleted_at IS NULL;
$$ LANGUAGE SQL STABLE;

-- Audit logging function
CREATE OR REPLACE FUNCTION app.log_and_return_mutation(
    auth_tenant_id UUID,
    auth_user_id UUID,
    entity_name TEXT,
    entity_id UUID,
    operation TEXT,
    status TEXT,
    updated_fields TEXT[],
    message TEXT,
    object_data JSONB,
    extra JSONB,
    error_details JSONB DEFAULT NULL
) RETURNS app.mutation_result AS $$
DECLARE
    result app.mutation_result;
BEGIN
    -- Build result
    result.id := entity_id;
    result.updated_fields := updated_fields;
    result.status := status;
    result.message := message;
    result.object_data := object_data;
    result._meta := COALESCE(extra, '{}'::JSONB);

    -- In production, this would log to audit table
    -- For tests, just return the result

    RETURN result;
END;
$$ LANGUAGE plpgsql;

-- Create input types for contact functions
CREATE TYPE app.type_create_contact_input AS (
    email TEXT,
    first_name TEXT,
    last_name TEXT,
    company_id TEXT,
    status TEXT,
    phone TEXT
);

CREATE TYPE app.type_qualify_lead_input AS (
    id UUID
);

-- Create Contact table (Trinity pattern)
CREATE TABLE crm.tb_contact (
    pk_contact INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    id UUID DEFAULT gen_random_uuid() NOT NULL UNIQUE,
    identifier TEXT,
    tenant_id UUID NOT NULL,
    email TEXT,
    first_name TEXT NOT NULL,
    last_name TEXT NOT NULL,
    fk_company INTEGER,
    status TEXT,
    phone TEXT,
    created_at TIMESTAMP DEFAULT now(),
    created_by UUID,
    updated_at TIMESTAMP DEFAULT now(),
    updated_by UUID,
    deleted_at TIMESTAMP
);

-- Create indexes
CREATE INDEX idx_contact_tenant ON crm.tb_contact(tenant_id);
CREATE INDEX idx_contact_email ON crm.tb_contact(email);
CREATE INDEX idx_contact_status ON crm.tb_contact(status);

-- Add FK constraint
ALTER TABLE crm.tb_contact ADD CONSTRAINT fk_contact_company
    FOREIGN KEY (fk_company) REFERENCES crm.tb_company(pk_company);

-- Trinity helper functions
CREATE OR REPLACE FUNCTION crm.company_pk(company_identifier TEXT, p_tenant_id UUID)
RETURNS INTEGER AS $$
    SELECT pk_company
    FROM crm.tb_company
    WHERE identifier = company_identifier
      AND tenant_id = p_tenant_id
      AND deleted_at IS NULL;
$$ LANGUAGE SQL STABLE;

CREATE OR REPLACE FUNCTION crm.contact_pk(contact_identifier TEXT, p_tenant_id UUID)
RETURNS INTEGER AS $$
    SELECT pk_contact
    FROM crm.tb_contact
    WHERE identifier = contact_identifier
      AND tenant_id = p_tenant_id
      AND deleted_at IS NULL;
$$ LANGUAGE SQL STABLE;

-- Contact functions (simplified for testing)
CREATE OR REPLACE FUNCTION app.create_contact(
    auth_tenant_id UUID,
    auth_user_id UUID,
    input_payload JSONB
) RETURNS app.mutation_result
LANGUAGE plpgsql
AS $$
DECLARE
    input_data app.type_create_contact_input;
    v_contact_id UUID := gen_random_uuid();
    v_fk_company INTEGER;
BEGIN
    -- Convert JSONB → Typed Composite
    input_data := jsonb_populate_record(
        NULL::app.type_create_contact_input,
        input_payload
    );

    -- Resolve company FK if provided
    IF input_data.company_id IS NOT NULL THEN
        v_fk_company := crm.company_pk(input_data.company_id::TEXT, auth_tenant_id);
    END IF;

    -- Insert contact
    INSERT INTO crm.tb_contact (
        id, tenant_id, email, first_name, last_name,
        fk_company, status, phone, created_by
    ) VALUES (
        v_contact_id, auth_tenant_id, input_data.email,
        input_data.first_name, input_data.last_name,
        v_fk_company, input_data.status, input_data.phone, auth_user_id
    );

    -- Return success
    RETURN app.log_and_return_mutation(
        auth_tenant_id, auth_user_id, 'contact', v_contact_id,
        'INSERT', 'success', ARRAY['email', 'first_name', 'last_name', 'status'],
        'Contact created successfully',
        (SELECT row_to_json(t.*) FROM crm.tb_contact t WHERE t.id = v_contact_id)::JSONB,
        NULL
    );
END;
$$;

CREATE OR REPLACE FUNCTION app.qualify_lead(
    auth_tenant_id UUID,
    auth_user_id UUID,
    input_payload JSONB
) RETURNS app.mutation_result
LANGUAGE plpgsql
AS $$
DECLARE
    input_data app.type_qualify_lead_input;
    v_contact_id UUID;
    v_current_status TEXT;
BEGIN
    -- Convert JSONB → Typed Composite
    input_data := jsonb_populate_record(
        NULL::app.type_qualify_lead_input,
        input_payload
    );

    v_contact_id := input_data.id;

    -- Check current status
    SELECT status INTO v_current_status
    FROM crm.tb_contact
    WHERE id = v_contact_id AND tenant_id = auth_tenant_id;

    -- Validate status is 'lead'
    IF v_current_status != 'lead' THEN
        RETURN app.log_and_return_mutation(
            auth_tenant_id, auth_user_id, 'contact', v_contact_id,
            'UPDATE', 'failed:validation_error',
            ARRAY[]::TEXT[], 'Contact is not a lead',
            NULL, NULL
        );
    END IF;

    -- Update status
    UPDATE crm.tb_contact
    SET status = 'qualified', updated_at = now(), updated_by = auth_user_id
    WHERE id = v_contact_id;

    -- Return success
    RETURN app.log_and_return_mutation(
        auth_tenant_id, auth_user_id, 'contact', v_contact_id,
        'UPDATE', 'success', ARRAY['status'],
        'Lead qualified successfully',
        (SELECT row_to_json(t.*) FROM crm.tb_contact t WHERE t.id = v_contact_id)::JSONB,
        NULL
    );
END;
$$;

-- Grant permissions (if using postgres user)
GRANT ALL ON SCHEMA specql_registry TO PUBLIC;
GRANT ALL ON SCHEMA app TO PUBLIC;
GRANT ALL ON SCHEMA crm TO PUBLIC;
GRANT ALL ON SCHEMA common TO PUBLIC;
GRANT ALL ON SCHEMA core TO PUBLIC;
GRANT ALL ON SCHEMA pm TO PUBLIC;
GRANT ALL ON SCHEMA catalog TO PUBLIC;
GRANT ALL ON ALL TABLES IN SCHEMA specql_registry TO PUBLIC;
GRANT ALL ON ALL TABLES IN SCHEMA app TO PUBLIC;
GRANT ALL ON ALL TABLES IN SCHEMA crm TO PUBLIC;
GRANT ALL ON ALL SEQUENCES IN SCHEMA specql_registry TO PUBLIC;
GRANT ALL ON ALL SEQUENCES IN SCHEMA crm TO PUBLIC;