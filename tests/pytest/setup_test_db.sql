-- Drop existing schemas if they exist
DROP SCHEMA IF EXISTS app CASCADE;
DROP SCHEMA IF EXISTS crm CASCADE;
DROP SCHEMA IF EXISTS common CASCADE;
DROP SCHEMA IF EXISTS core CASCADE;

-- Create schemas
CREATE SCHEMA app;
CREATE SCHEMA crm;
CREATE SCHEMA common;
CREATE SCHEMA core;

-- Create app.mutation_result type
CREATE TYPE app.mutation_result AS (
    id UUID,
    updated_fields TEXT[],
    status TEXT,
    message TEXT,
    object_data JSONB,
    _meta JSONB
);

-- Create app.type_create_contact_input type
CREATE TYPE app.type_create_contact_input AS (
    email TEXT,
    first_name TEXT,
    last_name TEXT,
    company_id TEXT,
    status TEXT,
    phone TEXT
);

-- Create app.type_qualify_lead_input type
CREATE TYPE app.type_qualify_lead_input AS (
    id UUID
);

-- Create Contact table (Trinity pattern)
CREATE TABLE crm.tb_contact (
    pk_contact INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    id UUID DEFAULT gen_random_uuid() NOT NULL UNIQUE,
    identifier TEXT,
    tenant_id UUID NOT NULL,
    email TEXT,
    first_name TEXT NOT NULL,
    last_name TEXT NOT NULL,
    fk_company INTEGER,
    status TEXT,
    phone TEXT,
    created_at TIMESTAMP DEFAULT now(),
    created_by UUID,
    updated_at TIMESTAMP DEFAULT now(),
    updated_by UUID,
    deleted_at TIMESTAMP
);

-- Create indexes
CREATE INDEX idx_contact_tenant ON crm.tb_contact(tenant_id);
CREATE INDEX idx_contact_email ON crm.tb_contact(email);
CREATE INDEX idx_contact_status ON crm.tb_contact(status);

-- Create Company table (for FK testing)
CREATE TABLE crm.tb_company (
    pk_company INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    id UUID DEFAULT gen_random_uuid() NOT NULL UNIQUE,
    identifier TEXT,
    tenant_id UUID NOT NULL,
    name TEXT NOT NULL,
    created_at TIMESTAMP DEFAULT now(),
    created_by UUID,
    updated_at TIMESTAMP DEFAULT now(),
    updated_by UUID,
    deleted_at TIMESTAMP
);

-- Add FK constraint
ALTER TABLE crm.tb_contact ADD CONSTRAINT fk_contact_company
    FOREIGN KEY (fk_company) REFERENCES crm.tb_company(pk_company);

-- Trinity helper functions
CREATE OR REPLACE FUNCTION crm.company_pk(company_identifier TEXT, tenant_id UUID)
RETURNS INTEGER AS $$
    SELECT pk_company
    FROM crm.tb_company
    WHERE identifier = company_identifier
      AND crm.tb_company.tenant_id = company_pk.tenant_id
      AND deleted_at IS NULL;
$$ LANGUAGE SQL;

CREATE OR REPLACE FUNCTION crm.contact_pk(contact_identifier TEXT, tenant_id UUID)
RETURNS INTEGER AS $$
    SELECT pk_contact
    FROM crm.tb_contact
    WHERE identifier = contact_identifier
      AND crm.tb_contact.tenant_id = contact_pk.tenant_id
      AND deleted_at IS NULL;
$$ LANGUAGE SQL;

-- Audit logging function
CREATE OR REPLACE FUNCTION app.log_and_return_mutation(
    auth_tenant_id UUID,
    auth_user_id UUID,
    entity_name TEXT,
    entity_id UUID,
    operation TEXT,
    status TEXT,
    updated_fields TEXT[],
    message TEXT,
    object_data JSONB,
    extra JSONB,
    error_details JSONB DEFAULT NULL
) RETURNS app.mutation_result AS $$
DECLARE
    result app.mutation_result;
BEGIN
    -- Build result
    result.id := entity_id;
    result.updated_fields := updated_fields;
    result.status := status;
    result.message := message;
    result.object_data := object_data;
    result._meta := COALESCE(extra, '{}'::JSONB);

    -- In a real implementation, this would log to audit table
    -- For tests, just return the result

    RETURN result;
END;
$$ LANGUAGE plpgsql;
