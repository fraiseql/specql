"""Tests for base table (tb_) generation with Trinity pattern"""

import pytest
from src.generators.schema.base_table_generator import BaseTableGenerator
from src.core.ast_models import Entity, FieldDefinition


class TestBaseTableGeneration:
    """Test generation of tb_ base tables with Trinity pattern"""

    @pytest.fixture
    def generator(self):
        return BaseTableGenerator()

    @pytest.fixture
    def sample_entity(self):
        return Entity(
            name="Contact",
            schema="crm",
            fields={
                "email": FieldDefinition(name="email", type_name="text", nullable=False),
                "company": FieldDefinition(name="company", type_name="ref", reference_entity="Company"),
                "status": FieldDefinition(name="status", type_name="enum", values=["lead", "qualified"]),
            }
        )

    def test_generate_base_table_with_trinity_pattern(self, generator, sample_entity):
        """Test base table includes full Trinity pattern"""
        # Act
        result = generator.generate(sample_entity)

        # Assert - Trinity pattern fields
        assert "pk_contact INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY" in result
        assert "id UUID DEFAULT gen_random_uuid() NOT NULL" in result
        assert "CONSTRAINT tb_contact_id_key UNIQUE (id)" in result

    def test_generate_base_table_with_audit_fields(self, generator, sample_entity):
        """Test base table includes complete audit trail"""
        # Act
        result = generator.generate(sample_entity)

        # Assert - All 6 audit fields
        assert "created_at TIMESTAMPTZ NOT NULL DEFAULT now()" in result
        assert "created_by UUID" in result
        assert "updated_at TIMESTAMPTZ NOT NULL DEFAULT now()" in result
        assert "updated_by UUID" in result
        assert "deleted_at TIMESTAMPTZ" in result
        assert "deleted_by UUID" in result

    def test_generate_base_table_with_tenant_id(self, generator, sample_entity):
        """Test multi-tenant schema includes tenant_id"""
        # Arrange
        sample_entity.schema_type = "multi_tenant"

        # Act
        result = generator.generate(sample_entity)

        # Assert
        assert "tenant_id UUID NOT NULL" in result

    def test_generate_base_table_with_business_fields(self, generator, sample_entity):
        """Test business fields correctly mapped"""
        # Act
        result = generator.generate(sample_entity)

        # Assert
        assert "email VARCHAR(255) NOT NULL" in result  # Context-aware inference
        assert "company INTEGER" in result  # FK to pk_company
        assert "status TEXT" in result
        assert "CONSTRAINT chk_tb_contact_status CHECK (status IN ('lead', 'qualified'))" in result

    def test_generate_base_table_with_foreign_keys(self, generator, sample_entity):
        """Test foreign key constraints generated"""
        # Act
        result = generator.generate(sample_entity)

        # Assert
        assert "CONSTRAINT fk_contact_company FOREIGN KEY (company) REFERENCES crm.tb_company(pk_company)" in result

    def test_generate_base_table_with_indexes(self, generator, sample_entity):
        """Test indexes auto-generated for FK and enum fields"""
        # Act
        result = generator.generate(sample_entity)

        # Assert
        assert "CREATE INDEX idx_tb_contact_company ON crm.tb_contact(company)" in result
        assert "CREATE INDEX idx_tb_contact_status ON crm.tb_contact(status)" in result


class TestBaseTableNaming:
    """Test naming conventions for base tables"""

    @pytest.fixture
    def generator(self):
        return BaseTableGenerator()

    @pytest.fixture
    def sample_entity(self):
        return Entity(
            name="Contact",
            schema="crm",
            fields={
                "email": FieldDefinition(name="email", type_name="text", nullable=False),
                "company": FieldDefinition(name="company", type_name="ref", reference_entity="Company"),
                "status": FieldDefinition(name="status", type_name="enum", values=["lead", "qualified"]),
            }
        )

    def test_table_name_convention(self, generator, sample_entity):
        """Test table name follows tb_{entity} convention"""
        # Act
        result = generator.generate(sample_entity)

        # Assert
        assert "CREATE TABLE crm.tb_contact" in result

    def test_constraint_naming_conventions(self, generator, sample_entity):
        """Test constraint names follow standards"""
        # Act
        result = generator.generate(sample_entity)

        # Assert - Primary key constraint
        assert "tb_contact_pkey" in result or "PRIMARY KEY" in result

        # Unique constraint
        assert "tb_contact_id_key UNIQUE (id)" in result

        # Foreign key constraint
        assert "fk_contact_company" in result

        # Check constraint
        assert "chk_tb_contact_status" in result


class TestEnhancedTypeSystem:
    """Test enhanced type system with subtypes (NEW!)"""

    @pytest.fixture
    def generator(self):
        return BaseTableGenerator()

    def test_integer_subtypes(self, generator):
        """Test integer subtypes map to correct PostgreSQL types"""
        entity = Entity(
            name="Product",
            schema="catalog",
            fields={
                "id": FieldDefinition(name="id", type_name="integer"),  # → BIGINT (smart default)
                "age": FieldDefinition(name="age", type_name="integer:small"),  # → SMALLINT (explicit)
                "count": FieldDefinition(name="count", type_name="integer:int"),  # → INTEGER (explicit)
                "big_num": FieldDefinition(name="big_num", type_name="integer:big"),  # → BIGINT (explicit)
            }
        )

        # Act
        result = generator.generate(entity)

        # Assert
        assert "id BIGINT" in result  # Smart default for id field
        assert "age SMALLINT" in result  # Explicit subtype
        assert "count INTEGER" in result  # Explicit subtype
        assert "big_num BIGINT" in result  # Explicit subtype

    def test_decimal_subtypes(self, generator):
        """Test decimal subtypes map to correct numeric types"""
        entity = Entity(
            name="Product",
            schema="catalog",
            fields={
                "price": FieldDefinition(name="price", type_name="decimal:money"),  # → NUMERIC(10,2)
                "latitude": FieldDefinition(name="latitude", type_name="decimal:geo"),  # → NUMERIC(9,6)
                "tax_rate": FieldDefinition(name="tax_rate", type_name="decimal:percent"),  # → NUMERIC(5,4)
                "precise": FieldDefinition(name="precise", type_name="decimal:high"),  # → NUMERIC(20,10)
            }
        )

        # Act
        result = generator.generate(entity)

        # Assert
        assert "price NUMERIC(10,2)" in result
        assert "latitude NUMERIC(9,6)" in result
        assert "tax_rate NUMERIC(5,4)" in result
        assert "precise NUMERIC(20,10)" in result

    def test_text_subtypes(self, generator):
        """Test text subtypes map to correct varchar/text types"""
        entity = Entity(
            name="Contact",
            schema="crm",
            fields={
                "email": FieldDefinition(name="email", type_name="text:short"),  # → VARCHAR(255)
                "code": FieldDefinition(name="code", type_name="text:tiny"),  # → VARCHAR(10)
                "description": FieldDefinition(name="description", type_name="text:long"),  # → TEXT
                "name": FieldDefinition(name="name", type_name="text"),  # → TEXT (default)
            }
        )

        # Act
        result = generator.generate(entity)

        # Assert
        assert "email VARCHAR(255)" in result
        assert "code VARCHAR(10)" in result
        assert "description TEXT" in result
        assert "name TEXT" in result

    def test_context_aware_type_inference(self, generator):
        """Test type inference based on field names and patterns"""
        entity = Entity(
            name="User",
            schema="auth",
            fields={
                # Should infer integer:big for IDs
                "user_id": FieldDefinition(name="user_id", type_name="integer"),  # → BIGINT
                "organization_id": FieldDefinition(name="organization_id", type_name="integer"),  # → BIGINT

                # Should infer integer:small for age
                "age": FieldDefinition(name="age", type_name="integer"),  # → SMALLINT

                # Should infer text:short for email/phone
                "email": FieldDefinition(name="email", type_name="text"),  # → VARCHAR(255)
                "phone": FieldDefinition(name="phone", type_name="text"),  # → VARCHAR(50)

                # Should infer decimal:money for price/amount
                "price": FieldDefinition(name="price", type_name="decimal"),  # → NUMERIC(10,2)
                "amount": FieldDefinition(name="amount", type_name="decimal"),  # → NUMERIC(10,2)
            }
        )

        # Act
        result = generator.generate(entity)

        # Assert - Context-aware inference
        assert "user_id BIGINT" in result
        assert "organization_id BIGINT" in result
        assert "age SMALLINT" in result
        assert "email VARCHAR(255)" in result
        assert "phone VARCHAR(50)" in result
        assert "price NUMERIC(10,2)" in result
        assert "amount NUMERIC(10,2)" in result

    def test_backward_compatibility(self, generator):
        """Test that existing YAML without subtypes still works"""
        entity = Entity(
            name="LegacyEntity",
            schema="legacy",
            fields={
                "name": FieldDefinition(name="name", type_name="text"),
                "count": FieldDefinition(name="count", type_name="integer"),
                "price": FieldDefinition(name="price", type_name="decimal"),
                "active": FieldDefinition(name="active", type_name="boolean"),
            }
        )

        # Act - Should not fail
        result = generator.generate(entity)

        # Assert - Uses smart defaults
        assert "name TEXT" in result  # or VARCHAR based on inference
        assert ("count INTEGER" in result or "count BIGINT" in result)  # Context-dependent
        assert ("price NUMERIC" in result or "price NUMERIC(10,2)" in result)
        assert "active BOOLEAN" in result