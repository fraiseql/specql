# tests/unit/cli/commands/reverse/test_sql_integration.py
import sys
from pathlib import Path

# Add src to path for new CLI structure
project_root = Path(__file__).parent.parent.parent.parent.parent  # /home/lionel/code/specql
src_path = project_root / "src"
sys.path.insert(0, str(src_path))

import pytest
from click.testing import CliRunner


@pytest.fixture
def cli_runner():
    return CliRunner()


@pytest.fixture
def sample_sql_ddl():
    return """
    CREATE TABLE crm.tb_contact (
        pk_contact INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
        id UUID DEFAULT gen_random_uuid() NOT NULL,
        tenant_id UUID NOT NULL,
        email TEXT NOT NULL,
        created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
        created_by UUID,
        updated_at TIMESTAMPTZ NOT NULL DEFAULT now(),
        updated_by UUID,
        deleted_at TIMESTAMPTZ,
        deleted_by UUID
    );
    """


def test_reverse_sql_creates_yaml(cli_runner, sample_sql_ddl):
    """Reverse sql should create YAML from SQL DDL."""
    from cli.main import app

    with cli_runner.isolated_filesystem():
        Path("tables.sql").write_text(sample_sql_ddl)
        Path("out").mkdir()

        result = cli_runner.invoke(app, ["reverse", "sql", "tables.sql", "--output", "out/"])

        assert result.exit_code == 0
        yaml_files = list(Path("out/").glob("*.yaml"))
        assert len(yaml_files) > 0

        # Find the contact entity file (should be in entities/ directory)
        contact_files = list(Path("out/entities").glob("*contact*.yaml"))
        assert len(contact_files) > 0, (
            f"No contact entity file found in {[str(f) for f in yaml_files]}"
        )

        # Check that the YAML contains expected content
        yaml_content = contact_files[0].read_text()
        assert "entity: Contact" in yaml_content  # Note: capitalized
        assert "schema: crm" in yaml_content
        assert "email:" in yaml_content


def test_reverse_sql_preview_mode(cli_runner, sample_sql_ddl):
    """Reverse sql --preview should not write files."""
    from cli.main import app

    with cli_runner.isolated_filesystem():
        Path("tables.sql").write_text(sample_sql_ddl)
        Path("out").mkdir()

        result = cli_runner.invoke(
            app, ["reverse", "sql", "tables.sql", "--output", "out/", "--preview"]
        )

        assert result.exit_code == 0
        assert "Preview mode" in result.output
        yaml_files = list(Path("out/").glob("*.yaml"))
        assert len(yaml_files) == 0


def test_reverse_sql_with_foreign_keys(cli_runner):
    """Reverse sql should handle foreign key relationships."""
    from cli.main import app

    sql_with_fk = """
    CREATE TABLE crm.tb_contact (
        pk_contact INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
        id UUID DEFAULT gen_random_uuid() NOT NULL,
        tenant_id UUID NOT NULL,
        email TEXT NOT NULL
    );

    CREATE TABLE crm.tb_organization (
        pk_organization INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
        id UUID DEFAULT gen_random_uuid() NOT NULL,
        tenant_id UUID NOT NULL,
        name TEXT NOT NULL
    );

    ALTER TABLE crm.tb_contact ADD CONSTRAINT fk_contact_organization
        FOREIGN KEY (fk_organization) REFERENCES crm.tb_organization(pk_organization);
    """

    with cli_runner.isolated_filesystem():
        Path("schema.sql").write_text(sql_with_fk)
        Path("out").mkdir()

        result = cli_runner.invoke(app, ["reverse", "sql", "schema.sql", "--output", "out/"])

        assert result.exit_code == 0
        yaml_files = list(Path("out/").glob("*.yaml"))
        assert len(yaml_files) >= 1  # At least contact should be created


def test_reverse_sql_min_confidence_filtering(cli_runner):
    """Reverse sql should filter based on confidence threshold."""
    from cli.main import app

    # Simple table that should have high confidence for Trinity pattern
    simple_table = """
    CREATE TABLE public.users (
        id SERIAL PRIMARY KEY,
        email TEXT NOT NULL,
        created_at TIMESTAMP DEFAULT now()
    );
    """

    with cli_runner.isolated_filesystem():
        Path("simple.sql").write_text(simple_table)
        Path("out").mkdir()

        # Test with very high confidence threshold
        result = cli_runner.invoke(
            app, ["reverse", "sql", "simple.sql", "--output", "out/", "--min-confidence", "0.95"]
        )

        assert result.exit_code == 0
        # Should still work but might show warnings about low confidence


def test_reverse_sql_no_ai_flag(cli_runner, sample_sql_ddl):
    """Reverse sql --no-ai should skip function parsing."""
    from cli.main import app

    sql_with_function = (
        sample_sql_ddl
        + """

    CREATE OR REPLACE FUNCTION crm.get_contact_by_email(user_email TEXT)
    RETURNS TABLE(id UUID, email TEXT) AS $$
    BEGIN
        RETURN QUERY
        SELECT c.id, c.email
        FROM crm.tb_contact c
        WHERE c.email = user_email;
    END;
    $$ LANGUAGE plpgsql;
    """
    )

    with cli_runner.isolated_filesystem():
        Path("with_function.sql").write_text(sql_with_function)
        Path("out").mkdir()

        result = cli_runner.invoke(
            app, ["reverse", "sql", "with_function.sql", "--output", "out/", "--no-ai"]
        )

        assert result.exit_code == 0
        # Should still work without AI parsing


def test_reverse_sql_handles_invalid_sql(cli_runner):
    """Reverse sql should handle invalid SQL gracefully."""
    from cli.main import app

    invalid_sql = """
    CREATE TABLE invalid (
        id INTEGER PRIMARY KEY,
        -- Missing closing parenthesis
    """

    with cli_runner.isolated_filesystem():
        Path("invalid.sql").write_text(invalid_sql)
        Path("out").mkdir()

        result = cli_runner.invoke(app, ["reverse", "sql", "invalid.sql", "--output", "out/"])

        # Should not crash, but may skip invalid statements
        assert (
            result.exit_code == 0 or result.exit_code == 1
        )  # Allow either success or controlled failure


def test_reverse_sql_creates_snake_case_filename(cli_runner):
    """Reverse sql should create snake_case filenames from table names."""
    from cli.main import app

    # Test table with underscores in name
    sql_with_underscores = """
    CREATE TABLE crm.tb_machine_contract_relationship (
        pk_machine_contract_relationship INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
        id UUID DEFAULT gen_random_uuid() NOT NULL,
        machine_id UUID NOT NULL,
        contract_id UUID NOT NULL
    );
    """

    with cli_runner.isolated_filesystem():
        Path("tables.sql").write_text(sql_with_underscores)
        Path("out").mkdir()

        result = cli_runner.invoke(app, ["reverse", "sql", "tables.sql", "--output", "out/"])

        assert result.exit_code == 0

        # Find all YAML files recursively
        all_yaml_files = list(Path("out").rglob("*.yaml"))

        # Should create machine_contract_relationship.yaml (snake_case) in entities/
        expected_filename = "machine_contract_relationship.yaml"
        assert any(f.name == expected_filename for f in all_yaml_files), (
            f"Expected {expected_filename}, got {[f.name for f in all_yaml_files]}"
        )


def test_reverse_sql_preserves_comments(cli_runner):
    """Reverse sql should preserve COMMENT ON TABLE and COMMENT ON COLUMN statements."""
    from cli.main import app

    # SQL with table and column comments (like PrintOptim source)
    sql_with_comments = """
    CREATE TABLE catalog.tb_language (
        pk_language INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
        id UUID DEFAULT gen_random_uuid() NOT NULL,
        identifier VARCHAR(255) NOT NULL,
        name VARCHAR(20) NOT NULL,
        created_at TIMESTAMPTZ NOT NULL DEFAULT now()
    );

    -- Documentation
    COMMENT ON TABLE catalog.tb_language IS '[Table: 010111 | Write-Side.Common.Locale.Language] Defines supported languages for the system.';
    COMMENT ON COLUMN catalog.tb_language.identifier IS 'Internal language identifier (e.g., ''fr'', ''de'', ''it'', ''ko'').';
    COMMENT ON COLUMN catalog.tb_language.name IS 'Default display name for the language.';
    """

    with cli_runner.isolated_filesystem():
        Path("language.sql").write_text(sql_with_comments)
        Path("out").mkdir()

        result = cli_runner.invoke(app, ["reverse", "sql", "language.sql", "--output", "out/"])

        assert result.exit_code == 0

        # Find the language entity file
        language_files = list(Path("out/entities").rglob("*language*.yaml"))
        assert len(language_files) > 0, "Language entity file not found"

        yaml_content = language_files[0].read_text()

        # Should preserve table comment as description
        assert "Table: 010111 | Write-Side.Common.Locale.Language" in yaml_content
        assert "Defines supported" in yaml_content and "languages for the system" in yaml_content

        # Should preserve column comments
        assert "Internal language identifier" in yaml_content
        assert (
            "fr" in yaml_content
            and "de" in yaml_content
            and "it" in yaml_content
            and "ko" in yaml_content
        )
        assert "Default display name for the language" in yaml_content


def test_reverse_sql_preserves_comments_edge_cases(cli_runner):
    """Reverse sql should handle edge cases in COMMENT statements."""
    from cli.main import app

    # SQL with various comment edge cases
    sql_with_edge_cases = """
    CREATE TABLE test.tb_edge_cases (
        pk_edge_cases INTEGER PRIMARY KEY,
        simple_col TEXT,
        quoted_col TEXT
    );

    -- Simple comment
    COMMENT ON TABLE test.tb_edge_cases IS 'Simple table comment.';

    -- Comment with single quotes (escaped)
    COMMENT ON COLUMN test.tb_edge_cases.simple_col IS 'Column with ''single quotes'' inside.';

    -- Comment with special characters
    COMMENT ON COLUMN test.tb_edge_cases.quoted_col IS 'Column with special chars: @#$%^&*()';
    """

    with cli_runner.isolated_filesystem():
        Path("edge_cases.sql").write_text(sql_with_edge_cases)
        Path("out").mkdir()

        result = cli_runner.invoke(app, ["reverse", "sql", "edge_cases.sql", "--output", "out/"])

        assert result.exit_code == 0

        # Find the edge_cases entity file
        entity_files = list(Path("out/entities").rglob("*edge_cases*.yaml"))
        assert len(entity_files) > 0, "Edge cases entity file not found"

        yaml_content = entity_files[0].read_text()

        # Should handle simple comments
        assert "Simple table comment" in yaml_content

        # Should handle escaped quotes
        assert "single quotes" in yaml_content

        # Should handle special characters
        assert "special chars" in yaml_content


def test_reverse_sql_generates_project_yaml(cli_runner):
    """Reverse sql should generate project.yaml with schemas and extensions."""
    from cli.main import app

    # SQL with multiple schemas and UUID usage (should detect uuid-ossp extension)
    sql_with_multiple_schemas = """
    CREATE TABLE catalog.tb_language (
        pk_language INTEGER PRIMARY KEY,
        id UUID DEFAULT gen_random_uuid() NOT NULL,
        name VARCHAR(20) NOT NULL
    );

    CREATE TABLE tenant.tb_contact (
        pk_contact INTEGER PRIMARY KEY,
        id UUID DEFAULT gen_random_uuid() NOT NULL,
        tenant_id UUID NOT NULL,
        email TEXT NOT NULL
    );

    CREATE TABLE common.tb_currency (
        pk_currency INTEGER PRIMARY KEY,
        code VARCHAR(3) NOT NULL,
        name VARCHAR(50) NOT NULL
    );
    """

    with cli_runner.isolated_filesystem():
        Path("multi_schema.sql").write_text(sql_with_multiple_schemas)
        Path("out").mkdir()

        result = cli_runner.invoke(app, ["reverse", "sql", "multi_schema.sql", "--output", "out/"])

        if result.exit_code != 0:
            print(f"Command failed with output: {result.output}")
            print(f"Exception: {result.exception}")
        assert result.exit_code == 0

        # Should generate project.yaml
        project_yaml = Path("out/project.yaml")
        assert project_yaml.exists(), "project.yaml should be generated"

        # Should generate registry
        registry_yaml = Path("out/registry/domain_registry.yaml")
        assert registry_yaml.exists(), "registry/domain_registry.yaml should be generated"

        project_content = project_yaml.read_text()
        registry_content = registry_yaml.read_text()

        # Should contain detected schemas
        assert "name: catalog" in project_content
        assert "name: tenant" in project_content
        assert "name: common" in project_content

        # Should contain uuid-ossp extension (detected from gen_random_uuid())
        assert "uuid-ossp" in project_content

        # Should contain basic project metadata
        assert "version:" in project_content
        assert "name: multi_schema_project" in project_content

        # Should contain registry with detected schemas
        assert "domains:" in registry_content
        assert "catalog" in registry_content
        assert "tenant" in registry_content
        assert "common" in registry_content


def test_reverse_sql_hierarchical_numbering(cli_runner):
    """Reverse sql should preserve hierarchical numbering from source files."""
    from cli.main import app

    # Create directory structure with numbered files (PrintOptim style)
    sql_structure = {
        "db/0_schema/01_write_side/010_i18n/0101_locale/01011_language/010111_tb_language.sql": """
        CREATE TABLE catalog.tb_language (
            pk_language INTEGER PRIMARY KEY,
            id UUID DEFAULT gen_random_uuid() NOT NULL,
            identifier VARCHAR(255) NOT NULL,
            name VARCHAR(20) NOT NULL
        );
        """,
        "db/0_schema/01_write_side/012_crm/0121_contact/012111_tb_contact.sql": """
        CREATE TABLE tenant.tb_contact (
            pk_contact INTEGER PRIMARY KEY,
            id UUID DEFAULT gen_random_uuid() NOT NULL,
            email TEXT NOT NULL
        );
        """,
    }

    with cli_runner.isolated_filesystem():
        # Create directory structure and files
        for file_path, sql_content in sql_structure.items():
            Path(file_path).parent.mkdir(parents=True, exist_ok=True)
            Path(file_path).write_text(sql_content)

        Path("out").mkdir()

        # Run reverse engineering on specific files
        result = cli_runner.invoke(
            app,
            [
                "reverse",
                "sql",
                "db/0_schema/01_write_side/010_i18n/0101_locale/01011_language/010111_tb_language.sql",
                "db/0_schema/01_write_side/012_crm/0121_contact/012111_tb_contact.sql",
                "--output",
                "out/",
            ],
        )
        if result.exit_code != 0:
            print(f"Command failed with output: {result.output}")
            print(f"Exception: {result.exception}")
        assert result.exit_code == 0

        # Debug: list all files created
        import glob

        all_files = list(Path("out").rglob("*.yaml"))
        print(f"Created files: {[str(f) for f in all_files]}")

        # Should create hierarchical output structure
        language_yaml = Path(
            "out/entities/010_i18n/0101_locale/01011_language/010111_language.yaml"
        )
        contact_yaml = Path("out/entities/012_crm/0121_contact/012111_contact.yaml")

        assert language_yaml.exists(), (
            f"Expected hierarchical path: {language_yaml}, but found: {[str(f) for f in all_files]}"
        )
        assert contact_yaml.exists(), (
            f"Expected hierarchical path: {contact_yaml}, but found: {[str(f) for f in all_files]}"
        )

        # Verify content
        language_content = language_yaml.read_text()
        contact_content = contact_yaml.read_text()

        assert "entity: Language" in language_content
        assert "schema: catalog" in language_content
        assert "entity: Contact" in contact_content
        assert "schema: tenant" in contact_content


def test_reverse_sql_hierarchical_fallback(cli_runner):
    """Reverse sql should fall back to flat structure when no numbering."""
    from cli.main import app

    # SQL files without numbering
    sql_without_numbering = """
    CREATE TABLE catalog.users (
        pk_users INTEGER PRIMARY KEY,
        email TEXT NOT NULL
    );
    """

    with cli_runner.isolated_filesystem():
        Path("schema.sql").write_text(sql_without_numbering)
        Path("out").mkdir()

        result = cli_runner.invoke(app, ["reverse", "sql", "schema.sql", "--output", "out/"])
        assert result.exit_code == 0

        # Should create flat structure
        users_yaml = Path("out/entities/users.yaml")
        assert users_yaml.exists(), "Should fall back to flat structure"

        content = users_yaml.read_text()
        assert "entity: Users" in content
        assert "schema: catalog" in content


def test_project_yaml_round_trip(cli_runner):
    """Test round-trip: SQL → project.yaml → foundation SQL."""
    from cli.main import app
    from core.project_config import ProjectConfig
    from generators.foundation_generator import FoundationGenerator

    # First, generate project.yaml from SQL
    sql_with_multiple_schemas = """
    CREATE TABLE catalog.tb_language (
        pk_language INTEGER PRIMARY KEY,
        id UUID DEFAULT gen_random_uuid() NOT NULL,
        name VARCHAR(20) NOT NULL
    );

    CREATE TABLE tenant.tb_contact (
        pk_contact INTEGER PRIMARY KEY,
        id UUID DEFAULT gen_random_uuid() NOT NULL,
        email TEXT NOT NULL
    );
    """

    with cli_runner.isolated_filesystem():
        Path("multi_schema.sql").write_text(sql_with_multiple_schemas)
        Path("out").mkdir()

        # Generate project.yaml
        result = cli_runner.invoke(app, ["reverse", "sql", "multi_schema.sql", "--output", "out/"])
        assert result.exit_code == 0

        # Load project config
        project_yaml = Path("out/project.yaml")
        config = ProjectConfig.from_yaml(project_yaml)

        # Generate foundation SQL
        foundation_gen = FoundationGenerator()
        foundation_sql = foundation_gen.generate(config)

        # Verify foundation SQL contains expected content
        assert 'CREATE EXTENSION IF NOT EXISTS "uuid-ossp";' in foundation_sql
        assert "CREATE SCHEMA IF NOT EXISTS catalog;" in foundation_sql
        assert "CREATE SCHEMA IF NOT EXISTS tenant;" in foundation_sql
        assert "COMMENT ON SCHEMA catalog IS" in foundation_sql
        assert "COMMENT ON SCHEMA tenant IS" in foundation_sql
