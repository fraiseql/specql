# tests/unit/cli/commands/reverse/test_sql_integration.py
import sys
from pathlib import Path

# Add src to path for new CLI structure
project_root = Path(__file__).parent.parent.parent.parent.parent  # /home/lionel/code/specql
src_path = project_root / "src"
sys.path.insert(0, str(src_path))

import pytest
from click.testing import CliRunner


@pytest.fixture
def cli_runner():
    return CliRunner()


@pytest.fixture
def sample_sql_ddl():
    return """
    CREATE TABLE crm.tb_contact (
        pk_contact INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
        id UUID DEFAULT gen_random_uuid() NOT NULL,
        tenant_id UUID NOT NULL,
        email TEXT NOT NULL,
        created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
        created_by UUID,
        updated_at TIMESTAMPTZ NOT NULL DEFAULT now(),
        updated_by UUID,
        deleted_at TIMESTAMPTZ,
        deleted_by UUID
    );
    """


def test_reverse_sql_creates_yaml(cli_runner, sample_sql_ddl):
    """Reverse sql should create YAML from SQL DDL."""
    from cli.main import app

    with cli_runner.isolated_filesystem():
        Path("tables.sql").write_text(sample_sql_ddl)
        Path("out").mkdir()

        result = cli_runner.invoke(app, ["reverse", "sql", "tables.sql", "--output", "out/"])

        assert result.exit_code == 0
        yaml_files = list(Path("out/").glob("*.yaml"))
        assert len(yaml_files) > 0

        # Check that the YAML contains expected content
        yaml_content = yaml_files[0].read_text()
        assert "entity: Contact" in yaml_content  # Note: capitalized
        assert "schema: crm" in yaml_content
        assert "email:" in yaml_content


def test_reverse_sql_preview_mode(cli_runner, sample_sql_ddl):
    """Reverse sql --preview should not write files."""
    from cli.main import app

    with cli_runner.isolated_filesystem():
        Path("tables.sql").write_text(sample_sql_ddl)
        Path("out").mkdir()

        result = cli_runner.invoke(
            app, ["reverse", "sql", "tables.sql", "--output", "out/", "--preview"]
        )

        assert result.exit_code == 0
        assert "Preview mode" in result.output
        yaml_files = list(Path("out/").glob("*.yaml"))
        assert len(yaml_files) == 0


def test_reverse_sql_with_foreign_keys(cli_runner):
    """Reverse sql should handle foreign key relationships."""
    from cli.main import app

    sql_with_fk = """
    CREATE TABLE crm.tb_contact (
        pk_contact INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
        id UUID DEFAULT gen_random_uuid() NOT NULL,
        tenant_id UUID NOT NULL,
        email TEXT NOT NULL
    );

    CREATE TABLE crm.tb_organization (
        pk_organization INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
        id UUID DEFAULT gen_random_uuid() NOT NULL,
        tenant_id UUID NOT NULL,
        name TEXT NOT NULL
    );

    ALTER TABLE crm.tb_contact ADD CONSTRAINT fk_contact_organization
        FOREIGN KEY (fk_organization) REFERENCES crm.tb_organization(pk_organization);
    """

    with cli_runner.isolated_filesystem():
        Path("schema.sql").write_text(sql_with_fk)
        Path("out").mkdir()

        result = cli_runner.invoke(app, ["reverse", "sql", "schema.sql", "--output", "out/"])

        assert result.exit_code == 0
        yaml_files = list(Path("out/").glob("*.yaml"))
        assert len(yaml_files) >= 1  # At least contact should be created


def test_reverse_sql_min_confidence_filtering(cli_runner):
    """Reverse sql should filter based on confidence threshold."""
    from cli.main import app

    # Simple table that should have high confidence for Trinity pattern
    simple_table = """
    CREATE TABLE public.users (
        id SERIAL PRIMARY KEY,
        email TEXT NOT NULL,
        created_at TIMESTAMP DEFAULT now()
    );
    """

    with cli_runner.isolated_filesystem():
        Path("simple.sql").write_text(simple_table)
        Path("out").mkdir()

        # Test with very high confidence threshold
        result = cli_runner.invoke(
            app, ["reverse", "sql", "simple.sql", "--output", "out/", "--min-confidence", "0.95"]
        )

        assert result.exit_code == 0
        # Should still work but might show warnings about low confidence


def test_reverse_sql_no_ai_flag(cli_runner, sample_sql_ddl):
    """Reverse sql --no-ai should skip function parsing."""
    from cli.main import app

    sql_with_function = (
        sample_sql_ddl
        + """

    CREATE OR REPLACE FUNCTION crm.get_contact_by_email(user_email TEXT)
    RETURNS TABLE(id UUID, email TEXT) AS $$
    BEGIN
        RETURN QUERY
        SELECT c.id, c.email
        FROM crm.tb_contact c
        WHERE c.email = user_email;
    END;
    $$ LANGUAGE plpgsql;
    """
    )

    with cli_runner.isolated_filesystem():
        Path("with_function.sql").write_text(sql_with_function)
        Path("out").mkdir()

        result = cli_runner.invoke(
            app, ["reverse", "sql", "with_function.sql", "--output", "out/", "--no-ai"]
        )

        assert result.exit_code == 0
        # Should still work without AI parsing


def test_reverse_sql_handles_invalid_sql(cli_runner):
    """Reverse sql should handle invalid SQL gracefully."""
    from cli.main import app

    invalid_sql = """
    CREATE TABLE invalid (
        id INTEGER PRIMARY KEY,
        -- Missing closing parenthesis
    """

    with cli_runner.isolated_filesystem():
        Path("invalid.sql").write_text(invalid_sql)
        Path("out").mkdir()

        result = cli_runner.invoke(app, ["reverse", "sql", "invalid.sql", "--output", "out/"])

        # Should not crash, but may skip invalid statements
        assert (
            result.exit_code == 0 or result.exit_code == 1
        )  # Allow either success or controlled failure
