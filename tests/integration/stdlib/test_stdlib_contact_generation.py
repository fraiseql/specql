from pathlib import Path

import pytest

from src.cli.generate import convert_entity_definition_to_entity
from src.core.specql_parser import SpecQLParser
from src.generators.schema_orchestrator import SchemaOrchestrator


def load_snapshot(snapshot_path: Path) -> str:
    """Load snapshot content from file"""
    if not snapshot_path.exists():
        pytest.fail(
            f"Snapshot file {snapshot_path} does not exist. Run with --snapshot-update to create it."
        )
    return snapshot_path.read_text()


def save_snapshot(snapshot_path: Path, content: str):
    """Save content to snapshot file"""
    snapshot_path.parent.mkdir(parents=True, exist_ok=True)
    snapshot_path.write_text(content)


def test_generate_contact_entity_snapshot():
    """Snapshot test for Contact entity DDL generation"""
    import os

    # Parse the Contact entity from stdlib
    parser = SpecQLParser()
    contact_path = Path("stdlib/crm/contact.yaml")
    entity_def = parser.parse(contact_path.read_text())

    # Convert to Entity for orchestrator
    entity = convert_entity_definition_to_entity(entity_def)

    # Generate complete DDL using schema orchestrator
    orchestrator = SchemaOrchestrator()
    ddl = orchestrator.generate_complete_schema(entity)

    # Snapshot testing
    snapshot_path = Path("tests/integration/stdlib/snapshots/contact_entity_ddl.sql")

    if os.environ.get("SNAPSHOT_UPDATE") == "1":
        # Update mode: save the current DDL as the new snapshot
        save_snapshot(snapshot_path, ddl)
        pytest.skip("Snapshot updated")
    else:
        # Test mode: compare against existing snapshot
        expected_ddl = load_snapshot(snapshot_path)
        assert (
            ddl == expected_ddl
        ), "DDL does not match snapshot. Run with SNAPSHOT_UPDATE=1 to update the snapshot if this change is intentional."


def test_generate_contact_entity_production_readiness():
    """Test that Contact entity DDL is production-ready with proper structure"""
    # Parse the Contact entity from stdlib
    parser = SpecQLParser()
    contact_path = Path("stdlib/crm/contact.yaml")
    entity_def = parser.parse(contact_path.read_text())

    # Convert to Entity for orchestrator
    entity = convert_entity_definition_to_entity(entity_def)

    # Generate complete DDL using schema orchestrator
    orchestrator = SchemaOrchestrator()
    ddl = orchestrator.generate_complete_schema(entity)

    # Production readiness checks
    lines = ddl.strip().split("\n")

    # Should generate substantial DDL (not empty)
    assert len(lines) > 100, "Generated DDL should be substantial for production use"

    # Should include app schema foundation
    assert any(
        "CREATE SCHEMA IF NOT EXISTS app;" in line for line in lines
    ), "Should create app schema"

    # Should include mutation result type
    assert any(
        "CREATE TYPE app.mutation_result" in line for line in lines
    ), "Should define mutation result type"

    # Should include audit logging
    assert any(
        "CREATE TABLE app.tb_mutation_audit_log" in line for line in lines
    ), "Should create audit log table"

    # Should create tenant schema
    assert any(
        "CREATE SCHEMA IF NOT EXISTS tenant;" in line for line in lines
    ), "Should create tenant schema"

    # Should create contact table with proper structure
    contact_table_start = None
    for i, line in enumerate(lines):
        if "CREATE TABLE tenant.tb_contact" in line:
            contact_table_start = i
            break

    assert contact_table_start is not None, "Should create tenant.tb_contact table"

    # Extract contact table DDL
    contact_ddl_lines = []
    paren_depth = 0
    for line in lines[contact_table_start:]:
        contact_ddl_lines.append(line)
        paren_depth += line.count("(") - line.count(")")
        if paren_depth == 0 and line.strip().endswith(");"):
            break

    contact_ddl = "\n".join(contact_ddl_lines)

    # Production table structure validation
    assert "pk_contact INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY" in contact_ddl
    assert "id UUID DEFAULT gen_random_uuid() NOT NULL" in contact_ddl
    assert "tenant_id UUID NOT NULL" in contact_ddl

    # Should have rich type constraints
    assert "CHECK (email_address ~* " in ddl
    assert "CHECK (office_phone ~* " in ddl or "CHECK (mobile_phone ~* " in ddl

    # Should have foreign key constraints
    assert "REFERENCES tenant.tb_organization" in ddl
    assert "REFERENCES tenant.tb_genre" in ddl

    # Should have proper indexes
    assert "CREATE INDEX idx_tb_contact_tenant ON tenant.tb_contact(tenant_id);" in ddl

    # Should have FraiseQL metadata
    assert "@fraiseql:type" in ddl
    assert "trinity: true" in ddl

    # Should generate input types for actions
    assert "CREATE TYPE app.type_create_contact_input" in ddl
    assert "CREATE TYPE app.type_update_contact_input" in ddl

    # Should have FraiseQL input type metadata
    assert "@fraiseql:composite" in ddl
    assert "name: CreateContactInput" in ddl
    assert "name: UpdateContactInput" in ddl

    # Should have comprehensive action coverage (multiple input types generated)
    action_inputs = [
        "type_create_contact_input",
        "type_update_contact_input",
        "type_activate_contact_input",
        "type_deactivate_contact_input",
        "type_change_email_address_input",
        "type_change_office_phone_input",
        "type_change_mobile_phone_input",
        "type_update_job_title_input",
        "type_update_position_input",
        "type_change_timezone_input",
    ]

    for action_input in action_inputs:
        assert f"CREATE TYPE app.{action_input}" in ddl, f"Should generate {action_input}"


def validate_rich_type_fields(ddl: str):
    """Validate rich type fields are properly generated with constraints"""
    # Email field with validation
    assert "email_address TEXT NOT NULL" in ddl
    assert "CHECK (email_address ~* " in ddl
    assert "@" in ddl  # Email regex pattern

    # Phone fields with E.164 validation
    assert "office_phone TEXT" in ddl
    assert "mobile_phone TEXT" in ddl
    assert "CHECK (office_phone ~* " in ddl or "CHECK (mobile_phone ~* " in ddl
    assert "+" in ddl  # Phone E.164 pattern


def validate_foreign_key_references(ddl: str):
    """Validate foreign key relationships are properly generated"""
    assert "REFERENCES tenant.tb_organization" in ddl
    assert "REFERENCES tenant.tb_genre" in ddl


def validate_trinity_pattern(ddl: str):
    """Validate Trinity pattern (pk, id, tenant_id) is properly implemented"""
    assert "pk_contact INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY" in ddl
    assert "id UUID DEFAULT gen_random_uuid() NOT NULL" in ddl
    assert "tenant_id UUID NOT NULL" in ddl


def validate_audit_fields(ddl: str):
    """Validate audit fields are properly generated"""
    assert "created_at TIMESTAMPTZ NOT NULL DEFAULT now()" in ddl
    assert "updated_at TIMESTAMPTZ NOT NULL DEFAULT now()" in ddl


def test_generate_contact_entity_full_ddl():
    """Generate complete DDL for stdlib Contact entity"""
    # Parse the Contact entity from stdlib
    parser = SpecQLParser()
    contact_path = Path("stdlib/crm/contact.yaml")
    entity_def = parser.parse(contact_path.read_text())

    # Convert to Entity for orchestrator
    entity = convert_entity_definition_to_entity(entity_def)

    # Generate complete DDL using schema orchestrator
    orchestrator = SchemaOrchestrator()
    ddl = orchestrator.generate_complete_schema(entity)

    # Verify table creation
    assert "CREATE TABLE tenant.tb_contact" in ddl

    # Validate rich type fields and constraints
    validate_rich_type_fields(ddl)

    # Validate foreign key relationships
    validate_foreign_key_references(ddl)

    # Validate Trinity pattern implementation
    validate_trinity_pattern(ddl)

    # Validate audit fields
    validate_audit_fields(ddl)
