"""Integration test with actual PrintOptim manufacturer table."""

from click.testing import CliRunner

from cli.main import app


class TestPrintOptimMigration:
    """Test reverse engineering with real PrintOptim schema."""

    def test_printoptim_manufacturer_extraction(self, tmp_path):
        """Test with actual PrintOptim manufacturer table."""
        # Create PrintOptim-style manufacturer table
        sql_file = tmp_path / "tb_manufacturer.sql"
        sql_file.write_text("""
        CREATE TABLE catalog.tb_manufacturer (
            id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
            pk_manufacturer UUID DEFAULT gen_random_uuid() NOT NULL,
            identifier TEXT NOT NULL,
            name TEXT,
            abbreviation CHAR(2) NOT NULL,
            created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
            created_by UUID,
            updated_at TIMESTAMPTZ NOT NULL DEFAULT now(),
            updated_by UUID,
            deleted_at TIMESTAMPTZ,
            deleted_by UUID,
            CONSTRAINT tb_manufacturer_identifier_key UNIQUE (identifier),
            CONSTRAINT tb_manufacturer_pk_manufacturer_key UNIQUE (pk_manufacturer)
        );

        ALTER TABLE catalog.tb_manufacturer
            ADD CONSTRAINT tb_manufacturer_created_by_fkey
            FOREIGN KEY (created_by)
            REFERENCES management.tb_user(pk_user);

        ALTER TABLE catalog.tb_manufacturer
            ADD CONSTRAINT tb_manufacturer_updated_by_fkey
            FOREIGN KEY (updated_by)
            REFERENCES management.tb_user(pk_user);

        ALTER TABLE catalog.tb_manufacturer
            ADD CONSTRAINT tb_manufacturer_deleted_by_fkey
            FOREIGN KEY (deleted_by)
            REFERENCES management.tb_user(pk_user);
        """)

        output_dir = tmp_path / "output"

        runner = CliRunner()
        result = runner.invoke(app, ["reverse", "sql", str(sql_file), "-o", str(output_dir)])

        assert result.exit_code == 0

        # The entity should be named "manufacturer" (lowercased from tb_manufacturer)
        # Files are now generated in entities/ subdirectory with hierarchical paths
        yaml_files = list(output_dir.glob("**/*.yaml"))
        manufacturer_files = [
            f
            for f in yaml_files
            if "manufacturer" in f.name.lower() and "project" not in f.name.lower()
        ]
        assert len(manufacturer_files) > 0, f"Expected manufacturer.yaml, found: {yaml_files}"
        yaml_path = manufacturer_files[0]

        yaml_content = yaml_path.read_text()

        # Verify Trinity pattern detected
        assert "entity: Manufacturer" in yaml_content
        assert "trinity" in yaml_content

        # Verify business fields only (no id, pk_*, audit fields)
        # Check that these fields don't appear as field names (but may appear in other contexts)
        lines = yaml_content.split("\n")
        field_lines = [
            line
            for line in lines
            if line.strip().startswith(
                (
                    "id:",
                    "pk_manufacturer:",
                    "created_at:",
                    "created_by:",
                    "updated_at:",
                    "updated_by:",
                    "deleted_at:",
                    "deleted_by:",
                )
            )
        ]
        assert len(field_lines) == 0, f"Found technical fields in output: {field_lines}"

        # Verify business fields present
        assert "identifier: text!" in yaml_content
        assert "name: text" in yaml_content
        assert "abbreviation: char(2)!" in yaml_content

        # Verify FK references (created_by etc. should be excluded as audit)
        # Note: created_by is audit field, so not included in business fields
