"""
Integration tests for Team B - SQL Generation from SpecQL
"""

from pathlib import Path

import pytest

from src.core.ast_models import Action, Entity, FieldDefinition
from src.core.specql_parser import SpecQLParser
from src.generators.function_generator import FunctionGenerator
from src.generators.schema_orchestrator import SchemaOrchestrator
from src.generators.table_generator import TableGenerator


class TestTeamBIntegration:
    """Test Team B generators with real SpecQL examples"""

    @pytest.fixture
    def parser(self):
        """Create SpecQL parser"""
        return SpecQLParser()

    @pytest.fixture
    def table_generator(self, schema_registry):
        """Create table generator"""
        return TableGenerator(schema_registry)

    @pytest.fixture
    def function_generator(self, schema_registry):
        """Create function generator"""
        return FunctionGenerator(schema_registry)

    def test_contact_lightweight_integration(
        self, parser, table_generator, function_generator
    ):
        """Test full integration with contact_lightweight.yaml"""
        # Parse SpecQL
        yaml_path = Path("entities/examples/contact_lightweight.yaml")
        entity = parser.parse(yaml_path.read_text())

        # Verify parsing
        assert entity.name == "Contact"
        assert entity.schema == "crm"
        assert (
            len(entity.fields) == 6
        )  # email, first_name, last_name, company, status, phone
        assert len(entity.actions) == 2  # create_contact, qualify_lead

        # Generate table DDL
        ddl = table_generator.generate_table_ddl(entity)

        # Verify table structure
        assert "CREATE TABLE crm.tb_contact" in ddl
        assert "pk_contact INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY" in ddl
        assert "id UUID DEFAULT gen_random_uuid() NOT NULL" in ddl

        # Verify fields
        assert "email TEXT" in ddl
        assert "status TEXT" in ddl
        assert "fk_company INTEGER" in ddl

        # Verify enum constraint
        assert "CHECK (status IN ('lead', 'qualified', 'customer'))" in ddl

        # Verify foreign key
        fk_ddl = table_generator.generate_foreign_keys_ddl(entity)
        assert "REFERENCES crm.tb_company(pk_company)" in fk_ddl

        # Verify indexes
        idx_ddl = table_generator.generate_indexes_ddl(entity)
        assert "CREATE INDEX idx_tb_contact_id" in idx_ddl
        assert "CREATE INDEX idx_tb_contact_company" in idx_ddl
        assert "CREATE INDEX idx_tb_contact_status" in idx_ddl

        # Generate action functions (app wrapper + core logic pattern)
        action_sql = function_generator.generate_action_functions(entity)
        assert (
            "CREATE OR REPLACE FUNCTION app.qualify_lead" in action_sql
        )  # App wrapper
        # TODO: Custom actions like qualify_lead don't have core logic yet
        # assert "CREATE OR REPLACE FUNCTION crm.qualify_lead" in action_sql  # Core logic (not implemented for custom actions)
        assert (
            "CREATE OR REPLACE FUNCTION app.create_contact" in action_sql
        )  # App wrapper for CRUD
        assert (
            "CREATE OR REPLACE FUNCTION crm.create_contact" in action_sql
        )  # Core logic for CRUD works
        assert "LANGUAGE plpgsql" in action_sql

    def test_task_lightweight_integration(
        self, parser, table_generator, function_generator
    ):
        """Test full integration with task_lightweight.yaml"""
        # Parse SpecQL
        yaml_path = Path("entities/examples/task_lightweight.yaml")
        entity = parser.parse(yaml_path.read_text())

        # Verify parsing
        assert entity.name == "Task"
        assert len(entity.fields) == 6
        assert len(entity.actions) == 2

        # Generate table DDL
        ddl = table_generator.generate_table_ddl(entity)

        # Verify table structure
        assert "CREATE TABLE projects.tb_task" in ddl
        assert "pk_task INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY" in ddl

        # Verify fields
        assert "title TEXT" in ddl
        assert "fk_assignee INTEGER" in ddl  # Foreign key
        assert "status TEXT" in ddl

        # Verify enum constraint
        assert "CHECK (status IN ('todo', 'in_progress', 'done'))" in ddl

        # Generate action functions (app wrapper + core logic pattern)
        action_sql = function_generator.generate_action_functions(entity)
        assert "CREATE OR REPLACE FUNCTION app.assign_task" in action_sql  # App wrapper
        # TODO: Custom actions don't have core logic yet
        # assert "CREATE OR REPLACE FUNCTION projects.assign_task" in action_sql  # Core logic
        assert "LANGUAGE plpgsql" in action_sql

    def test_manufacturer_example_integration(self, parser, table_generator):
        """Test integration with manufacturer.yaml (more complex example)"""
        yaml_path = Path("entities/examples/manufacturer.yaml")
        entity = parser.parse(yaml_path.read_text())

        # Verify parsing
        assert entity.name == "manufacturer"
        assert entity.schema == "catalog"
        assert len(entity.fields) >= 4

        # Generate table DDL
        ddl = table_generator.generate_table_ddl(entity)

        # Verify table structure
        assert "CREATE TABLE catalog.tb_manufacturer" in ddl
        assert (
            "pk_manufacturer INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY"
            in ddl
        )

    def test_sql_output_validity(self, parser, table_generator):
        """Test that generated SQL is syntactically valid"""
        # Parse a simple entity
        yaml_path = Path("entities/examples/contact_lightweight.yaml")
        entity = parser.parse(yaml_path.read_text())

        # Generate DDL
        ddl = table_generator.generate_table_ddl(entity)
        table_generator.generate_foreign_keys_ddl(entity)
        table_generator.generate_indexes_ddl(entity)

        # Basic syntax checks
        assert ddl.strip().endswith(";")
        assert not ddl.startswith(" ;")  # No leading spaces before CREATE

        # Check for balanced parentheses
        assert ddl.count("(") == ddl.count(")")

        # Check for required Trinity pattern elements
        assert "GENERATED BY DEFAULT AS IDENTITY" in ddl
        assert "DEFAULT gen_random_uuid()" in ddl
        assert "created_at TIMESTAMPTZ NOT NULL DEFAULT now()" in ddl

    def test_trinity_pattern_compliance(self, parser, table_generator):
        """Test that generated tables follow Trinity pattern"""
        yaml_path = Path("entities/examples/contact_lightweight.yaml")
        entity = parser.parse(yaml_path.read_text())

        ddl = table_generator.generate_table_ddl(entity)

        # Trinity Pattern requirements:
        # 1. INTEGER primary key with IDENTITY
        assert "pk_contact INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY" in ddl

        # 2. UUID public identifier
        assert "id UUID DEFAULT gen_random_uuid() NOT NULL" in ddl

        # 3. UNIQUE constraint on UUID
        assert "CONSTRAINT tb_contact_id_key UNIQUE (id)" in ddl

        # 4. Audit fields
        assert "created_at TIMESTAMPTZ NOT NULL DEFAULT now()" in ddl
        assert "created_by UUID" in ddl
        assert "updated_at TIMESTAMPTZ NOT NULL DEFAULT now()" in ddl
        assert "updated_by UUID" in ddl
        assert "deleted_at TIMESTAMPTZ" in ddl
        assert "deleted_by UUID" in ddl

    def test_foreign_key_generation(self, parser, table_generator):
        """Test foreign key constraint generation"""
        yaml_path = Path("entities/examples/contact_lightweight.yaml")
        entity = parser.parse(yaml_path.read_text())

        fk_ddl = table_generator.generate_foreign_keys_ddl(entity)

        # Should generate FK for company field
        assert "ALTER TABLE ONLY crm.tb_contact" in fk_ddl
        assert "ADD CONSTRAINT tb_contact_company_fkey" in fk_ddl
        assert (
            "FOREIGN KEY (fk_company) REFERENCES crm.tb_company(pk_company)" in fk_ddl
        )


class TestSchemaOrchestratorIntegration:
    """Integration tests for complete schema generation with orchestrator"""

    @pytest.fixture
    def parser(self):
        """Create SpecQL parser"""
        return SpecQLParser()

    @pytest.fixture
    def orchestrator(self):
        """Create schema orchestrator"""
        return SchemaOrchestrator()

    def test_complete_contact_schema_generation(self, parser, orchestrator):
        """Test complete schema generation for contact entity"""
        # Parse SpecQL
        yaml_path = Path("entities/examples/contact_lightweight.yaml")
        entity = parser.parse(yaml_path.read_text())

        # Generate complete schema
        sql = orchestrator.generate_complete_schema(entity)

        # Verify tables
        assert "CREATE TABLE crm.tb_contact" in sql
        assert "pk_contact INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY" in sql
        assert "id UUID DEFAULT gen_random_uuid() NOT NULL" in sql
        assert "email TEXT" in sql
        assert "fk_company INTEGER" in sql  # Internal INTEGER FK
        assert "status TEXT" in sql

        # Verify composite types
        assert "CREATE TYPE app.type_create_contact_input" in sql
        assert "email TEXT" in sql  # External API field
        assert "company_id UUID" in sql  # External UUID reference
        assert "status TEXT" in sql

        # Verify FraiseQL annotations (YAML format)
        assert "@fraiseql:composite" in sql
        assert "name: CreateContactInput" in sql
        assert "@fraiseql:field" in sql
        assert "name: email" in sql
        assert "name: company_id" in sql
        assert "references: Company" in sql

        # Verify common types
        assert "CREATE TYPE app.mutation_result" in sql
        assert "@fraiseql:composite" in sql  # YAML format
        assert "name: MutationResult" in sql

        # Verify indexes
        assert "CREATE INDEX idx_tb_contact_id" in sql
        assert "CREATE INDEX idx_tb_contact_company" in sql
        assert "CREATE INDEX idx_tb_contact_status" in sql

        # Verify foreign keys
        assert "FOREIGN KEY (fk_company) REFERENCES crm.tb_company(pk_company)" in sql

    def test_schema_orchestrator_with_task_entity(self, parser, orchestrator):
        """Test schema orchestration with task entity"""
        yaml_path = Path("entities/examples/task_lightweight.yaml")
        entity = parser.parse(yaml_path.read_text())

        sql = orchestrator.generate_complete_schema(entity)

        # Verify table structure
        assert "CREATE TABLE projects.tb_task" in sql
        assert "fk_assignee INTEGER" in sql

        # Verify composite types (currently only includes id by default)
        assert "CREATE TYPE app.type_assign_task_input" in sql
        assert "id UUID" in sql  # Input type includes entity ID

        # Verify FraiseQL annotations (YAML format)
        assert "@fraiseql:composite" in sql
        assert "name: AssignTaskInput" in sql

    def test_generated_sql_is_valid_postgresql(self, parser, orchestrator):
        """Test that generated SQL is syntactically valid PostgreSQL"""
        yaml_path = Path("entities/examples/contact_lightweight.yaml")
        entity = parser.parse(yaml_path.read_text())

        sql = orchestrator.generate_complete_schema(entity)

        # Basic syntax checks
        assert sql.strip()
        assert not sql.startswith(";")  # No leading semicolons

        # Count CREATE statements
        create_count = sql.count("CREATE ")
        assert create_count >= 3  # At least table, type, and common types

        # Check for balanced parentheses in type definitions
        lines = sql.split("\n")
        for line in lines:
            if "CREATE TYPE" in line:
                # Find the corresponding closing parenthesis
                paren_count = 0
                found_open = False
                for char in line:
                    if char == "(":
                        found_open = True
                        paren_count += 1
                    elif char == ")":
                        paren_count -= 1
                # Should have at least one opening paren
                assert found_open, f"Type definition missing opening paren: {line}"

    def test_schema_orchestrator_handles_multiple_actions(self, parser, orchestrator):
        """Test that orchestrator handles entities with multiple actions"""
        # Create a test entity with multiple actions
        entity = Entity(
            name="TestEntity",
            schema="test",
            fields={
                "name": FieldDefinition(name="name", type_name="text", nullable=False),
                "value": FieldDefinition(
                    name="value", type_name="integer", nullable=True
                ),
            },
            actions=[
                Action(name="create_test_entity", steps=[]),
                Action(name="update_test_entity", steps=[]),
                Action(name="delete_test_entity", steps=[]),
            ],
        )

        sql = orchestrator.generate_complete_schema(entity)

        # Should generate types for create and update, but not delete
        assert "CREATE TYPE app.type_create_test_entity_input" in sql
        assert "CREATE TYPE app.type_update_test_entity_input" in sql
        assert (
            "type_delete_test_entity_input" not in sql
        )  # Delete actions don't need input types

        # Both types should have appropriate fields
        assert "name TEXT" in sql
        assert "value INTEGER" in sql
