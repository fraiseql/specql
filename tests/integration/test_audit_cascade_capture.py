"""
Integration tests for audit cascade capture functionality
"""

from uuid import uuid4


class TestAuditCascadeCapture:
    """Integration tests for cascade data capture in audit triggers"""

    def test_audit_captures_cascade_data(self, test_db):
        """Test that audit triggers capture cascade data from mutations"""

        # Setup: Create Post entity with audit trail + cascade
        setup_sql = """
            CREATE SCHEMA IF NOT EXISTS blog;
            CREATE SCHEMA IF NOT EXISTS app;

            -- Create tables
            CREATE TABLE blog.tb_post (
                pk_post INTEGER PRIMARY KEY,
                id UUID NOT NULL UNIQUE DEFAULT gen_random_uuid(),
                title TEXT,
                tenant_id UUID NOT NULL
            );

            CREATE TABLE blog.tb_user (
                pk_user INTEGER PRIMARY KEY,
                id UUID NOT NULL UNIQUE DEFAULT gen_random_uuid(),
                post_count INTEGER DEFAULT 0,
                tenant_id UUID NOT NULL
            );

            -- Create audit tables with cascade
            -- (generated by AuditGenerator with include_cascade=True)
            CREATE TABLE app.audit_post (
                audit_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
                entity_id UUID NOT NULL,
                tenant_id UUID NOT NULL,
                operation_type TEXT,
                new_values JSONB,
                cascade_data JSONB,
                cascade_entities TEXT[],
                cascade_source TEXT
            );

            -- Create audit trigger
            -- (generated trigger with cascade capture)
            CREATE OR REPLACE FUNCTION app.audit_trigger_post()
            RETURNS TRIGGER AS $$
            BEGIN
                INSERT INTO app.audit_post (
                    entity_id, tenant_id, operation_type, new_values,
                    cascade_data, cascade_entities, cascade_source
                ) VALUES (
                    NEW.id, NEW.tenant_id, TG_OP, row_to_json(NEW),
                    NULLIF(current_setting('app.cascade_data', true), '')::jsonb,
                    string_to_array(NULLIF(current_setting('app.cascade_entities', true), ''), ','),
                    NULLIF(current_setting('app.cascade_source', true), '')
                );
                RETURN NEW;
            END;
            $$ LANGUAGE plpgsql;

            CREATE TRIGGER audit_trigger_post
            AFTER INSERT ON blog.tb_post
            FOR EACH ROW EXECUTE FUNCTION app.audit_trigger_post();
        """

        test_db.execute(setup_sql)

        # Execute mutation with cascade
        tenant_id = uuid4()
        post_id = uuid4()
        user_id = uuid4()

        mutation_sql = f"""
        DO $$
        DECLARE
            v_cascade_data JSONB;
        BEGIN
            -- Build cascade data (as action function would)
            v_cascade_data := jsonb_build_object(
                'updated', jsonb_build_array(
                    jsonb_build_object(
                        '__typename', 'Post',
                        'id', '{post_id}',
                        'operation', 'CREATED'
                    ),
                    jsonb_build_object(
                        '__typename', 'User',
                        'id', '{user_id}',
                        'operation', 'UPDATED'
                    )
                )
            );

            -- Set session variables
            PERFORM set_config('app.cascade_data', v_cascade_data::text, true);
            PERFORM set_config('app.cascade_entities', 'Post,User', true);
            PERFORM set_config('app.cascade_source', 'create_post', true);

            -- Execute mutation (trigger fires here)
            INSERT INTO blog.tb_post (pk_post, id, title, tenant_id)
            VALUES (1, '{post_id}', 'Test Post', '{tenant_id}');

            -- Clear session variables
            PERFORM set_config('app.cascade_data', NULL, true);
            PERFORM set_config('app.cascade_entities', NULL, true);
            PERFORM set_config('app.cascade_source', NULL, true);
        END $$;
        """

        test_db.execute(mutation_sql)

        # Verify audit record captured cascade
        cursor = test_db.execute(f"""
            SELECT
                cascade_data,
                cascade_entities,
                cascade_source
            FROM app.audit_post
            WHERE entity_id = '{post_id}'
        """)
        audit = cursor.fetchone()

        assert audit is not None
        cascade_data, cascade_entities, cascade_source = audit
        assert cascade_data is not None
        assert 'updated' in cascade_data
        assert len(cascade_data['updated']) == 2
        assert cascade_entities == ['Post', 'User']
        assert cascade_source == 'create_post'

    def test_audit_without_cascade_session_vars(self, test_db):
        """Test audit works normally when cascade session vars are not set"""

        # Setup: Create simple audit table without cascade columns
        setup_sql = """
            CREATE SCHEMA IF NOT EXISTS blog;
            CREATE SCHEMA IF NOT EXISTS app;

            CREATE TABLE blog.tb_comment (
                pk_comment INTEGER PRIMARY KEY,
                id UUID NOT NULL UNIQUE DEFAULT gen_random_uuid(),
                text TEXT,
                tenant_id UUID NOT NULL
            );

            CREATE TABLE app.audit_comment (
                audit_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
                entity_id UUID NOT NULL,
                tenant_id UUID NOT NULL,
                operation_type TEXT,
                new_values JSONB
            );

            CREATE OR REPLACE FUNCTION app.audit_trigger_comment()
            RETURNS TRIGGER AS $$
            BEGIN
                INSERT INTO app.audit_comment (
                    entity_id, tenant_id, operation_type, new_values
                ) VALUES (
                    NEW.id, NEW.tenant_id, TG_OP, row_to_json(NEW)
                );
                RETURN NEW;
            END;
            $$ LANGUAGE plpgsql;

            CREATE TRIGGER audit_trigger_comment
            AFTER INSERT ON blog.tb_comment
            FOR EACH ROW EXECUTE FUNCTION app.audit_trigger_comment();
        """

        test_db.execute(setup_sql)

        # Execute mutation without setting cascade session vars
        tenant_id = uuid4()
        comment_id = uuid4()

        test_db.execute(f"""
            INSERT INTO blog.tb_comment (pk_comment, id, text, tenant_id)
            VALUES (1, '{comment_id}', 'Test Comment', '{tenant_id}');
        """)

        # Verify audit record exists but no cascade data
        cursor = test_db.execute(f"""
            SELECT * FROM app.audit_comment
            WHERE entity_id = '{comment_id}'
        """)
        audit = cursor.fetchone()

        assert audit is not None
        # audit_id, entity_id, tenant_id, operation_type, new_values
        assert str(audit[1]) == str(comment_id)  # entity_id
        assert audit[3] == 'INSERT'  # operation_type
        # No cascade columns should exist in this table