"""
Entity YAML Generator

Converts parsed tables and detected patterns into SpecQL entity YAML.
"""

from datetime import UTC, datetime

import yaml

from .fk_detector import ForeignKeyInfo
from .pattern_orchestrator import PatternDetectionResult
from .table_parser import ParsedTable


class EntityYAMLGenerator:
    """Generates SpecQL entity YAML from parsed tables and patterns."""

    def generate(
        self,
        table: ParsedTable,
        patterns: PatternDetectionResult,
        foreign_keys: list[ForeignKeyInfo] | None = None,
    ) -> str:
        """Generate SpecQL YAML for an entity."""
        # Convert table name to entity name (tb_manufacturer → Manufacturer)
        entity_name = self._table_to_entity_name(table.table_name)

        # Use table comment as description if available
        description = (
            table.table_comment or f"Auto-generated from {table.schema}.{table.table_name}"
        )

        # Build entity dict
        entity = {
            "entity": entity_name,
            "schema": table.schema,
            "description": description,
            "fields": self._build_fields(table, foreign_keys or []),
            "patterns": patterns.patterns,
            "_metadata": {
                "source_table": f"{table.schema}.{table.table_name}",
                "confidence": patterns.confidence,
                "detected_patterns": patterns.patterns,
                "generated_by": "specql-reverse-schema",
                "generated_at": datetime.now(UTC).isoformat(),
            },
        }

        return yaml.dump(entity, default_flow_style=False, sort_keys=False)

    def _table_to_entity_name(self, table_name: str) -> str:
        """Convert table name to entity name (tb_manufacturer → Manufacturer)."""
        # Remove tb_ or tv_ prefix
        name = table_name.removeprefix("tb_").removeprefix("tv_")

        # Convert snake_case to PascalCase
        return "".join(word.capitalize() for word in name.split("_"))

    def _build_fields(self, table: ParsedTable, foreign_keys: list[ForeignKeyInfo]) -> dict:
        """Build the fields dict for the entity."""
        fields = {}
        fk_map = {fk.column: fk for fk in foreign_keys}
        column_comments = table.column_comments or {}

        for column in table.columns:
            # Skip Trinity and audit fields (they're auto-generated by SpecQL)
            if self._is_technical_field(column.name):
                continue

            if column.name in fk_map:
                # Convert fk_company → company: ref(Organization)
                fk = fk_map[column.name]
                field_name = self._fk_to_field_name(column.name)
                field_value = f"ref({fk.entity_name})"
            else:
                # Regular field - use column name as field name
                field_name = column.name
                field_type = self._format_field_type(column)
                field_value = field_type

            # Add description if comment exists (use original column name for comment lookup)
            if column.name in column_comments:
                fields[field_name] = {
                    "type": field_value,
                    "description": column_comments[column.name],
                }
            else:
                fields[field_name] = field_value

        return fields

    def _is_technical_field(self, column_name: str) -> bool:
        """Check if a column is a technical field that should be excluded."""
        technical_fields = {
            "id",
            "pk_" + column_name.split("pk_")[-1] if "pk_" in column_name else "",
            "created_at",
            "created_by",
            "updated_at",
            "updated_by",
            "deleted_at",
            "deleted_by",
        }
        return column_name in technical_fields or column_name.startswith("pk_")

    def _fk_to_field_name(self, fk_column: str) -> str:
        """Convert fk_company → company."""
        return fk_column.removeprefix("fk_")

    def _format_field_type(self, column) -> str:
        """Format column type with nullability (text → text!)."""
        type_str = column.specql_type
        if not column.nullable:
            type_str += "!"
        return type_str

    def _get_timestamp(self):
        """Get current timestamp for metadata."""
        return datetime.now(UTC).isoformat()

    def _generate_yaml(self, entity_dict):
        """Generate YAML from entity dict."""
        return yaml.dump(entity_dict, default_flow_style=False, sort_keys=False)
