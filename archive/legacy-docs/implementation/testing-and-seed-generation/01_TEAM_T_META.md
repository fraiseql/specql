# Team T-Meta: Test Metadata Schema & Generation

**Status**: Planning Phase
**Timeline**: Week 2 (5 days)
**Priority**: Critical - Foundation for all testing infrastructure
**Team Size**: 1-2 developers

---

## üéØ Mission

**Generate and manage test metadata that drives automatic seed data and test generation from SpecQL definitions.**

Test metadata is the "control plane" for testing:
- Describes how to generate each field
- Defines test scenarios
- Configures UUID encoding
- Enables group leader pattern

---

## üìã Responsibilities

### Core
1. **Design `test_metadata` schema** - PostgreSQL tables for test configuration
2. **Generate test metadata from SpecQL AST** - Parse Entity ‚Üí Populate metadata
3. **Implement group leader pattern** - Related field dependencies
4. **Provide metadata query API** - Functions to retrieve test config

### Integration
- Consume: Team A's `Entity`, `FieldDefinition`, `Action` AST models
- Provide: Metadata for Team T-Seed, Team T-Test
- Coordinate: Team B for entity codes, Team C for function numbers

---

## üèóÔ∏è Architecture

```
SpecQL YAML
    ‚Üì
Team A: Parse ‚Üí AST (Entity, Fields, Actions)
    ‚Üì
Team T-Meta: AST ‚Üí Test Metadata
    ‚Üì
PostgreSQL: test_metadata schema
    ‚îú‚îÄ tb_entity_test_config
    ‚îú‚îÄ tb_field_generator_mapping
    ‚îú‚îÄ tb_test_scenarios
    ‚îî‚îÄ tb_group_leader_config
    ‚Üì
Query API Functions
    ‚îú‚îÄ test_meta_get_entity_config()
    ‚îú‚îÄ test_meta_get_field_generators()
    ‚îî‚îÄ test_meta_get_scenarios()
    ‚Üì
Team T-Seed: Generate seed data
Team T-Test: Generate tests
```

---

## üìä Data Model

### Table 1: `test_metadata.tb_entity_test_config`

**Purpose**: High-level configuration for each entity's testing

```sql
CREATE TABLE test_metadata.tb_entity_test_config (
    -- Primary key
    pk_entity_test_config INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,

    -- Entity identification
    entity_name TEXT NOT NULL UNIQUE,           -- "Contact"
    schema_name TEXT NOT NULL,                  -- "crm"
    table_name TEXT NOT NULL,                   -- "tb_contact"

    -- UUID encoding configuration
    table_code INTEGER NOT NULL,                -- 123210 (for UUID encoding)
    entity_code TEXT NOT NULL,                  -- "CON" (3-char abbreviation)
    base_uuid_prefix TEXT NOT NULL,             -- "012321" (6-digit prefix)

    -- Multi-tenancy
    is_tenant_scoped BOOLEAN DEFAULT TRUE,
    default_tenant_id UUID DEFAULT '22222222-2222-2222-2222-222222222222',
    default_user_id UUID DEFAULT '01232022-0000-0000-0000-000000000001',

    -- Seed data defaults
    default_seed_count INTEGER DEFAULT 10,
    seed_strategy TEXT DEFAULT 'realistic',     -- 'realistic', 'edge_cases', 'performance', 'minimal'

    -- Test generation flags
    enable_crud_tests BOOLEAN DEFAULT TRUE,
    enable_action_tests BOOLEAN DEFAULT TRUE,
    enable_constraint_tests BOOLEAN DEFAULT TRUE,
    enable_dedup_tests BOOLEAN DEFAULT FALSE,
    enable_fk_tests BOOLEAN DEFAULT TRUE,

    -- Metadata
    source_yaml_path TEXT,                      -- Path to SpecQL file
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),

    -- Indexes
    CONSTRAINT valid_seed_strategy CHECK (seed_strategy IN ('realistic', 'edge_cases', 'performance', 'minimal'))
);

CREATE INDEX idx_entity_test_config_entity_name ON test_metadata.tb_entity_test_config(entity_name);
CREATE INDEX idx_entity_test_config_schema ON test_metadata.tb_entity_test_config(schema_name);
```

**Example Row**:
```sql
INSERT INTO test_metadata.tb_entity_test_config
(entity_name, schema_name, table_name, table_code, entity_code, base_uuid_prefix, enable_dedup_tests)
VALUES
('Contact', 'crm', 'tb_contact', 123210, 'CON', '012321', TRUE);
```

---

### Table 2: `test_metadata.tb_field_generator_mapping`

**Purpose**: Describes how to generate value for each field

```sql
CREATE TABLE test_metadata.tb_field_generator_mapping (
    -- Primary key
    pk_field_gen INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,

    -- Foreign key to entity
    fk_entity_test_config INTEGER NOT NULL REFERENCES test_metadata.tb_entity_test_config(pk_entity_test_config),

    -- Field identification
    field_name TEXT NOT NULL,
    field_type TEXT NOT NULL,                   -- "text", "email", "ref(Company)", "enum(lead,qualified)"
    postgres_type TEXT NOT NULL,                -- "TEXT", "INTEGER", "NUMERIC(19,4)"

    -- Generator strategy
    generator_type TEXT NOT NULL,               -- 'random', 'fk_resolve', 'group_leader', 'group_dependent', 'fixed', 'sequence'
    generator_function TEXT,                    -- SQL function name: 'test_random_email'
    generator_params JSONB,                     -- Parameters for generator

    -- For FK resolution
    fk_target_entity TEXT,                      -- "Company"
    fk_target_schema TEXT,                      -- "crm"
    fk_target_table TEXT,                       -- "tb_company"
    fk_target_pk_field TEXT,                    -- "pk_company"
    fk_resolution_query TEXT,                   -- Custom query for FK lookup
    fk_filter_conditions TEXT,                  -- WHERE conditions for FK query
    fk_dependencies TEXT[],                     -- Other fields needed for FK resolution (e.g., ['tenant_id'])

    -- Group leader pattern
    generator_group TEXT,                       -- "address_group", "location_group"
    is_group_leader BOOLEAN DEFAULT FALSE,      -- This field executes the query
    group_leader_field TEXT,                    -- Name of group leader (if this is dependent)
    group_dependency_fields TEXT[],             -- Fields returned by group leader query

    -- Constraints & validation
    nullable BOOLEAN DEFAULT TRUE,
    unique_constraint BOOLEAN DEFAULT FALSE,
    validation_pattern TEXT,                    -- Regex for validation
    check_constraint TEXT,                      -- SQL CHECK expression

    -- Seed data hints
    example_values TEXT[],                      -- Example values for seed
    seed_distribution JSONB,                    -- Statistical distribution: {"min": 1, "max": 100, "mean": 50}
    enum_values TEXT[],                         -- For enum types

    -- Metadata
    priority_order INTEGER DEFAULT 100,         -- Generation order (lower = earlier)
    created_at TIMESTAMPTZ DEFAULT NOW(),

    -- Constraints
    UNIQUE (fk_entity_test_config, field_name),
    CONSTRAINT valid_generator_type CHECK (generator_type IN ('random', 'fk_resolve', 'group_leader', 'group_dependent', 'fixed', 'sequence'))
);

CREATE INDEX idx_field_gen_entity ON test_metadata.tb_field_generator_mapping(fk_entity_test_config);
CREATE INDEX idx_field_gen_type ON test_metadata.tb_field_generator_mapping(generator_type);
CREATE INDEX idx_field_gen_group ON test_metadata.tb_field_generator_mapping(generator_group) WHERE generator_group IS NOT NULL;
```

**Example Rows**:
```sql
-- Random field
INSERT INTO test_metadata.tb_field_generator_mapping
(fk_entity_test_config, field_name, field_type, postgres_type, generator_type, generator_function, priority_order)
VALUES
(1, 'email', 'email', 'TEXT', 'random', 'test_random_email', 10);

-- FK resolution
INSERT INTO test_metadata.tb_field_generator_mapping
(fk_entity_test_config, field_name, field_type, postgres_type, generator_type, fk_target_entity, fk_target_schema, fk_target_table, fk_target_pk_field, fk_dependencies, priority_order)
VALUES
(1, 'fk_company', 'ref(Company)', 'INTEGER', 'fk_resolve', 'Company', 'crm', 'tb_company', 'pk_company', ARRAY['tenant_id'], 20);

-- Group leader
INSERT INTO test_metadata.tb_field_generator_mapping
(fk_entity_test_config, field_name, field_type, postgres_type, generator_type, is_group_leader, generator_group, group_dependency_fields, generator_params, priority_order)
VALUES
(1, 'country_code', 'text', 'TEXT', 'group_leader', TRUE, 'address_group', ARRAY['country_code', 'postal_code', 'city_code'],
 '{"leader_query": "SELECT country_code, postal_code, city_code FROM dim.tb_address WHERE deleted_at IS NULL ORDER BY RANDOM() LIMIT 1"}'::JSONB, 15);

-- Group dependent
INSERT INTO test_metadata.tb_field_generator_mapping
(fk_entity_test_config, field_name, field_type, postgres_type, generator_type, generator_group, group_leader_field, priority_order)
VALUES
(1, 'postal_code', 'text', 'TEXT', 'group_dependent', 'address_group', 'country_code', 15),
(1, 'city_code', 'text', 'TEXT', 'group_dependent', 'address_group', 'country_code', 15);
```

---

### Table 3: `test_metadata.tb_test_scenarios`

**Purpose**: Define test scenarios for each entity

```sql
CREATE TABLE test_metadata.tb_test_scenarios (
    -- Primary key
    pk_scenario INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,

    -- Foreign key to entity
    fk_entity_test_config INTEGER NOT NULL REFERENCES test_metadata.tb_entity_test_config(pk_entity_test_config),

    -- Scenario identification
    scenario_code INTEGER NOT NULL,             -- 0, 1000, 2000, etc. (for UUID encoding)
    scenario_name TEXT NOT NULL,                -- "happy_path_create", "duplicate_email"
    scenario_type TEXT NOT NULL,                -- 'happy_path', 'constraint_violation', 'dedup', 'custom_action', 'fk_violation'

    -- Test generation
    test_function_name TEXT,                    -- "test_create_contact_duplicate_email"
    target_action TEXT,                         -- For action tests: "qualify_lead"
    input_overrides JSONB,                      -- Override default field values: {"email": "duplicate@example.com"}
    expected_result TEXT NOT NULL,              -- 'success', 'error'
    expected_error_code TEXT,                   -- 'duplicate_key_violation', 'fk_violation'
    expected_status_pattern TEXT,               -- Regex: 'failed:.*'

    -- Seed data
    seed_count INTEGER DEFAULT 1,
    requires_dependencies BOOLEAN DEFAULT TRUE, -- Need parent entities seeded?
    dependency_entities TEXT[],                 -- ["Company", "User"] - need these first

    -- Test execution
    setup_sql TEXT,                             -- SQL to run before test
    teardown_sql TEXT,                          -- SQL to run after test

    -- Metadata
    description TEXT,
    test_category TEXT,                         -- 'crud', 'action', 'constraint', 'performance'
    enabled BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMPTZ DEFAULT NOW(),

    -- Constraints
    UNIQUE (fk_entity_test_config, scenario_code),
    CONSTRAINT valid_scenario_type CHECK (scenario_type IN ('happy_path', 'constraint_violation', 'dedup', 'custom_action', 'fk_violation', 'performance')),
    CONSTRAINT valid_expected_result CHECK (expected_result IN ('success', 'error'))
);

CREATE INDEX idx_scenario_entity ON test_metadata.tb_test_scenarios(fk_entity_test_config);
CREATE INDEX idx_scenario_type ON test_metadata.tb_test_scenarios(scenario_type);
CREATE INDEX idx_scenario_enabled ON test_metadata.tb_test_scenarios(enabled) WHERE enabled = TRUE;
```

**Example Rows**:
```sql
-- Scenario 0: Happy path
INSERT INTO test_metadata.tb_test_scenarios
(fk_entity_test_config, scenario_code, scenario_name, scenario_type, expected_result, description)
VALUES
(1, 0, 'happy_path_create', 'happy_path', 'success', 'Standard contact creation');

-- Scenario 1000: Duplicate test
INSERT INTO test_metadata.tb_test_scenarios
(fk_entity_test_config, scenario_code, scenario_name, scenario_type, input_overrides, expected_result, expected_error_code, seed_count)
VALUES
(1, 1000, 'duplicate_email', 'dedup', '{"email": "duplicate@example.com"}'::JSONB, 'error', 'duplicate_key_violation', 2);

-- Scenario 2000: Custom action
INSERT INTO test_metadata.tb_test_scenarios
(fk_entity_test_config, scenario_code, scenario_name, scenario_type, target_action, expected_result, setup_sql)
VALUES
(1, 2000, 'qualify_lead_action', 'custom_action', 'qualify_lead', 'success',
 'INSERT INTO crm.tb_contact (id, tenant_id, email, status) VALUES (''01232022-0000-0000-2000-000000000001'', ''22222222-2222-2222-2222-222222222222'', ''qualify@example.com'', ''lead'')');
```

---

## üîß Implementation Phases

### **Phase 1: Schema Definition** (Day 1)

**Objective**: Create `test_metadata` schema in PostgreSQL

#### RED: Write Failing Test
```python
# tests/unit/testing/test_metadata_schema.py

def test_test_metadata_schema_exists(db_connection):
    """Test metadata schema should exist"""
    result = db_connection.execute(
        "SELECT schema_name FROM information_schema.schemata WHERE schema_name = 'test_metadata'"
    ).fetchone()
    assert result is not None

def test_entity_test_config_table_exists(db_connection):
    """Entity test config table should exist"""
    result = db_connection.execute(
        "SELECT table_name FROM information_schema.tables WHERE table_schema = 'test_metadata' AND table_name = 'tb_entity_test_config'"
    ).fetchone()
    assert result is not None
```

#### GREEN: Minimal Implementation
```sql
-- migrations/test_metadata_schema.sql

CREATE SCHEMA IF NOT EXISTS test_metadata;

CREATE TABLE test_metadata.tb_entity_test_config (
    pk_entity_test_config INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    entity_name TEXT NOT NULL UNIQUE,
    schema_name TEXT NOT NULL,
    table_name TEXT NOT NULL,
    table_code INTEGER NOT NULL,
    entity_code TEXT NOT NULL,
    base_uuid_prefix TEXT NOT NULL,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Similar for other tables...
```

#### REFACTOR: Add Full Schema
- Add all columns from data model above
- Add indexes
- Add constraints
- Add comments

#### QA: Verify
```bash
uv run pytest tests/unit/testing/test_metadata_schema.py -v
```

---

### **Phase 2: Metadata Generator from AST** (Day 2-3)

**Objective**: Convert SpecQL AST ‚Üí Test metadata SQL

#### RED: Write Failing Test
```python
# tests/unit/testing/test_metadata_generator.py

from src.core.ast_models import Entity, FieldDefinition
from src.testing.metadata.metadata_generator import TestMetadataGenerator

def test_generate_entity_config():
    """Should generate entity test config SQL"""
    entity = Entity(
        name="Contact",
        schema="crm",
        fields={}
    )

    generator = TestMetadataGenerator()
    sql = generator.generate_entity_config(entity, table_code=123210)

    assert "INSERT INTO test_metadata.tb_entity_test_config" in sql
    assert "'Contact'" in sql
    assert "'crm'" in sql
    assert "123210" in sql

def test_generate_field_mapping_for_email():
    """Should generate field mapping for email field"""
    field = FieldDefinition(
        name="email",
        type_name="email",
        nullable=False
    )

    generator = TestMetadataGenerator()
    sql = generator.generate_field_mapping(entity_config_id=1, field=field)

    assert "INSERT INTO test_metadata.tb_field_generator_mapping" in sql
    assert "'email'" in sql
    assert "'random'" in sql  # email fields use random generator
```

#### GREEN: Minimal Implementation
```python
# src/testing/metadata/metadata_generator.py

from typing import Dict, Any
from src.core.ast_models import Entity, FieldDefinition, Action

class TestMetadataGenerator:
    """Generate test metadata SQL from SpecQL AST"""

    def generate_entity_config(self, entity: Entity, table_code: int) -> str:
        """Generate entity test config INSERT statement"""

        entity_code = self._derive_entity_code(entity.name)
        base_uuid_prefix = str(table_code).zfill(6)

        return f"""
INSERT INTO test_metadata.tb_entity_test_config
(entity_name, schema_name, table_name, table_code, entity_code, base_uuid_prefix)
VALUES
('{entity.name}', '{entity.schema}', 'tb_{entity.name.lower()}', {table_code}, '{entity_code}', '{base_uuid_prefix}');
"""

    def generate_field_mapping(self, entity_config_id: int, field: FieldDefinition) -> str:
        """Generate field generator mapping INSERT statement"""

        generator_type = self._infer_generator_type(field)
        generator_function = self._get_generator_function(field)

        return f"""
INSERT INTO test_metadata.tb_field_generator_mapping
(fk_entity_test_config, field_name, field_type, postgres_type, generator_type, generator_function)
VALUES
({entity_config_id}, '{field.name}', '{field.type_name}', '{field.postgres_type}', '{generator_type}', '{generator_function}');
"""

    def _derive_entity_code(self, entity_name: str) -> str:
        """Derive 3-char entity code from name"""
        # Simple: take first 3 uppercase letters
        code = ''.join([c for c in entity_name if c.isupper()])[:3]
        if len(code) < 3:
            code = entity_name[:3].upper()
        return code

    def _infer_generator_type(self, field: FieldDefinition) -> str:
        """Infer generator type from field type"""
        if field.type_name.startswith('ref('):
            return 'fk_resolve'
        else:
            return 'random'

    def _get_generator_function(self, field: FieldDefinition) -> str:
        """Get SQL function name for random generation"""
        # Map field types to generator functions
        GENERATOR_MAP = {
            'email': 'test_random_email',
            'phoneNumber': 'test_random_phone',
            'url': 'test_random_url',
            'text': 'test_random_text',
            'integer': 'test_random_integer',
        }
        return GENERATOR_MAP.get(field.type_name, 'test_random_value')
```

#### REFACTOR: Complete Implementation
- Handle all field types (enums, composites, lists)
- Handle FK resolution with dependencies
- Detect group leader candidates (address, location fields)
- Generate default test scenarios
- Add proper error handling
- Use parameterized queries (avoid SQL injection)

#### QA: Verify
```bash
uv run pytest tests/unit/testing/test_metadata_generator.py -v
```

---

### **Phase 3: Group Leader Pattern** (Day 4)

**Objective**: Implement group leader detection and configuration

#### RED: Write Failing Test
```python
def test_detect_address_group_leader():
    """Should detect address fields as group leader"""
    entity = Entity(
        name="Contact",
        schema="crm",
        fields={
            "country_code": FieldDefinition(name="country_code", type_name="text"),
            "postal_code": FieldDefinition(name="postal_code", type_name="text"),
            "city_code": FieldDefinition(name="city_code", type_name="text"),
        }
    )

    detector = GroupLeaderDetector()
    groups = detector.detect_groups(entity)

    assert 'address_group' in groups
    assert groups['address_group']['leader'] == 'country_code'
    assert set(groups['address_group']['dependents']) == {'postal_code', 'city_code'}
```

#### GREEN: Minimal Implementation
```python
# src/testing/metadata/group_leader_detector.py

from typing import Dict, List, Set
from src.core.ast_models import Entity

class GroupLeaderDetector:
    """Detect field groups that should use group leader pattern"""

    # Known field group patterns
    ADDRESS_FIELDS = {'country_code', 'postal_code', 'city_code', 'country', 'postal', 'city'}
    LOCATION_FIELDS = {'latitude', 'longitude', 'elevation'}
    PERSON_FIELDS = {'first_name', 'last_name', 'gender', 'birth_date'}

    def detect_groups(self, entity: Entity) -> Dict[str, Dict[str, any]]:
        """Detect field groups in entity"""
        groups = {}

        # Detect address group
        address_fields = set(entity.fields.keys()) & self.ADDRESS_FIELDS
        if len(address_fields) >= 2:
            leader = self._pick_leader(address_fields, ['country_code', 'country'])
            groups['address_group'] = {
                'leader': leader,
                'dependents': [f for f in address_fields if f != leader],
                'query_template': self._get_address_query_template()
            }

        # Detect location group
        location_fields = set(entity.fields.keys()) & self.LOCATION_FIELDS
        if len(location_fields) >= 2:
            groups['location_group'] = {
                'leader': 'latitude',
                'dependents': [f for f in location_fields if f != 'latitude'],
                'query_template': self._get_location_query_template()
            }

        return groups

    def _pick_leader(self, fields: Set[str], priority: List[str]) -> str:
        """Pick group leader based on priority"""
        for candidate in priority:
            if candidate in fields:
                return candidate
        return list(fields)[0]

    def _get_address_query_template(self) -> str:
        """Get SQL query template for address group"""
        return "SELECT country_code, postal_code, city_code FROM dim.tb_address WHERE deleted_at IS NULL ORDER BY RANDOM() LIMIT 1"
```

#### REFACTOR: Enhanced Detection
- Support custom group definitions in SpecQL YAML
- Support multiple groups per entity
- Generate optimized queries
- Handle missing dependency tables gracefully

#### QA: Verify
```bash
uv run pytest tests/unit/testing/test_group_leader_detector.py -v
```

---

### **Phase 4: Metadata Query API** (Day 5)

**Objective**: Create SQL functions to query test metadata

#### RED: Write Failing Test
```python
def test_get_entity_config(db_connection):
    """Should retrieve entity config by name"""
    result = db_connection.execute(
        "SELECT test_metadata.get_entity_config('Contact')"
    ).fetchone()

    assert result is not None
    config = result[0]  # Returns JSONB
    assert config['entity_name'] == 'Contact'
    assert config['schema_name'] == 'crm'
```

#### GREEN: Minimal Implementation
```sql
-- migrations/test_metadata_functions.sql

CREATE OR REPLACE FUNCTION test_metadata.get_entity_config(p_entity_name TEXT)
RETURNS JSONB AS $$
BEGIN
    RETURN (
        SELECT jsonb_build_object(
            'entity_name', entity_name,
            'schema_name', schema_name,
            'table_name', table_name,
            'table_code', table_code,
            'entity_code', entity_code,
            'base_uuid_prefix', base_uuid_prefix,
            'default_tenant_id', default_tenant_id,
            'default_seed_count', default_seed_count
        )
        FROM test_metadata.tb_entity_test_config
        WHERE entity_name = p_entity_name
    );
END;
$$ LANGUAGE plpgsql STABLE;

CREATE OR REPLACE FUNCTION test_metadata.get_field_generators(p_entity_name TEXT)
RETURNS TABLE (
    field_name TEXT,
    field_type TEXT,
    generator_type TEXT,
    generator_function TEXT,
    generator_params JSONB,
    fk_target_entity TEXT,
    is_group_leader BOOLEAN,
    generator_group TEXT
) AS $$
BEGIN
    RETURN QUERY
    SELECT
        fg.field_name,
        fg.field_type,
        fg.generator_type,
        fg.generator_function,
        fg.generator_params,
        fg.fk_target_entity,
        fg.is_group_leader,
        fg.generator_group
    FROM test_metadata.tb_field_generator_mapping fg
    JOIN test_metadata.tb_entity_test_config ec ON ec.pk_entity_test_config = fg.fk_entity_test_config
    WHERE ec.entity_name = p_entity_name
    ORDER BY fg.priority_order, fg.field_name;
END;
$$ LANGUAGE plpgsql STABLE;

CREATE OR REPLACE FUNCTION test_metadata.get_scenarios(p_entity_name TEXT)
RETURNS TABLE (
    scenario_code INTEGER,
    scenario_name TEXT,
    scenario_type TEXT,
    expected_result TEXT,
    input_overrides JSONB
) AS $$
BEGIN
    RETURN QUERY
    SELECT
        s.scenario_code,
        s.scenario_name,
        s.scenario_type,
        s.expected_result,
        s.input_overrides
    FROM test_metadata.tb_test_scenarios s
    JOIN test_metadata.tb_entity_test_config ec ON ec.pk_entity_test_config = s.fk_entity_test_config
    WHERE ec.entity_name = p_entity_name
      AND s.enabled = TRUE
    ORDER BY s.scenario_code;
END;
$$ LANGUAGE plpgsql STABLE;
```

#### REFACTOR: Add More Queries
- `get_group_leader_config(entity_name, group_name)`
- `get_fk_dependencies(entity_name, field_name)`
- `get_test_scenarios_by_type(entity_name, scenario_type)`

#### QA: Verify
```bash
uv run pytest tests/integration/testing/test_metadata_api.py -v
```

---

## üß™ Testing Strategy

### Unit Tests
```python
# tests/unit/testing/

test_metadata_generator.py         # AST ‚Üí SQL generation
test_group_leader_detector.py      # Group detection logic
test_entity_code_derivation.py     # Entity code generation
```

### Integration Tests
```python
# tests/integration/testing/

test_metadata_schema.py             # Schema creation
test_metadata_population.py         # Full Contact ‚Üí metadata
test_metadata_query_api.py          # Query functions work
```

### Test Coverage Target
- **Unit tests**: 95%+
- **Integration tests**: 100% of public API

---

## üìä Success Criteria

### Week 2 Completion
- ‚úÖ `test_metadata` schema created in PostgreSQL
- ‚úÖ All 3 tables (entity_config, field_mapping, scenarios) created
- ‚úÖ TestMetadataGenerator generates SQL from AST
- ‚úÖ Group leader detection works for address/location
- ‚úÖ Metadata query API functions work
- ‚úÖ Full Contact entity example in metadata
- ‚úÖ 15+ unit tests passing
- ‚úÖ 5+ integration tests passing

---

## üîó Integration Points

### Consumes (Inputs)
- **Team A**: `Entity`, `FieldDefinition`, `Action` AST models
- **SpecQL YAML**: Entity definitions with optional test hints

### Provides (Outputs)
- **Team T-Seed**: Entity config, field generators, scenarios
- **Team T-Test**: Test scenarios, expected results
- **PostgreSQL**: `test_metadata` schema populated

### Coordinates With
- **Team B**: Table codes for UUID encoding
- **Team C**: Function numbers for UUID encoding
- **Team E**: CLI integration for metadata generation

---

## üìù Example Output

For `contact.yaml`:

```sql
-- Generated test metadata

-- Entity config
INSERT INTO test_metadata.tb_entity_test_config VALUES
(1, 'Contact', 'crm', 'tb_contact', 123210, 'CON', '012321', TRUE, '22222222-2222-2222-2222-222222222222', 10, 'realistic', TRUE, TRUE, TRUE, TRUE, TRUE, 'entities/contact.yaml', NOW(), NOW());

-- Field generators
INSERT INTO test_metadata.tb_field_generator_mapping VALUES
(1, 1, 'email', 'email', 'TEXT', 'random', 'test_random_email', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, FALSE, NULL, NULL, TRUE, TRUE, NULL, NULL, NULL, NULL, 10, NOW()),
(2, 1, 'fk_company', 'ref(Company)', 'INTEGER', 'fk_resolve', NULL, NULL, 'Company', 'crm', 'tb_company', 'pk_company', 'SELECT pk_company FROM crm.tb_company WHERE tenant_id = $tenant_id ORDER BY RANDOM() LIMIT 1', NULL, ARRAY['tenant_id'], NULL, FALSE, NULL, NULL, FALSE, FALSE, NULL, NULL, NULL, NULL, 20, NOW());

-- Scenarios
INSERT INTO test_metadata.tb_test_scenarios VALUES
(1, 1, 0, 'happy_path_create', 'happy_path', 'test_create_contact_happy_path', NULL, NULL, 'success', NULL, NULL, 1, TRUE, NULL, NULL, NULL, 'Standard contact creation', 'crud', TRUE, NOW()),
(2, 1, 1000, 'duplicate_email', 'dedup', 'test_create_contact_duplicate', NULL, '{"email": "duplicate@example.com"}'::JSONB, 'error', 'duplicate_key_violation', 'failed:.*', 2, TRUE, NULL, NULL, NULL, 'Duplicate email constraint test', 'constraint', TRUE, NOW());
```

---

**Next**: [Team T-Seed: Seed Data Generation](02_TEAM_T_SEED.md)
