-- ============================================
-- PostgreSQL Schema for Confiture
-- ============================================
--
-- Environment: test
-- Generated: 2025-11-09T17:42:25.814283
-- Schema Hash: 770dbd8249340f7a278bccc3f1ddce2e4dd8e723207c9210dd526951b7bdf0cf
-- Files Included: 11
--
-- This file was generated by Confiture (confiture build)
-- DO NOT EDIT MANUALLY - Edit source files in db/schema/
--
-- ============================================


-- ============================================
-- File: 00_foundation/000_app_foundation.sql
-- ============================================

-- Create app schema
CREATE SCHEMA IF NOT EXISTS app;


-- ============================================================================
-- MUTATION RESULT TYPE
-- Standard output type for all mutations
-- ============================================================================
CREATE TYPE app.mutation_result AS (
    id UUID,
    updated_fields TEXT[],
    status TEXT,
    message TEXT,
    object_data JSONB,
    extra_metadata JSONB
);

COMMENT ON TYPE app.mutation_result IS
'Standard mutation result for all operations.
Returns entity data, status, and optional metadata.

@fraiseql:composite
name: MutationResult
tier: 1
storage: composite';

COMMENT ON COLUMN app.mutation_result.id IS
'Unique identifier of the affected entity.

@fraiseql:field
name: id
type: UUID!
required: true';

COMMENT ON COLUMN app.mutation_result.updated_fields IS
'Fields that were modified in this mutation.

@fraiseql:field
name: updatedFields
type: [String]
required: false';

COMMENT ON COLUMN app.mutation_result.status IS
'Operation status indicator.
Values: success, failed:error_code

@fraiseql:field
name: status
type: String!
required: true';

COMMENT ON COLUMN app.mutation_result.message IS
'Human-readable success or error message.

@fraiseql:field
name: message
type: String
required: false';

COMMENT ON COLUMN app.mutation_result.object_data IS
'Complete entity data after mutation.

@fraiseql:field
name: object
type: JSON
required: false';

COMMENT ON COLUMN app.mutation_result.extra_metadata IS
'Additional metadata including side effects and impact information.

@fraiseql:field
name: extra
type: JSON
required: false';

-- ============================================================================
-- AUDIT LOG TABLE: app.tb_mutation_audit_log
-- Comprehensive audit trail for all mutations across the application
-- ============================================================================
CREATE TABLE app.tb_mutation_audit_log (
    -- Primary key
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),

    -- Multi-tenancy
    tenant_id UUID NOT NULL,

    -- User context
    user_id UUID,

    -- Entity context
    entity_type TEXT NOT NULL,
    entity_id UUID NOT NULL,

    -- Operation details
    operation TEXT NOT NULL,  -- 'INSERT', 'UPDATE', 'DELETE', 'NOOP'
    status TEXT NOT NULL,     -- 'success', 'failed:*'

    -- Data changes
    updated_fields TEXT[],
    message TEXT,
    object_data JSONB,

    -- Additional context
    extra_metadata JSONB,
    error_context JSONB,

    -- Timestamps
    created_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

-- Indexes for performance
CREATE INDEX idx_mutation_audit_tenant ON app.tb_mutation_audit_log(tenant_id);
CREATE INDEX idx_mutation_audit_entity ON app.tb_mutation_audit_log(entity_type, entity_id);
CREATE INDEX idx_mutation_audit_created ON app.tb_mutation_audit_log(created_at);

-- Comments
COMMENT ON TABLE app.tb_mutation_audit_log IS 'Comprehensive audit trail for all mutations across the application';
COMMENT ON COLUMN app.tb_mutation_audit_log.id IS 'Unique identifier for this audit log entry';
COMMENT ON COLUMN app.tb_mutation_audit_log.tenant_id IS 'Tenant that performed the operation';
COMMENT ON COLUMN app.tb_mutation_audit_log.user_id IS 'User who performed the operation';
COMMENT ON COLUMN app.tb_mutation_audit_log.entity_type IS 'Type of entity being mutated (e.g., contact, company)';
COMMENT ON COLUMN app.tb_mutation_audit_log.entity_id IS 'ID of the entity being mutated';
COMMENT ON COLUMN app.tb_mutation_audit_log.operation IS 'Type of operation: INSERT, UPDATE, DELETE, NOOP';
COMMENT ON COLUMN app.tb_mutation_audit_log.status IS 'Operation status: success or failed:*';
COMMENT ON COLUMN app.tb_mutation_audit_log.updated_fields IS 'Array of field names that were modified';
COMMENT ON COLUMN app.tb_mutation_audit_log.message IS 'Human-readable success or error message';
COMMENT ON COLUMN app.tb_mutation_audit_log.object_data IS 'Complete entity data after the mutation';
COMMENT ON COLUMN app.tb_mutation_audit_log.extra_metadata IS 'Additional metadata including side effects';
COMMENT ON COLUMN app.tb_mutation_audit_log.error_context IS 'Error context information for debugging';
COMMENT ON COLUMN app.tb_mutation_audit_log.created_at IS 'Timestamp when the audit log entry was created';

-- ============================================================================
-- SHARED UTILITY: app.log_and_return_mutation
-- Used by ALL business schemas for standardized mutation responses with audit logging
-- ============================================================================
CREATE OR REPLACE FUNCTION app.log_and_return_mutation(
    p_tenant_id UUID,
    p_user_id UUID,
    p_entity TEXT,
    p_entity_id UUID,
    p_operation TEXT,          -- 'INSERT', 'UPDATE', 'DELETE', 'NOOP'
    p_status TEXT,             -- 'success', 'failed:*'
    p_updated_fields TEXT[],
    p_message TEXT,
    p_object_data JSONB,
    p_extra_metadata JSONB DEFAULT NULL,
    p_error_context JSONB DEFAULT NULL
) RETURNS app.mutation_result
LANGUAGE plpgsql
AS $$
DECLARE
    v_audit_id UUID := gen_random_uuid();
BEGIN
    -- Insert audit log record
    INSERT INTO app.tb_mutation_audit_log (
        id,
        tenant_id,
        user_id,
        entity_type,
        entity_id,
        operation,
        status,
        updated_fields,
        message,
        object_data,
        extra_metadata,
        error_context,
        created_at
    ) VALUES (
        v_audit_id,
        p_tenant_id,
        p_user_id,
        p_entity,
        p_entity_id,
        p_operation,
        p_status,
        p_updated_fields,
        p_message,
        p_object_data,
        p_extra_metadata,
        p_error_context,
        now()
    );

    -- Return standardized mutation result
    RETURN ROW(
        p_entity_id,
        p_updated_fields,
        p_status,
        p_message,
        p_object_data,
        p_extra_metadata
    )::app.mutation_result;
END;
$$;

COMMENT ON FUNCTION app.log_and_return_mutation IS
  'Audit logger and standardized mutation result builder for all app/core functions';

-- ============================================
-- File: 10_tables/contact.sql
-- ============================================

-- ============================================================================
-- Table: crm.tb_contact
-- ============================================================================
-- [Table: CON | Customer contact information]
-- ============================================================================

CREATE TABLE crm.tb_contact (
    -- ========================================================================
    -- Trinity Pattern: INTEGER primary key for performance
    -- ========================================================================
    pk_contact INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,

    -- ========================================================================
    -- Trinity Pattern: UUID for stable public API
    -- ========================================================================
    id UUID DEFAULT gen_random_uuid() NOT NULL,
    -- ========================================================================
    -- Multi-Tenancy: Denormalized from JWT (CRITICAL for security)
    -- ========================================================================
    tenant_id UUID NOT NULL,

    -- ========================================================================
    -- Multi-Tenancy: Optional business FK to organization
    -- ========================================================================
    -- Note: Only add fk_organization if entity belongs to specific org unit
    -- (not just tenant isolation). Comment out if not needed.
    -- fk_organization INTEGER,
    -- ========================================================================
    -- Business Fields
    -- ========================================================================
    email TEXT,
    first_name TEXT,
    last_name TEXT,
    status TEXT,
    phone TEXT,
    -- ========================================================================
    -- Foreign Keys (Trinity Pattern: INTEGER references)
    -- ========================================================================    fk_company INTEGER,
    -- ========================================================================
    -- Audit Fields (Trinity Pattern standard)
    -- ========================================================================
    created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
    created_by UUID,
    updated_at TIMESTAMPTZ NOT NULL DEFAULT now(),
    updated_by UUID,
    deleted_at TIMESTAMPTZ,
    deleted_by UUID,

    -- ========================================================================
    -- Constraints
    -- ========================================================================
    CONSTRAINT tb_contact_id_key UNIQUE (id)
    ,CONSTRAINT chk_tb_contact_status_enum CHECK (status IN ('lead', 'qualified', 'customer')));

-- ============================================================================
-- Foreign Key Constraints (defined after table creation)
-- ============================================================================
ALTER TABLE ONLY crm.tb_contact
    ADD CONSTRAINT tb_contact_fk_company_fkey
    FOREIGN KEY (fk_company) REFERENCES crm.tb_company(pk_company);-- ============================================================================
-- Multi-Tenancy Indexes (CRITICAL for performance & RLS)
-- ============================================================================
CREATE INDEX idx_tb_contact_tenant ON crm.tb_contact(tenant_id);
-- ============================================================================
-- Documentation
-- ============================================================================
COMMENT ON TABLE crm.tb_contact IS
'Customer contact information.

@fraiseql:type
trinity: true';

-- Trinity Pattern columns
COMMENT ON COLUMN crm.tb_contact.pk_contact IS 'Internal INTEGER primary key used in joins and foreign keys.';
COMMENT ON COLUMN crm.tb_contact.id IS
'Public UUID identifier for external APIs and GraphQL.

@fraiseql:field
name: id
type: UUID!
required: true';
-- Multi-Tenancy columns
COMMENT ON COLUMN crm.tb_contact.tenant_id IS 'Denormalized tenant identifier from JWT token (security context).';
-- COMMENT ON COLUMN crm.tb_contact.fk_organization IS 'Optional business FK to organization unit (uncomment if needed).';
-- Business field columns (comments handled by CommentGenerator)

-- Foreign key columns (comments handled by CommentGenerator)

-- Audit field columns
COMMENT ON COLUMN crm.tb_contact.created_at IS 'Timestamp when the record was created.';
COMMENT ON COLUMN crm.tb_contact.created_by IS 'User or system who created the record.';
COMMENT ON COLUMN crm.tb_contact.updated_at IS 'Timestamp when the record was last updated.';
COMMENT ON COLUMN crm.tb_contact.updated_by IS 'User or system who last updated the record.';
COMMENT ON COLUMN crm.tb_contact.deleted_at IS 'Timestamp of soft deletion.';
COMMENT ON COLUMN crm.tb_contact.deleted_by IS 'User or system who deleted the record.';

-- ============================================
-- File: 10_tables/task.sql
-- ============================================

-- ============================================================================
-- Table: crm.tb_task
-- ============================================================================
-- [Table: TAS | Task entity for CRM]
-- ============================================================================

CREATE TABLE crm.tb_task (
    -- ========================================================================
    -- Trinity Pattern: INTEGER primary key for performance
    -- ========================================================================
    pk_task INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,

    -- ========================================================================
    -- Trinity Pattern: UUID for stable public API
    -- ========================================================================
    id UUID DEFAULT gen_random_uuid() NOT NULL,
    -- ========================================================================
    -- Multi-Tenancy: Denormalized from JWT (CRITICAL for security)
    -- ========================================================================
    tenant_id UUID NOT NULL,

    -- ========================================================================
    -- Multi-Tenancy: Optional business FK to organization
    -- ========================================================================
    -- Note: Only add fk_organization if entity belongs to specific org unit
    -- (not just tenant isolation). Comment out if not needed.
    -- fk_organization INTEGER,
    -- ========================================================================
    -- Business Fields
    -- ========================================================================
    title TEXT,
    description TEXT,
    priority TEXT,
    -- ========================================================================
    -- Foreign Keys (Trinity Pattern: INTEGER references)
    -- ========================================================================
    -- ========================================================================
    -- Audit Fields (Trinity Pattern standard)
    -- ========================================================================
    created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
    created_by UUID,
    updated_at TIMESTAMPTZ NOT NULL DEFAULT now(),
    updated_by UUID,
    deleted_at TIMESTAMPTZ,
    deleted_by UUID,

    -- ========================================================================
    -- Constraints
    -- ========================================================================
    CONSTRAINT tb_task_id_key UNIQUE (id)
    ,CONSTRAINT chk_tb_task_priority_enum CHECK (priority IN ('low', 'medium', 'high')));

-- ============================================================================
-- Foreign Key Constraints (defined after table creation)
-- ============================================================================-- ============================================================================
-- Multi-Tenancy Indexes (CRITICAL for performance & RLS)
-- ============================================================================
CREATE INDEX idx_tb_task_tenant ON crm.tb_task(tenant_id);
-- ============================================================================
-- Documentation
-- ============================================================================
COMMENT ON TABLE crm.tb_task IS
'Task entity for CRM.

@fraiseql:type
trinity: true';

-- Trinity Pattern columns
COMMENT ON COLUMN crm.tb_task.pk_task IS 'Internal INTEGER primary key used in joins and foreign keys.';
COMMENT ON COLUMN crm.tb_task.id IS
'Public UUID identifier for external APIs and GraphQL.

@fraiseql:field
name: id
type: UUID!
required: true';
-- Multi-Tenancy columns
COMMENT ON COLUMN crm.tb_task.tenant_id IS 'Denormalized tenant identifier from JWT token (security context).';
-- COMMENT ON COLUMN crm.tb_task.fk_organization IS 'Optional business FK to organization unit (uncomment if needed).';
-- Business field columns (comments handled by CommentGenerator)

-- Foreign key columns (comments handled by CommentGenerator)

-- Audit field columns
COMMENT ON COLUMN crm.tb_task.created_at IS 'Timestamp when the record was created.';
COMMENT ON COLUMN crm.tb_task.created_by IS 'User or system who created the record.';
COMMENT ON COLUMN crm.tb_task.updated_at IS 'Timestamp when the record was last updated.';
COMMENT ON COLUMN crm.tb_task.updated_by IS 'User or system who last updated the record.';
COMMENT ON COLUMN crm.tb_task.deleted_at IS 'Timestamp of soft deletion.';
COMMENT ON COLUMN crm.tb_task.deleted_by IS 'User or system who deleted the record.';

-- ============================================
-- File: 10_tables/test.sql
-- ============================================

CREATE TABLE test_table (id INTEGER);

-- ============================================
-- File: 20_helpers/contact_helpers.sql
-- ============================================




-- ============================================================================
-- Trinity Helper: crm.contact_pk()
-- ============================================================================
-- Converts between UUID and INTEGER representations
-- ============================================================================

-- UUID/identifier/text → INTEGER (pk)
CREATE OR REPLACE FUNCTION crm.contact_pk(p_identifier TEXT, p_tenant_id UUID)
RETURNS INTEGER
LANGUAGE sql STABLE
AS $$
    SELECT pk_contact
    FROM crm.tb_contact
    WHERE (id::TEXT = p_identifier
        OR pk_contact::TEXT = p_identifier)
      AND tenant_id = p_tenant_id
    LIMIT 1;
$$;

COMMENT ON FUNCTION crm.contact_pk(TEXT, UUID) IS
'Trinity Pattern: Resolve entity identifier to internal INTEGER primary key.
Accepts UUID, text identifier, or integer pk and returns pk_contact.';




-- ============================================================================
-- Trinity Helper: crm.contact_id()
-- ============================================================================
-- Converts between UUID and INTEGER representations
-- ============================================================================

-- INTEGER (pk) → UUID
CREATE OR REPLACE FUNCTION crm.contact_id(p_pk INTEGER)
RETURNS UUID
LANGUAGE sql STABLE
AS $$
    SELECT id FROM crm.tb_contact
    WHERE pk_contact = p_pk;
$$;

COMMENT ON FUNCTION crm.contact_id(INTEGER) IS
'Trinity Pattern: Convert internal INTEGER primary key to external UUID identifier.';

-- ============================================
-- File: 20_helpers/task_helpers.sql
-- ============================================




-- ============================================================================
-- Trinity Helper: crm.task_pk()
-- ============================================================================
-- Converts between UUID and INTEGER representations
-- ============================================================================

-- UUID/identifier/text → INTEGER (pk)
CREATE OR REPLACE FUNCTION crm.task_pk(p_identifier TEXT, p_tenant_id UUID)
RETURNS INTEGER
LANGUAGE sql STABLE
AS $$
    SELECT pk_task
    FROM crm.tb_task
    WHERE (id::TEXT = p_identifier
        OR pk_task::TEXT = p_identifier)
      AND tenant_id = p_tenant_id
    LIMIT 1;
$$;

COMMENT ON FUNCTION crm.task_pk(TEXT, UUID) IS
'Trinity Pattern: Resolve entity identifier to internal INTEGER primary key.
Accepts UUID, text identifier, or integer pk and returns pk_task.';




-- ============================================================================
-- Trinity Helper: crm.task_id()
-- ============================================================================
-- Converts between UUID and INTEGER representations
-- ============================================================================

-- INTEGER (pk) → UUID
CREATE OR REPLACE FUNCTION crm.task_id(p_pk INTEGER)
RETURNS UUID
LANGUAGE sql STABLE
AS $$
    SELECT id FROM crm.tb_task
    WHERE pk_task = p_pk;
$$;

COMMENT ON FUNCTION crm.task_id(INTEGER) IS
'Trinity Pattern: Convert internal INTEGER primary key to external UUID identifier.';

-- ============================================
-- File: 30_functions/contact.sql
-- ============================================

-- Core Logic Functions
-- ============================================================================
-- CORE LOGIC: crm.qualify_lead
-- Custom Business Action
-- ============================================================================
CREATE OR REPLACE FUNCTION crm.qualify_lead(
    auth_tenant_id UUID,
    input_data app.type_qualify_lead_input,
    input_payload JSONB,
    auth_user_id UUID
) RETURNS app.mutation_result
LANGUAGE plpgsql
AS $$
DECLARE
    v_contact_id UUID := input_data.id;
    v_contact_pk INTEGER;
    v_current_status TEXT;
    v_fk_company INTEGER;
BEGIN
    -- Debug: Input parameters
    RAISE NOTICE 'qualify_lead: input_data.id=%, auth_tenant_id=%', input_data.id, auth_tenant_id;
    -- Fetch current values for validation: status = 'lead'
    RAISE NOTICE 'Before SELECT: v_contact_id=%, auth_tenant_id=%', v_contact_id, auth_tenant_id;
    SELECT status INTO v_current_status
    FROM crm.tb_contact WHERE id = v_contact_id AND tenant_id = auth_tenant_id;
    RAISE NOTICE 'After SELECT: v_current_status=%', v_current_status;
    -- Validate: status = 'lead'
    RAISE NOTICE 'Before validation: v_current_status=%', v_current_status;
    IF NOT (v_current_status = 'lead') THEN
        RETURN app.log_and_return_mutation(
            auth_tenant_id, auth_user_id, 'contact', v_contact_id,
            'CUSTOM', 'failed:validation_error',
            ARRAY[]::TEXT[], 'not_a_lead', NULL, NULL
        );
    END IF;
    -- Update Contact
    UPDATE crm.tb_contact SET status = 'qualified', updated_at = now(), updated_by = auth_user_id
    WHERE id = v_contact_id;

    -- === SUCCESS RESPONSE ===
    RETURN app.log_and_return_mutation(
        auth_tenant_id,
        auth_user_id,
        'contact',
        v_contact_id,
        'CUSTOM',
        'success',
        ARRAY[]::TEXT[],
        'Qualify Lead completed',
        (SELECT row_to_json(t.*) FROM crm.tb_contact t WHERE t.id = v_contact_id)::JSONB,
        NULL
    );
END;
$$;

-- ============================================================================
-- CORE LOGIC: crm.create_contact
-- Business Rules & Data Manipulation
-- ============================================================================
CREATE OR REPLACE FUNCTION crm.create_contact(
    auth_tenant_id UUID,
    input_data app.type_create_contact_input,
    input_payload JSONB,
    auth_user_id UUID
) RETURNS app.mutation_result
LANGUAGE plpgsql
AS $$
DECLARE
    v_contact_id UUID := gen_random_uuid();
    v_contact_pk INTEGER;
    v_fk_company INTEGER;
BEGIN
    -- === VALIDATION ===

    -- === UUID → INTEGER RESOLUTION (Trinity Helpers) ===
    IF input_data.company_id IS NOT NULL THEN
        v_fk_company := crm.company_pk(input_data.company_id::TEXT, auth_tenant_id);

        IF v_fk_company IS NULL THEN
            RETURN app.log_and_return_mutation(
                auth_tenant_id,
                auth_user_id,
                'contact',
                '00000000-0000-0000-0000-000000000000'::UUID,
                'NOOP',
                 'validation:reference_not_found',
                ARRAY['company_id']::TEXT[],
                 'Referenced company not found',
                NULL, NULL,
                jsonb_build_object('company_id', input_data.company_id)
            );
        END IF;
    END IF;

    -- === BUSINESS LOGIC: INSERT ===
    INSERT INTO crm.tb_contact (
        id,
        tenant_id,
        email,
        first_name,
        last_name,
        fk_company,
        status,
        phone,
        created_at,
        created_by
    ) VALUES (
        v_contact_id,
        auth_tenant_id,
        input_data.email,
        input_data.first_name,
        input_data.last_name,
        v_fk_company,
        input_data.status,
        input_data.phone,
        now(),
        auth_user_id
    )
    RETURNING pk_contact INTO v_contact_pk;

    -- === AUDIT & RETURN ===
    RETURN app.log_and_return_mutation(
        auth_tenant_id,
        auth_user_id,
        'contact',
        v_contact_id,
        'INSERT',
        'success',
        ARRAY(SELECT jsonb_object_keys(input_payload)),
        'Contact created successfully',
        (SELECT row_to_json(t.*) FROM crm.tb_contact t WHERE t.id = v_contact_id)::JSONB,
        NULL
    );
END;
$$;

-- Trinity Helper Functions



-- ============================================================================
-- Trinity Helper: crm.contact_pk()
-- ============================================================================
-- Converts between UUID and INTEGER representations
-- ============================================================================

-- UUID/identifier/text → INTEGER (pk)
CREATE OR REPLACE FUNCTION crm.contact_pk(p_identifier TEXT, p_tenant_id UUID)
RETURNS INTEGER
LANGUAGE sql STABLE
AS $$
    SELECT pk_contact
    FROM crm.tb_contact
    WHERE (id::TEXT = p_identifier
        OR pk_contact::TEXT = p_identifier)
      AND tenant_id = p_tenant_id
    LIMIT 1;
$$;

COMMENT ON FUNCTION crm.contact_pk(TEXT, UUID) IS
'Trinity Pattern: Resolve entity identifier to internal INTEGER primary key.
Accepts UUID, text identifier, or integer pk and returns pk_contact.';




-- ============================================================================
-- Trinity Helper: crm.contact_id()
-- ============================================================================
-- Converts between UUID and INTEGER representations
-- ============================================================================

-- INTEGER (pk) → UUID
CREATE OR REPLACE FUNCTION crm.contact_id(p_pk INTEGER)
RETURNS UUID
LANGUAGE sql STABLE
AS $$
    SELECT id FROM crm.tb_contact
    WHERE pk_contact = p_pk;
$$;

COMMENT ON FUNCTION crm.contact_id(INTEGER) IS
'Trinity Pattern: Convert internal INTEGER primary key to external UUID identifier.';

-- ============================================
-- File: 30_functions/create.sql
-- ============================================

-- ============================================================================
-- Mutation: create
-- Entity: Contact
-- Pattern: App Wrapper + Core Logic + FraiseQL Metadata
-- ============================================================================

-- ============================================================================
-- APP WRAPPER: create
-- API Entry Point (GraphQL/REST)
-- ============================================================================
CREATE OR REPLACE FUNCTION app.create(
    auth_tenant_id UUID,              -- JWT context: tenant_id
    auth_user_id UUID,                -- JWT context: user_id
    input_payload JSONB               -- User input (GraphQL/REST)
) RETURNS app.mutation_result
LANGUAGE plpgsql
AS $$
DECLARE
    input_data app.type_create_input;
BEGIN
    -- Convert JSONB → Typed Composite
    input_data := jsonb_populate_record(
        NULL::app.type_create_input,
        input_payload
    );

    -- Delegate to core business logic
    RETURN crm.create(
        auth_tenant_id,
        input_data,
        input_payload,
        auth_user_id
    );
EXCEPTION
    WHEN OTHERS THEN
        -- Handle unexpected errors
        RETURN ROW(
            '00000000-0000-0000-0000-000000000000'::UUID,
            ARRAY[]::TEXT[],
            'failed:unexpected_error',
            'An unexpected error occurred',
            NULL::JSONB,
            jsonb_build_object('error', SQLERRM, 'detail', SQLSTATE)
        )::app.mutation_result;
END;
$$;

COMMENT ON FUNCTION app.create IS
'Performs create operation on Contact.
Validates input and delegates to core business logic.

@fraiseql:mutation
name: create
input_type: app.type_create_input
success_type: CreateSuccess
failure_type: CreateError';

-- ============================================================================
-- CORE LOGIC: crm.create_contact
-- Business Rules & Data Manipulation
-- ============================================================================
CREATE OR REPLACE FUNCTION crm.create_contact(
    auth_tenant_id UUID,
    input_data app.type_create_contact_input,
    input_payload JSONB,
    auth_user_id UUID
) RETURNS app.mutation_result
LANGUAGE plpgsql
AS $$
DECLARE
    v_contact_id UUID := gen_random_uuid();
    v_contact_pk INTEGER;
BEGIN
    -- === VALIDATION ===

    -- === UUID → INTEGER RESOLUTION (Trinity Helpers) ===

    -- === BUSINESS LOGIC: INSERT ===
    INSERT INTO crm.tb_contact (
        id,
        tenant_id,
        email,
        first_name,
        last_name,
        phone,
        created_at,
        created_by
    ) VALUES (
        v_contact_id,
        auth_tenant_id,
        input_data.email,
        input_data.first_name,
        input_data.last_name,
        input_data.phone,
        now(),
        auth_user_id
    )
    RETURNING pk_contact INTO v_contact_pk;

    -- === AUDIT & RETURN ===
    RETURN app.log_and_return_mutation(
        auth_tenant_id,
        auth_user_id,
        'contact',
        v_contact_id,
        'INSERT',
        'success',
        ARRAY(SELECT jsonb_object_keys(input_payload)),
        'Contact created successfully',
        (SELECT row_to_json(t.*) FROM crm.tb_contact t WHERE t.id = v_contact_id)::JSONB,
        NULL
    );
END;
$$;

COMMENT ON FUNCTION crm.create IS
  '@fraiseql:mutation
   name=create
   input=CreateInput
   success_type=CreateSuccess
   error_type=CreateError
   primary_entity=Contact
   metadata_mapping={}';

-- ============================================
-- File: 30_functions/create_contact.sql
-- ============================================

-- ============================================================================
-- Mutation: create_contact
-- Entity: Contact
-- Pattern: App Wrapper + Core Logic + FraiseQL Metadata
-- ============================================================================

-- ============================================================================
-- APP WRAPPER: create_contact
-- API Entry Point (GraphQL/REST)
-- ============================================================================
CREATE OR REPLACE FUNCTION app.create_contact(
    auth_tenant_id UUID,              -- JWT context: tenant_id
    auth_user_id UUID,                -- JWT context: user_id
    input_payload JSONB               -- User input (GraphQL/REST)
) RETURNS app.mutation_result
LANGUAGE plpgsql
AS $$
DECLARE
    input_data app.type_create_contact_input;
BEGIN
    -- Convert JSONB → Typed Composite
    input_data := jsonb_populate_record(
        NULL::app.type_create_contact_input,
        input_payload
    );

    -- Delegate to core business logic
    RETURN crm.create_contact(
        auth_tenant_id,
        input_data,
        input_payload,
        auth_user_id
    );
EXCEPTION
    WHEN OTHERS THEN
        -- Handle unexpected errors
        RETURN ROW(
            '00000000-0000-0000-0000-000000000000'::UUID,
            ARRAY[]::TEXT[],
            'failed:unexpected_error',
            'An unexpected error occurred',
            NULL::JSONB,
            jsonb_build_object('error', SQLERRM, 'detail', SQLSTATE)
        )::app.mutation_result;
END;
$$;

COMMENT ON FUNCTION app.create_contact IS
'Creates a new Contact record.
Validates input and delegates to core business logic.

@fraiseql:mutation
name: createContact
input_type: app.type_create_contact_input
success_type: CreateContactSuccess
failure_type: CreateContactError';

-- ============================================================================
-- CORE LOGIC: crm.create_contact
-- Business Rules & Data Manipulation
-- ============================================================================
CREATE OR REPLACE FUNCTION crm.create_contact(
    auth_tenant_id UUID,
    input_data app.type_create_contact_input,
    input_payload JSONB,
    auth_user_id UUID
) RETURNS app.mutation_result
LANGUAGE plpgsql
AS $$
DECLARE
    v_contact_id UUID := gen_random_uuid();
    v_contact_pk INTEGER;
    v_fk_company INTEGER;
BEGIN
    -- === VALIDATION ===

    -- === UUID → INTEGER RESOLUTION (Trinity Helpers) ===
    IF input_data.company_id IS NOT NULL THEN
        v_fk_company := crm.company_pk(input_data.company_id::TEXT, auth_tenant_id);

        IF v_fk_company IS NULL THEN
            RETURN app.log_and_return_mutation(
                auth_tenant_id,
                auth_user_id,
                'contact',
                '00000000-0000-0000-0000-000000000000'::UUID,
                'NOOP',
                 'validation:reference_not_found',
                ARRAY['company_id']::TEXT[],
                 'Referenced company not found',
                NULL, NULL,
                jsonb_build_object('company_id', input_data.company_id)
            );
        END IF;
    END IF;

    -- === BUSINESS LOGIC: INSERT ===
    INSERT INTO crm.tb_contact (
        id,
        tenant_id,
        email,
        first_name,
        last_name,
        fk_company,
        status,
        phone,
        created_at,
        created_by
    ) VALUES (
        v_contact_id,
        auth_tenant_id,
        input_data.email,
        input_data.first_name,
        input_data.last_name,
        v_fk_company,
        input_data.status,
        input_data.phone,
        now(),
        auth_user_id
    )
    RETURNING pk_contact INTO v_contact_pk;

    -- === AUDIT & RETURN ===
    RETURN app.log_and_return_mutation(
        auth_tenant_id,
        auth_user_id,
        'contact',
        v_contact_id,
        'INSERT',
        'success',
        ARRAY(SELECT jsonb_object_keys(input_payload)),
        'Contact created successfully',
        (SELECT row_to_json(t.*) FROM crm.tb_contact t WHERE t.id = v_contact_id)::JSONB,
        NULL
    );
END;
$$;

COMMENT ON FUNCTION crm.create_contact IS
  '@fraiseql:mutation
   name=createContact
   input=CreateContactInput
   success_type=CreateContactSuccess
   error_type=CreateContactError
   primary_entity=Contact
   metadata_mapping={}';

-- ============================================
-- File: 30_functions/qualify_lead.sql
-- ============================================

-- ============================================================================
-- Mutation: qualify_lead
-- Entity: Contact
-- Pattern: App Wrapper + Core Logic + FraiseQL Metadata
-- ============================================================================

-- ============================================================================
-- APP WRAPPER: qualify_lead
-- API Entry Point (GraphQL/REST)
-- ============================================================================
CREATE OR REPLACE FUNCTION app.qualify_lead(
    auth_tenant_id UUID,              -- JWT context: tenant_id
    auth_user_id UUID,                -- JWT context: user_id
    input_payload JSONB               -- User input (GraphQL/REST)
) RETURNS app.mutation_result
LANGUAGE plpgsql
AS $$
DECLARE
    input_data app.type_qualify_lead_input;
BEGIN
    -- Convert JSONB → Typed Composite
    input_data := jsonb_populate_record(
        NULL::app.type_qualify_lead_input,
        input_payload
    );

    -- Delegate to core business logic
    RETURN crm.qualify_lead(
        auth_tenant_id,
        input_data,
        input_payload,
        auth_user_id
    );
EXCEPTION
    WHEN OTHERS THEN
        -- Handle unexpected errors
        RETURN ROW(
            '00000000-0000-0000-0000-000000000000'::UUID,
            ARRAY[]::TEXT[],
            'failed:unexpected_error',
            'An unexpected error occurred',
            NULL::JSONB,
            jsonb_build_object('error', SQLERRM, 'detail', SQLSTATE)
        )::app.mutation_result;
END;
$$;

COMMENT ON FUNCTION app.qualify_lead IS
'Performs qualify lead operation on Contact.
Validates input and delegates to core business logic.

@fraiseql:mutation
name: qualifyLead
input_type: app.type_qualify_lead_input
success_type: QualifyLeadSuccess
failure_type: QualifyLeadError';

-- ============================================================================
-- CORE LOGIC: crm.qualify_lead
-- Custom Business Action
-- ============================================================================
CREATE OR REPLACE FUNCTION crm.qualify_lead(
    auth_tenant_id UUID,
    input_data app.type_qualify_lead_input,
    input_payload JSONB,
    auth_user_id UUID
) RETURNS app.mutation_result
LANGUAGE plpgsql
AS $$
DECLARE
    v_contact_id UUID := input_data.id;
    v_contact_pk INTEGER;
    v_current_status TEXT;
    v_fk_company INTEGER;
BEGIN
    -- Debug: Input parameters
    RAISE NOTICE 'qualify_lead: input_data.id=%, auth_tenant_id=%', input_data.id, auth_tenant_id;
    -- Fetch current values for validation: status = 'lead'
    RAISE NOTICE 'Before SELECT: v_contact_id=%, auth_tenant_id=%', v_contact_id, auth_tenant_id;
    SELECT status INTO v_current_status
    FROM crm.tb_contact WHERE id = v_contact_id AND tenant_id = auth_tenant_id;
    RAISE NOTICE 'After SELECT: v_current_status=%', v_current_status;
    -- Validate: status = 'lead'
    RAISE NOTICE 'Before validation: v_current_status=%', v_current_status;
    IF NOT (v_current_status = 'lead') THEN
        RETURN app.log_and_return_mutation(
            auth_tenant_id, auth_user_id, 'contact', v_contact_id,
            'CUSTOM', 'failed:validation_error',
            ARRAY[]::TEXT[], 'not_a_lead', NULL, NULL
        );
    END IF;
    -- Update Contact
    UPDATE crm.tb_contact SET status = 'qualified', updated_at = now(), updated_by = auth_user_id
    WHERE id = v_contact_id;

    -- === SUCCESS RESPONSE ===
    RETURN app.log_and_return_mutation(
        auth_tenant_id,
        auth_user_id,
        'contact',
        v_contact_id,
        'CUSTOM',
        'success',
        ARRAY[]::TEXT[],
        'Qualify Lead completed',
        (SELECT row_to_json(t.*) FROM crm.tb_contact t WHERE t.id = v_contact_id)::JSONB,
        NULL
    );
END;
$$;

COMMENT ON FUNCTION crm.qualify_lead IS
  '@fraiseql:mutation
   name=qualifyLead
   input=QualifyLeadInput
   success_type=QualifyLeadSuccess
   error_type=QualifyLeadError
   primary_entity=Contact
   metadata_mapping={}';

-- ============================================
-- File: 30_functions/update.sql
-- ============================================

-- ============================================================================
-- Mutation: update
-- Entity: Contact
-- Pattern: App Wrapper + Core Logic + FraiseQL Metadata
-- ============================================================================

-- ============================================================================
-- APP WRAPPER: update
-- API Entry Point (GraphQL/REST)
-- ============================================================================
CREATE OR REPLACE FUNCTION app.update(
    auth_tenant_id UUID,              -- JWT context: tenant_id
    auth_user_id UUID,                -- JWT context: user_id
    input_payload JSONB               -- User input (GraphQL/REST)
) RETURNS app.mutation_result
LANGUAGE plpgsql
AS $$
DECLARE
    input_data app.type_update_input;
BEGIN
    -- Convert JSONB → Typed Composite
    input_data := jsonb_populate_record(
        NULL::app.type_update_input,
        input_payload
    );

    -- Delegate to core business logic
    RETURN crm.update(
        auth_tenant_id,
        input_data,
        input_payload,
        auth_user_id
    );
EXCEPTION
    WHEN OTHERS THEN
        -- Handle unexpected errors
        RETURN ROW(
            '00000000-0000-0000-0000-000000000000'::UUID,
            ARRAY[]::TEXT[],
            'failed:unexpected_error',
            'An unexpected error occurred',
            NULL::JSONB,
            jsonb_build_object('error', SQLERRM, 'detail', SQLSTATE)
        )::app.mutation_result;
END;
$$;

COMMENT ON FUNCTION app.update IS
'Performs update operation on Contact.
Validates input and delegates to core business logic.

@fraiseql:mutation
name: update
input_type: app.type_update_input
success_type: UpdateSuccess
failure_type: UpdateError';

-- ============================================================================
-- CORE LOGIC: crm.update_contact
-- Business Rules & Data Manipulation
-- ============================================================================
CREATE OR REPLACE FUNCTION crm.update_contact(
    auth_tenant_id UUID,
    input_data app.type_update_contact_input,
    input_payload JSONB,
    auth_user_id UUID
) RETURNS app.mutation_result
LANGUAGE plpgsql
AS $$
DECLARE
    v_contact_id UUID;
    v_contact_pk INTEGER;
BEGIN
    -- === VALIDATION ===
    -- Check if entity exists and belongs to tenant
    SELECT id, pk_contact
    INTO v_contact_id, v_contact_pk
    FROM crm.tb_contact
    WHERE id = input_data.id::UUID
      AND tenant_id = auth_tenant_id;

    IF v_contact_id IS NULL THEN
        RETURN app.log_and_return_mutation(
            auth_tenant_id,
            auth_user_id,
            'contact',
            input_data.id::UUID,
            'NOOP',
             'validation:reference_not_found',
            ARRAY['id']::TEXT[],
             'Referenced contact not found',
            NULL, NULL,
            jsonb_build_object('entity_id', input_data.id)
        );
    END IF;

    -- === UUID → INTEGER RESOLUTION (Trinity Helpers) ===

    -- === BUSINESS LOGIC: UPDATE ===
    UPDATE crm.tb_contact
    SET
        email = input_data.email,
        first_name = input_data.first_name,
        last_name = input_data.last_name,
        phone = input_data.phone,
        updated_at = now(),
        updated_by = auth_user_id
    WHERE id = v_contact_id
      AND tenant_id = auth_tenant_id;

    -- === AUDIT & RETURN ===
    RETURN app.log_and_return_mutation(
        auth_tenant_id,
        auth_user_id,
        'contact',
        v_contact_id,
        'UPDATE',
        'success',
        ARRAY(SELECT jsonb_object_keys(input_payload)),
        'Contact updated successfully',
        (SELECT row_to_json(t.*) FROM crm.tb_contact t WHERE t.id = v_contact_id)::JSONB,
        NULL
    );
END;
$$;

COMMENT ON FUNCTION crm.update IS
  '@fraiseql:mutation
   name=update
   input=UpdateInput
   success_type=UpdateSuccess
   error_type=UpdateError
   primary_entity=Contact
   metadata_mapping={}';
